<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API first</title>
    <url>/2020/08/17/api-design/api_first_approach/</url>
    <content><![CDATA[<blockquote>
<p>本文是 <a href="https://swagger.io/resources/articles/adopting-an-api-first-approach/">Understanding the API-First Approach to Building Products</a><br>的翻译，进供学习交流。如有翻译不当，请斧正。所有权归原作者。侵删。</p>
</blockquote>
<p><img src="https://static1.smartbear.co/swagger/media/images/resources/articles/api-first-approach-to-products.png" alt="swagger smartbear"></p>
<p>———— 珍妮特·瓦格纳（Janet Wagner）</p>
<p>Web API已经存在将近20年了，但是直到最近几年，“API优先” 的概念才在软件团队中引起关注。采用API优先方法构建产品的开发人员数量正在增加。<br>因此，今天我们将首先向您介绍API的概念，以及为什么这种方法越来越重要。</p>
<span id="more"></span>

<h2 id="API优先方法意味着什么？"><a href="#API优先方法意味着什么？" class="headerlink" title="API优先方法意味着什么？"></a>API优先方法意味着什么？</h2><p>以API优先意味着对于任何给定的开发项目，您的API都被视为“一等公民”。关于项目的一切都围绕着这样的想法：最终产品将由移动设备使用，<br>而API将由客户端应用程序使用。API优先方法涉及开发一致且可重用的API，这可以通过使用<br><a href="https://swagger.io/resources/articles/difference-between-api-documentation-specification/">API描述语言</a><br>来约束API的编写。这些约束可能会让API设计花费更多的时间。它还经常涉及额外的计划和利益相关者在编码前就设计提供的反馈。</p>
<h2 id="API越来越流行"><a href="#API越来越流行" class="headerlink" title="API越来越流行"></a>API越来越流行</h2><p>现在，人们通过手机、笔记本、平板和台式机等不同设备中的应用程序使用数据。考虑到不同设备的屏幕尺寸，就需要构建能在所有设备上显示正常且良好运行的程序。<br>API使公司可以将功能分解为单独的自治服务（也称为微服务）。基于微服务的程序可以在所有设备上都具有良好的用户体验(UX) 。API有限策略可以组织构建应用于<br>所有程序的API，而且可以对所设备、平台、操作系统有效地开发和维护。</p>
<h2 id="API优先方法的好处"><a href="#API优先方法的好处" class="headerlink" title="API优先方法的好处"></a>API优先方法的好处</h2><p>以API优先的产品构建方法可带来诸多好处，包括但不限于：</p>
<h3 id="开发团队可以并行工作"><a href="#开发团队可以并行工作" class="headerlink" title="开发团队可以并行工作"></a>开发团队可以并行工作</h3><p>API 首先建立约定[^1]。在 API 约定[^1]之下，团队可以同时使用多个 API 。开发人员不必发布 API 更新就可以继续使用下一个 API ，团队根据 API 约定 mock API<br>测试 API 的依赖性。</p>
<h3 id="减少开发成本"><a href="#减少开发成本" class="headerlink" title="减少开发成本"></a>减少开发成本</h3><p>API 和代码可以在许多不同项目上重用。当开发团队需要构建新的应用时，不必重头开始，这既费时又费钱。API 优先设计还允许在编写任何代码之前就解决大多数问题，<br>避免在 API 于应用集成时出现问题。</p>
<h3 id="加快上市速度"><a href="#加快上市速度" class="headerlink" title="加快上市速度"></a>加快上市速度</h3><p>使用允许导入 API 定义文件的工具，可以自动构建 API 的大部分过程。像 <a href="https://swagger.io/tools/swaggerhub/">SwaggerHub</a> 允许导入 API<br>定义文件，像 API 文档、SDK、和 mock API 都可以自动生成。自动化极大地加快了API和应用程序的开发。</p>
<p>API首先还可以为应用程序添加新的服务和技术，而不必重新架构整个系统。在开发应用程序方面，竞争非常激烈，因此必须快速开发应用程序。<br>如今，应用程序不仅必须经过精心设计，而且必须在六个月内推向市场。</p>
<h3 id="确保良好的开发人员体验"><a href="#确保良好的开发人员体验" class="headerlink" title="确保良好的开发人员体验"></a>确保良好的开发人员体验</h3><p>API的使用者通常是开发人员，开发人员的经验（DX）可以决定API的成败。 API 优先，可以保证开发人员在使用您的 API 时有良好的体验。。设计良好、文档良好、<br>一致性 API 可以为开发人员提供了积极的体验，因为它更容易重用代码，更容易让开发人员参与其中，并且减少了学习曲线。</p>
<h3 id="降低故障风险"><a href="#降低故障风险" class="headerlink" title="降低故障风险"></a>降低故障风险</h3><p>对于大多数的公司而言，API几乎用于每个业务流程-从营销和销售到通讯和面向消费者的应用程序，这意味着API可以对您的业务的各个方面产生正面或负面的影响。<br>API首先通过确保API可靠，一致且易于开发人员使用来降低失败的风险。</p>
<h2 id="计划您的API优先程序"><a href="#计划您的API优先程序" class="headerlink" title="计划您的API优先程序"></a>计划您的API优先程序</h2><p>既然您已经知道API优先方法在产品开发中的一些好处，那么您应该如何计划和实施API优先方法呢？</p>
<p>以下几点是你在计划 API 优先的时候要注意的：</p>
<ol>
<li><strong>集思广益</strong>：首先，有必要确定您的业务提供的关键服务和业务能力。弄清楚应该构建的API的种类以及应该通过API提供的服务。<br> 另外，找出并写下每个API的用例。根据这些用例写下潜在的端点。</li>
<li><strong>建立 API 受众</strong>: 谁是您组织中的利益相关者？您的API计划应包含尽可能多的人-您需要公司范围内的支持，并需要组织内团队共享的愿景。然后，<br> 利益相关者可以就整个组织之间的交互达成一致，以使API保持一致。<br>３. <strong>设计 API 约定[^1]</strong>: 约定[^1]为设计 API 建立了一套标准和最佳实践。确保描述和记录所有API。从端点名称和URL到错误代码和版本控制，<br> 确保所有API的工作方式相同。一致性是关键。</li>
<li><strong>定义风格指南</strong>: 全面，具有凝聚力的风格指南可确保组织服务的团队之间的一致性。API状态代码，版本控制，错误处理等将被标准化，<br> 以确保以相同的方式设计API。使用SwaggerHub之类的工具为组织中的所有API创建样式指南。</li>
<li><strong>实施API治理</strong>: API治理流程可以帮助强制执行既定标准并增强预期结果。我们将在即将发表的博客文章中讨论API治理。<br> 进行对等代码审查还可以帮助确保遵循API设计标准，并确保开发人员在生产高质量的代码。</li>
<li><strong>自动化流程</strong>: 使用SwaggerHub之类的工具来自动化流程，例如生成API文档，样式验证，API模拟和版本控制。另外，使API成为自助服务，<br> 以便开发人员可以立即开始使用您的API构建应用。提供交互式文档或沙箱，以便开发人员可以试用API端点。</li>
<li><strong>跟踪和管理您的API产品组合</strong>: 通过跟踪和管理您的API产品组合，避免重复代码和构建冗余API。实施有助于您跟踪和管理API的系统。<br> 您的组织和平台越大，跟踪API及其依赖性的难度就越大。</li>
<li><strong>为内部开发人员创建网站</strong>: 为内部开发人员创建一个中心位置，一个存储所有API的内容的地方-API规范，文档，合同等。例如，据<a href="https://www.infoq.com/articles/paypal-api-first-part1">InfoQ的一篇文章</a>，<br> 贝宝（PayPal）为开发人员建立了门户，它是“贝宝（PayPal）中访问量最大的内部应用程序之一”。贝宝的门户网站包含所有API，文档，仪表板等的清单。</li>
</ol>
<h2 id="API作为一等公民"><a href="#API作为一等公民" class="headerlink" title="API作为一等公民"></a>API作为一等公民</h2><p>API优先的产品构建方法可以使您的组织从许多方面受益。API优先方法要求团队计划，组织和共享其API程序的愿景。它还需要采用支持API优先方法的工具。</p>
<p>[^1]: 这里的约定其实就是 API 设计规范。</p>
]]></content>
      <tags>
        <tag>api-design</tag>
      </tags>
  </entry>
  <entry>
    <title>大规模分解API优先转换。在PayPal学习的经验教训–第3部分</title>
    <url>/2020/08/28/api-design/paypal_api_first_part3/</url>
    <content><![CDATA[<blockquote>
<p>本文是 <a href="https://www.infoq.com/articles/paypal-api-first-part3/?itm_source=infoq&itm_campaign=user_page&itm_medium=link">Untangling an API-First Transformation at Scale. Lessons Learnt at PayPal – Part 3</a><br>的翻译，仅供学习交流。如有翻译不当，请斧正。所有权归原作者，侵删。</p>
</blockquote>
<p><strong>要点</strong></p>
<ul>
<li>寻找到在你的组织中有效的参与策略。</li>
<li>建立一支强大的团队，以建立信誉和提供良好得客户体验所需的人才。</li>
<li>找到“推动”和“拉动”激励措施的良好平衡，以吸引开发人员参与。</li>
<li>在集中治理和协作之间找到适当的平衡。</li>
<li>了解您如何适应SDLC，以及如何在每个阶段最好地增加价值。</li>
</ul>
<p>这是一个由三部分组成的系列文章的第3部分，该系列探讨了PayPal如何采用更为API第一的方法来构建平台服务。在第一部分中，我们探讨了迁移到松散耦合，<br>API驱动的体系结构的原因，以及使该过程大规模运行所需的一些基础结构。在第二篇中，我们更深入地研究了API本身的管理方式。在本文中，<br>我们将仔细研究程序方面以及必须克服的一些执行和操作挑战。</p>
<span id="more"></span>

<p><strong>迪帕克·纳迪格（Deepak Nadig）：当您首次启动该计划时，最大的挑战是什么？</strong></p>
<blockquote>
<p><strong>埃里克·霍根（Erik Hogan）</strong>：我想到了一些。<br>最初，我们面临着一个习惯于现状的工程和产品组织，并且已经经历了从瀑布到敏捷的过渡。该组织的态度不是这里发明的，而是一群坚强而坚定的长期开发人员，<br>他们具有很高的抵抗力和影响力。过去曾尝试过几次旨在重构平台或进行SOA转换的类似程序，但都取得了不同的成功。出于合理的考虑，<br>这种新得努力只会导致更多的复杂性，更多的混乱和更多的技术债务。仅仅让他们购买并支持该计划是一个障碍。</p>
<p>了解公司的范围和能力是另一个巨大的挑战。十五年的开发产生了大量的代码并解决了许多用例，其中大部分并未真正记录在案。<br>必须对现有业务流程有一个很好的了解，才能对我们希望API产品组合最终看起来形成一个合理准确的愿景。</p>
<p>最后是如何构建程序。没有蓝图，我们必须制定既可行又能适应组织细微差别和成熟度水平的战略。那需要时间。企业没有密切参与过去的努力。<br>我们基本上从零开始。</p>
</blockquote>
<p><strong>迪帕克·纳迪格（Deepak Nadig）：您是如何克服这些障碍的？</strong></p>
<blockquote>
<p>Erik Hogan： 我将从策略开始。<br>自上而下的压力很大，以取得进展。CTO，CEO和相当多得技术VP认为我们需要进行更改，并将程序视为解决方案的一部分。从这个意义上讲，<br>我们不需要向上层管理人员兜售价值。他们了解，如果我们继续保持现状，我们将无法提高敏捷性并不能足够快地将新产品推向市场。<br>创新步伐缓慢和每次新集成的高昂成本使他们感到不高兴。</p>
<p>我们探索了几个不同的参与模型。第一步是在每个领域招募技术领导者，以成为“冠军”。这样做的目的是创建可以宣传团队中的原则和标准的专家。<br>我们聚在一起开会，进行了一些学习，当然–-这没有什么大不了的。倡导者喜欢这个主意，但是由于他们仍然有自己的日常工作，因此没有真正的动力去贯彻。<br>其他干部或多或少已被其经理“自愿”参加。他们不仅不一定要相信我们正在尝试做的事情，而且也并没有真正为此负责。然后就失败了。</p>
<p>我们还探索了扩展开发工具，以鼓励我们整合在一起的设计模式和标准。尽管它本身可以提供很多价值，并且实际上是成功的必要条件，<br>但是仅凭这一点还不足以重塑和巩固服务组合的能力边界。如果您有猪，使用口红并不能从根本上改变您只能制作培根和猪排的事实。<br>如果您想要一个很好的分离和敏捷的平台，则需要更深入地思考。</p>
<p>经过沉思后，我们终于开始形成我们认为可行的愿景。作为数据驱动的管理人员，需要一些简单的指标，他们可以使用这些指标来跟踪进度并使他们的团队负责。<br>他们主要对我们正在取得多少进展以及何时“完成”感兴趣。我们还知道这将花费很长时间（数年），并且我们需要一个模型，<br>该模型可以使我们灵活地分阶段进行转换。</p>
<p>我们决定采用API成熟度模型的思想，该模型封装了我们开发的标准。我们编写了客观可验证的标准，并以1-5的比例进行绘制。在优先级方面，<br>我们想强调设计良好的界面，并将其作为首要目标与业务能力模型相一致。这样的想法是，如果我们能够正确使用接口，那么我们就可以在业务功能之间<br>建立稳定的边界，开始迁移遗留流量，并逐步重构基础服务的实现。我们最终将获得一组封装良好的微服务，但是我们可以在不吸收前端整个重构的情况下，<br>获得API提供的大多数业务敏捷性和集成成本收益。成熟度级别3代表此步骤。实现完整数据和服务封装的API的成熟度为5。</p>
<p>要计算完成百分比指标，我们需要一个分母。我们的方法是定义一个业务能力模型，并模拟我们认为主要资源和端点将处于最终状态的东西。一个由六到<br>七个业务架构师组成的团队在一年中的大部分时间里都在分析用例，采访领域负责人，进行代码取证并记录业务流程以得出模型。这绝不是完美的，<br>但是它确实给了我们一些可用来追踪进度的分母。</p>
<p>最后，我们出售管理层的想法是，在第一年就将投资组合的目标百分比建立到3级成熟度，并且至关重要的是，我们得到了他们的承诺，将这一目标推广给所有经理。<br>这适用于产品和工程组织。第一步，我们解决了测量，逐步发展和优先级调整问题。至关重要的是，我们还用简单的数字表示了我们的进步，公司中的每个人<br>都可以理解。从内部营销的角度来看，这是非常强大的。我们设定的目标是，到2014年底，通过RESTful，符合标准的API公开的投资组合中占75％。<br>最终，我们大幅度击败了这一目标。</p>
</blockquote>
<p><strong>Deepak Nadig：团队有多少人，他们扮演什么角色？</strong> </p>
<blockquote>
<p><strong>埃里克·霍根（Erik Hogan）</strong>：根据该计划成立了一个平台产品小组。最初有大约7个人。这是分解业务架构，定义业务功能，管理API产品组合以及管理<br>基础架构和工具路线图以使整个程序成为可能的核心团队。</p>
<p>这些都是非常资深的技术产品经理，大多具有工程背景，他们对设计出色的平台充满热情。他们审查每个构建的API，并根据目标业务体系结构进行评估。<br>他们确定命名并尝试确保整个产品组合中的产品一致性。最重要的是，他们试图始终代表客户的观点，并确保内部概念，首字母缩写词和术语不会“泄漏”到外部接口中。<br>开发人员倾向于关注特定问题。这些产品组合经理可以在此处应用整体的平台视图，并帮助将开发人员的工作塑造为尽可能可重用的API。</p>
<p>另一个非常关键的组是我们称为API设计器的组。这些都是非常特殊的工程师，具有丰富的体系结构，界面设计技能，以客户为中心，以及对教育和指导的热情。<br>拥有其中一些技能并不少见，但在同一个人中找到全部技能却很不寻常。我们很幸运地找到了一些非常出色的人，他们能够将这个团队建设成为该计划的核心力量。<br>他们的工作不仅是定义和维护标准，还要宣传它们，教育组织并根据成熟度模型中的标准审查API规范请求。与开发人员的这种直接互动是大多数教育和学习实际发生<br>的地方。这也是我们获得大量实际信誉的地方。在最初的扩展年中，我们这个小组中只有三到四个人。他们检查了所有API，非常忙。</p>
<p>第三组是一个小型Scrum团队，专注于扩展程序所需的基础架构。刚开始的时候，我们对任何商业产品都不满意，因此我们建立了自己的内部开发人员门户。<br>它提供了所有API的可发现性，自动化了成熟度分数计算，提供了一些基本的工作流程，跟踪了生命周期状态，并实施了版本控制策略。<br>该核心系统还生成有关程序状态的必要报告，并将其汇总到各个团队和业务组织。随着时间的流逝，该团队还建立了库，API和插件，以简化SDLC，<br>并使开发人员更易于部署其API。</p>
<p>最后一组是计划管理，其工作是协调所有团队的活动并总体控制跨域风险。特别是在开始时，我们发现组织中不同团队和业务部门的许多重复开发。<br>投资组合驱动方法的显着优势是减少重复投资并提高可重用性。这需要高级领导做出一些艰难的决定，最终，这些决定导致团队被重新分配到其他项目。<br>计划管理在促进这些成果方面发挥了关键作用。</p>
</blockquote>
<p><strong>迪帕克·纳迪格（Deepak Nadig）：除了设定最高目标之外，您还采取了哪些措施来获得支持并鼓励开发人员和产品经理参与？</strong></p>
<blockquote>
<p><strong>Erik Hogan</strong>：公平地说，大多数开发人员实际上从一开始就支持我们所做的事情。我们提议从专有解决方案过渡到更多行业标准的方法，例如REST和OAuth2。<br>任何最近看过外界并且没有亲自投资于将要替换的东西的人，都凭直觉理解了采用与其他人相同的标准的价值。它也使他们个人感兴趣，因为他们将不得不使用<br>更现代的工具和技术来提高其可销售性。</p>
<p>在对我们要做的事情进行了更多的教育之后，大多数没有立即加入的人改变了主意。有一些顽固派顽固地坚持到最后，但是在我们阐明了清晰的愿景和实现这一目标<br>的计划之后，势头明显转移了。</p>
<p>我们试图找到创造性的方法来“吸引”开发人员。我们为最佳新服务设立了月度奖项，并在全体会议上公开认可了该团队。几个月后，团队积极游说该计划以赢得该奖项，<br>因此它肯定产生了作用。</p>
<p>我们还举办了黑客马拉松，鼓励创造性地使用新的API。这些不仅对激励服务开发人员很重要，而且对于消除SDLC中的错误和漏洞也很重要。副作用是，<br>它向服务开发人员表明他们在其直接项目之外拥有客户。对于许多人来说，想到一个甚至不问他们就将其集成到服务中的想法是一个奇怪的想法。这不是他们习惯的。<br>这是文化上的转变，这也说明了为什么好的文档实际上真的很重要。API不仅仅是项目。它们是需要持续支持以及希望有良好开发经验的产品。</p>
</blockquote>
<p><strong>迪帕克·纳迪格（Deepak Nadig）：像这样的程序总是有可能开始变得强大而失败。您做了什么以确保持续的长期成功？</strong></p>
<blockquote>
<p>埃里克·霍根（Erik Hogan）：  这是真的。通常会有一个强大的，最初的推动力，这是当务之急，取得了一些进展，然后组织转移到下一个新事物。<br>在某种程度上，在这种情况下也是如此。</p>
<p>我认为关键是要始终考虑您的长期策略并对环境的变化迅速做出反应。该程序本身就像一个产品。戴上产品帽会迫使您考虑客户，他们的需求，<br>您的竞争威胁以及如何保持增长。存在用于实现业务目的的程序，您需要确保自己做得很好，为期望值做出了贡献。</p>
<p>在我们的案例中，我们在第一年就获得了高层管理人员的大力支持。第二年，组织发生了许多变化，我们有了新的CEO，我们公开了上市，<br>并且有一系列非常不同的高层优先事项。我们的知名度急剧下降。</p>
<p>积极的结果是，这迫使我们加倍提高开发人员客户的满意度。我们变得更加以客户为中心，并系统地改善了困扰他们的领域。我们完善了我们的工具，<br>加快了审核过程，提高了开发人员教育水平，并消除了一些不必要的成熟度标准。过程中的摩擦减少了，更多的开发商积极参与其中。</p>
<p>我们注意到的另一件事是回头客在流程早期返回，并在SDLC早期寻求更多帮助。从本质上讲，我们向他们“销售”的产品-API设计专业知识-被认为对想要构建<br>优质服务的开发人员非常有价值。在许多情况下，我们最终节省了他们的时间，因此他们生产了更好的产品。来自各个领域的土著传教士更多，<br>这产生了积极的飞轮效应。</p>
<p>我们采用的另一种策略是尽可能地分散权力。这始终是原始计划的一部分，但我们觉得我们需要将事情保持集中，直到我们建立可重复的过程并完善支持<br>该过程的基础结构。在第二年末，我们开始在培训各个领域的开发人员如何自己进行API成熟度评估过程方面取得了一些成功。第三年，我们大力进行教育，<br>积极招募和培训了足够的开发人员来处理大多数API审查。现在，各领域正在制定自己的计划，以在每个团队中拥有“经过认证的” API设计人员，<br>因为他们已经看到了对其构建的服务质量的积极影响。我们正在转而担任更多的支持和监督角色，而方法论本身已成为每个团队的固有组成部分。</p>
<p>为了加强持久存在，您还应该弄清楚如何整合SDLC的每个阶段并为之做出贡献。最初，我们主要专注于设计阶段，因为我们希望确保我们拥有良好的API设计，<br>并尽可能遵循设计优先的方法。然后，我们通过提供一个供开发人员用来验证其服务实现与API规范匹配的库进入开发阶段。这将利用他们的功能测试来生成报告，<br>以识别存在差异的地方。它在识别错误​​和向后不兼容的更改（已潜入实现中）而不是API规范方面非常有效。最后，</p>
<p>总体而言，尽管组织和工作重点发生了一些剧烈变化，我们仍设法保持了势头并扩大了计划。以我的经验，大多数程序都在为此而努力。</p>
</blockquote>
<h2 id="关于被访者"><a href="#关于被访者" class="headerlink" title="关于被访者"></a>关于被访者</h2><p>Erik Hogan近二十年来一直在学习成为一名出色的产品经理意味着什么。大部分时间都花在了了解如何成为可以扩展的客户拥护者和可信赖的领导者上。他非常满意，<br>可以将复杂的问题分解为可重复使用的部分，并为工程提供准确执行快速执行所需的功能。最近，他一直在使用简单性，讲故事和专注等基本产品概念来影响组织变革，<br>这是一种非常不同的“产品”。同样，当他的妻子要求她的成功标准时，他仍然生气。</p>
<h2 id="关于面试官"><a href="#关于面试官" class="headerlink" title="关于面试官"></a>关于面试官</h2><p>Deepak Nadig  是Intuit的杰出建筑师。在加入Intuit之前，Deepak曾是PayPal API平台工程负责人，负责领导和转换内部和外部使用的PayPal API，<br>以处理1000亿美元的付款。Deepak在领先的工程和架构组织，eBay等大型在线网站以及VeriFone和HP等企业软件公司中拥有16年以上的经验。<br>迪帕克（Deepak）经常在会议上发表演讲，并热衷于在变革企业中使用技术。</p>
]]></content>
      <tags>
        <tag>api-design</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Web CloudNative [未完]</title>
    <url>/2020/05/28/cloudnative/python_web_cloudnative/</url>
    <content><![CDATA[<p>现在 CloudNative 那么火，当前基础设施环境也越来越成熟。诸如 Docker，K8s 到现在 DCI 标准的出现，使得 DevOps 越来越方便。本文以个人开发时总结的<br>一套 Python Web 开发在使用 gitalb-ci 和 Docker 环境上的实践。当然这只是第一版，以后也会在使用中不断优化开发管理和运维流程。</p>
<span id="more"></span>

<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>本项目以单 Web 项目为示例，以抛砖引玉。项目不注重业务功能，以最简单业务功能，模拟 Web 访问场景。但项目开发和组织是结合当前个人总结的开发实践来做的。如有缺陷，还望斧正。</p>
<p>项目以前后端分离。后端采用 <a href="https://fastapi.tiangolo.com/">fastapi</a> 框架开发，现在仅提供一个访问端点，后续优化可能会逐步增加数据库访问等依赖服务，尽可能模拟真实中小型 Web 开发场景。前端项目采用 <a href="https://reactjs.org/">react</a> 开发，使用 nodejs 构建成静态文件后由 nginx 加载后对外提供访问地址。前端页面调用后端服务。</p>
<h2 id="二、后端开发"><a href="#二、后端开发" class="headerlink" title="二、后端开发"></a>二、后端开发</h2><p>项目以 <code>httpbin</code> 命名，目的是在做示例项目之后，该项目可以像正常 <a href="https://httpbin.org/">httpbin</a> 一样可用。</p>
<p>项目 Python 环境为 <code>Python3.7</code> 。主要是 <code>fastapi</code> 是一个 <a href="https://asgi.readthedocs.io/en/latest/">ASGI</a> Web 框架，在 <code>Python 3.7</code> 异步支持更好。</p>
<h3 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1. 项目初始化"></a>1. 项目初始化</h3><p>安装 <a href="https://github.com/cookiecutter/cookiecutter">cookiecutter</a></p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">pip install cookiecutter</span><br></pre></td></tr></table></figure>

<p>使用已有项目模板创建项目，这个项目模板也是个人在实践过程中总结的通用 Python 项目模板。</p>
<p>如果无法使用，可以手动创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookiecutter http://git.tendata.com.cn/tendata/bigdata/cookiecutter-tendata-python.git</span><br></pre></td></tr></table></figure>

<p>项目模板结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── httpbin</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── Pipfile</span><br><span class="line">├── README.md</span><br><span class="line">├── setup.cfg</span><br><span class="line">├── setup.py</span><br><span class="line">├── tests</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── tox.ini</span><br></pre></td></tr></table></figure>

<h4 id="1-1-项目内容"><a href="#1-1-项目内容" class="headerlink" title="1.1 项目内容"></a>1.1 项目内容</h4><p>如果已经使用模板生成可以跳过</p>
<p><code>httpbin/__init__.py</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__version__ = &#x27;0.1.0&#x27;</span><br></pre></td></tr></table></figure>



<p><code>Pipfile</code></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[source]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;pypi&quot;</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://pypi.org/simple&quot;</span></span><br><span class="line"><span class="attr">verify_ssl</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dev-packages]</span></span><br><span class="line"><span class="attr">tox</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">isort</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">flake8</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[packages]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[requires]</span></span><br><span class="line"><span class="attr">python_version</span> = <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>项目依赖使用 <a href="https://github.com/pypa/pipenv">pipenv</a> 管理。初始模板带有四个开发环境时要使用的库。</p>
<p><code>README.md</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># httpbin</span></span><br><span class="line"></span><br><span class="line">This is a demo restful app developed using [<span class="string">fastapi web framework</span>](<span class="link">https://fastapi.tiangolo.com/</span>)</span><br></pre></td></tr></table></figure>



<p><code>setup.cfg</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[metadata]</span></span><br><span class="line"><span class="attr">name</span> = httpbin</span><br><span class="line"><span class="attr">version</span> = attr: httpbin.__version__</span><br><span class="line"><span class="attr">author</span> = wanghuagang</span><br><span class="line"><span class="attr">author_email</span> = huagang517@<span class="number">126</span>.com</span><br><span class="line"><span class="attr">description</span> = This is a demo resuful project</span><br><span class="line"><span class="attr">keywords</span> = [<span class="string">&#x27;httpbin&#x27;</span>, <span class="string">&#x27;fastaip&#x27;</span>, <span class="string">&#x27;restful&#x27;</span>]</span><br><span class="line"><span class="attr">long_description</span> = file: READMD.md</span><br><span class="line"><span class="attr">long_description_content_type</span>=<span class="string">&quot;text/markdown&quot;</span>,</span><br><span class="line"><span class="attr">classifiers</span> =</span><br><span class="line">    Operating System :: OS Independent</span><br><span class="line">    Programming Language :: Python :: 3.7</span><br><span class="line"></span><br><span class="line"><span class="section">[options]</span></span><br><span class="line"><span class="attr">python_requires</span>= &gt;=<span class="number">3.6</span></span><br><span class="line"><span class="attr">zip_safe</span> = <span class="literal">False</span></span><br><span class="line"><span class="attr">include_package_data</span> = <span class="literal">True</span></span><br><span class="line"><span class="attr">packages</span> = find:</span><br><span class="line"><span class="attr">install_requires</span> =</span><br><span class="line">    fastapi</span><br><span class="line">    uvicorn</span><br><span class="line"></span><br><span class="line"><span class="section">[options.packages.find]</span></span><br><span class="line"><span class="attr">exclude</span> = </span><br><span class="line">    tests</span><br><span class="line">    doc</span><br><span class="line"></span><br><span class="line"><span class="section">[flake8]</span></span><br><span class="line"><span class="attr">max-line-length</span> = <span class="number">120</span></span><br><span class="line"><span class="attr">exclude</span> =</span><br><span class="line">    build</span><br><span class="line">    .tox</span><br><span class="line">    .git,</span><br><span class="line"></span><br><span class="line"><span class="section">[isort]</span></span><br><span class="line"><span class="attr">not_skip</span> = __init__.py</span><br><span class="line"><span class="attr">skip</span> =</span><br><span class="line">    .tox</span><br><span class="line"></span><br><span class="line"><span class="section">[tool:pytest]</span></span><br><span class="line"><span class="attr">testpaths</span> = tests</span><br><span class="line"><span class="attr">python_files</span> = tests.py test_*.py *_tests.py</span><br></pre></td></tr></table></figure>

<p>为了减少源数据散落各处，项目打包源数据放在 <code>setup.cfg</code> 中，这是 <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html?highlight=setup.cfg#configuring-setup-using-setup-cfg-files">setuptools 30.3.0</a> 后新增的功能，所以在使用的时候，要注意版本。此文件中还放了其他库的要配置源数据。</p>
<p>项目依赖 <code>install_requires</code> 中包含了两个库，一个是 Web 框架 <code>fastapi</code> ，两一个是 <code>ASGI</code> 库 <code>uvicorn</code> 。这是运行 <code>fastapi</code> 程序需要用到的。</p>
<blockquote>
<p>注意： <code>version = attr: httpbin.__version__</code> 使用了 <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html?highlight=setup.cfg#specifying-values"><code>attr:</code></a> 特殊指令，其作用相当于 <code>import</code> ，如果 <code>httpbin/__init__.py</code> 中导入了第三方依赖，在执行 <code>tox</code> 或者在没有外部依赖的环境下执行 <code>python setup.py</code> 打包的时候会报缺少外部依赖的问题。因为依赖调用，而环境中又没有安装。此时要么把依赖从 <code>httpbin/__init__.py</code> 中移出去，要么在 <code>setuo.py</code> 中使用 <code>open</code> 方法读取 <code>httpbin/__init__.py</code> 文件，然后用正则匹配出对版本号。<code>re.search(r&quot;__version__ = [&#39;\&quot;]([^&#39;\&quot;]+)[&#39;\&quot;]&quot;, open([&#39;httpbin&#39;, &#39;__version__.py&#39;]).read(), re.M).group(1)</code></p>
</blockquote>
<p><code>setup.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"></span><br><span class="line">setuptools.setup()</span><br></pre></td></tr></table></figure>

<p>这个文件就不需要写太多参数啦。</p>
<p><code>tox.ini</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[tox]</span></span><br><span class="line"><span class="attr">skipsdist</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">envlist</span> = py37</span><br><span class="line"></span><br><span class="line"><span class="section">[testenv:py37]</span></span><br><span class="line"><span class="attr">usedevelop</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">deps</span> = </span><br><span class="line">    pipenv</span><br><span class="line"><span class="attr">commands</span> =</span><br><span class="line">    pipenv install -d</span><br><span class="line">    pytest</span><br><span class="line">    isort --recursive --check-only --diff</span><br><span class="line">    flake8</span><br></pre></td></tr></table></figure>



<p>至此，项目模板就是这样。</p>
<h4 id="1-2-初始开发环境"><a href="#1-2-初始开发环境" class="headerlink" title="1.2 初始开发环境"></a>1.2 初始开发环境</h4><p>使用 pipenv 初始化虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install</span><br></pre></td></tr></table></figure>

<p>使用 pipenv 安装 <code>fastapi</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install fastapi</span><br></pre></td></tr></table></figure>

<h4 id="1-3-初始化git"><a href="#1-3-初始化git" class="headerlink" title="1.3 初始化git"></a>1.3 初始化git</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>初始化 git 仓库，用于版本管理。这里记得创建 <code>.gitignore</code> 文件。</p>
<h3 id="2-项目开发"><a href="#2-项目开发" class="headerlink" title="2. 项目开发"></a>2. 项目开发</h3><h4 id="1-1-接口和路由"><a href="#1-1-接口和路由" class="headerlink" title="1.1 接口和路由"></a>1.1 接口和路由</h4><p>新建文件 <code>httpbin/routers.py</code> ，文件内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi.routing <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line">router = APIRouter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;now&#x27;</span>: datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %H:%D:%S&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅创建了一个接口，接口默认返回 JSON 数据。</p>
<h4 id="1-2-主程序"><a href="#1-2-主程序" class="headerlink" title="1.2 主程序"></a>1.2 主程序</h4><p>新建 <code>httpbin/server.py</code> ，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, __version__</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> httpbin.routers <span class="keyword">import</span> router</span><br><span class="line"></span><br><span class="line">app = FastAPI(</span><br><span class="line">    title=<span class="string">&#x27;httpbin&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;This is demo fastapi project&#x27;</span>,</span><br><span class="line">    version=__version__</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.include_router(router)</span><br></pre></td></tr></table></figure>

<p>首先初始化一个 <code>FastAPI</code> 对象，然后把前面定义的路由加载进去。</p>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>测试框架使用 <a href="https://docs.pytest.org/en/latest/">pytest</a> ,由于其强大的的特性和丰富的扩展插件，在编写测试的上更高效。</p>
<h4 id="3-1-配置测试"><a href="#3-1-配置测试" class="headerlink" title="3.1. 配置测试"></a>3.1. 配置测试</h4><p>新建 <code>tests/conftest.py</code> ，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> starlette.testclient <span class="keyword">import</span> TestClient</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> httpbin.server <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> TestClient(app)</span><br></pre></td></tr></table></figure>

<p><code>conftest.py</code> 为 pytest 的配置文件，在这里定义其他测试所依赖的内容。</p>
<p><code>fixture</code> 是一个很强大的功能，在使用 <code>yield</code> 关键字的时候可以让你直接在编写测试方法的情况下获得 <code>setup</code> 和 <code>teardown</code> 的效果。其 <code>scope</code> 参数可以配置 <code>function</code> 、 <code>class</code> 或者其他级别。具体请参考文档。</p>
<p>测试接口使用 <code>starlette.TestClient</code> ，其依赖 <code>requests</code> 库，所以要记得安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install -d requests</span><br></pre></td></tr></table></figure>



<h4 id="3-2-编写测试文件"><a href="#3-2-编写测试文件" class="headerlink" title="3.2.编写测试文件"></a>3.2.编写测试文件</h4><p>新建测试文件 <code>tests/test_api.py</code> ，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_index</span>(<span class="params">client</span>):</span></span><br><span class="line">    response = client.get(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> response.ok</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">    <span class="keyword">assert</span> json.loads(response.text).get(<span class="string">&#x27;now&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3-3-运行测试"><a href="#3-3-运行测试" class="headerlink" title="3.3. 运行测试"></a>3.3. 运行测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>



<h3 id="4-代码质量提升"><a href="#4-代码质量提升" class="headerlink" title="4. 代码质量提升"></a>4. 代码质量提升</h3><h4 id="4-1-运行-isort"><a href="#4-1-运行-isort" class="headerlink" title="4.1 运行 isort"></a>4.1 运行 isort</h4><p><a href="https://github.com/timothycrosley/isort">isort</a> 是一款自动格式化到包顺序的工具，运行后根据提示操作。格式化完成后，每个文件的导包会根据配置格式化。运行后有助于提升代码风格。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">isort</span><br></pre></td></tr></table></figure>

<h4 id="4-2-运行-flake8"><a href="#4-2-运行-flake8" class="headerlink" title="4.2 运行 flake8"></a>4.2 运行 flake8</h4><p><a href="https://flake8.pycqa.org/en/latest/">flake8</a>  是一款检测你的代码是否符合 <a href="https://www.python.org/dev/peps/pep-0008/#indentation">PEP8</a> 规范的工具。运行后有助于提升代码质量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flake8</span><br></pre></td></tr></table></figure>

<h3 id="5-自动化"><a href="#5-自动化" class="headerlink" title="5. 自动化"></a>5. 自动化</h3><p><a href="https://tox.readthedocs.io/en/latest/index.html">tox</a> 是一个自动化工具，通过配置可以编排需要执行的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tox</span><br></pre></td></tr></table></figure>

<p>在 <code>tox.ini</code> 文件中已经编写了对应的规则。一般在最后确定开发完成之后再运行一遍，用于最后检查项目是否还存在问题。</p>
<h3 id="6-运行项目"><a href="#6-运行项目" class="headerlink" title="6. 运行项目"></a>6. 运行项目</h3><p>以可编辑模式安装项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -e .</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uvicorn httpbin.server:app --port 8000 --host 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>端口和地址可以不指定。</p>
<p>访问地址 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a> 即可访问首页内容。</p>
<p><code>fastapi</code> 还提供了 <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md"><code>openapi 3.0规范</code></a>  的接口文档页面和对应的 schema 。访问 <a href="http://127.0.0.1:8000/docs">http”//127.0.0.1:8000/docs</a> 页面就能看到当前所有接口，方便前后端对接和调试。</p>
<p>在运行过程中如果发现异常问题，要及时排查和调整。修复后重复运行 <code>tox</code> 对项目重新自动化检测。</p>
<h3 id="7-提交代码"><a href="#7-提交代码" class="headerlink" title="7. 提交代码"></a>7. 提交代码</h3><p>提交代码前一定要运行一次 <code>tox</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;feat: 完善 httpbin 基本功能，测试正常。&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="三、后端-云原生"><a href="#三、后端-云原生" class="headerlink" title="三、后端-云原生"></a>三、后端-云原生</h2><h3 id="1-增加-Dockerfile"><a href="#1-增加-Dockerfile" class="headerlink" title="1. 增加 Dockerfile"></a>1. 增加 Dockerfile</h3><p>创建 ``Dockerfile` ，文件内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ##########################################################</span></span><br><span class="line"><span class="comment"># Build stage.</span></span><br><span class="line"><span class="comment"># Build python distribute package.</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span> as build</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PIP_INDEX_URL=https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> Pipfile Pipfile.lock  ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -U pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip3 install --no-cache-dir pipenv \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pipenv install --clear --system \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf ~/.cache/pipenv</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> httpbin ./httpbin</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> tests ./tests</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> setup.cfg setup.py README.md ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python setup.py bdist_wheel</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ##########################################################</span></span><br><span class="line"><span class="comment"># Distribute stage</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> name=httpbin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PIP_INDEX_URL=https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy build artifact from upstream stage.</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /app/dist/ /tmp/dist/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -U pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install --no-cache-dir /tmp/dist/*.whl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;uvicorn&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;httpbin:app&quot;</span>,  <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;80&quot;</span>, <span class="string">&quot;--host&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>为了减少生成镜像的层数，构建过程采用多<a href="https://docs.docker.com/develop/develop-images/multistage-build/">阶段构建</a>，最后阶段为发布的镜像，使用的依赖在前一阶段构建。</p>
<p>记得生成 <code>.dockerignore</code> 文件，排除不必要的内容，尽量缩减镜像层数和每层的大小。</p>
<h4 id="1-1-测试-Docker"><a href="#1-1-测试-Docker" class="headerlink" title="1.1 测试 Docker"></a>1.1 测试 Docker</h4><p>构建 Docker 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t httpbin:latest .</span><br></pre></td></tr></table></figure>

<p>构建完成后会生成对应镜像</p>
<h4 id="1-2-运行"><a href="#1-2-运行" class="headerlink" title="1.2 运行"></a>1.2 运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm httpbin</span><br></pre></td></tr></table></figure>



<h3 id="2-增加-ci-cd"><a href="#2-增加-ci-cd" class="headerlink" title="2. 增加 ci/cd"></a>2. 增加 ci/cd</h3><p>我使用的是 gitlab，所以后面 gitlab-ci 内容。以后有机会会增加其他 ci 工具。</p>
<p>新建 <code>.gitlab-ci.yml</code> ，内容如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">upload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This base py37 env, you should extend it in your stage.</span></span><br><span class="line"><span class="comment"># Use start with dot (.) to hide stage, ci will ignore it.</span></span><br><span class="line"><span class="string">.py37:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:3.7</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-U</span> <span class="string">pip</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">extends:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.py37</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-U</span> <span class="string">tox</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tox</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build whl:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:3.7</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">setup.py</span> <span class="string">bdist_wheel</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">7</span> <span class="string">days</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./dist/*.whl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build docker image only when release.</span></span><br><span class="line"><span class="attr">build image:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker:19</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">on_success</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">$CI_PROJECT_TITLE:$CI_COMMIT_REF_NAME</span> <span class="string">-t</span> <span class="string">$CI_PROJECT_TITLE:latest</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Upload to pypi only when release</span></span><br><span class="line"><span class="attr">upload twine:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">upload</span></span><br><span class="line">  <span class="attr">extends:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.py37</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">on_success</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$TWINE_USERNAME</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$TWINE_PASSWORD</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-U</span> <span class="string">twine</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">twine</span> <span class="string">upload</span> <span class="string">dist/*.whl</span></span><br></pre></td></tr></table></figure>

<p>此 CI 逻辑为一般提交只运行测试和构建 whl 文件，当发布的时候会根据 release 的版本号，构建 Docker 镜像，同时将归档文件上传到 pypi 索引服务器。</p>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>fastapi</tag>
        <tag>react</tag>
        <tag>gitlab-ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 7 安装 Jupyter Notebook</title>
    <url>/2018/08/03/operations/Centos%207%20%E5%AE%89%E8%A3%85%20Jupyter%20Notebook/</url>
    <content><![CDATA[<p>本文安装 Jupyter Notebook 是我在 Centos 7 服务器上安装的一次记录过程。此方式可以作为本地环境使用，也可以作为服务器环境部署。当然对于本次<br>Jupyter Notebook 的部署方式，也是我现在常用的项目部署方式—-通过 supervisor 部署，而结合 virtualenvwrapper 能够更方便的控制虚拟环境。<br>下面开始吧</p>
<span id="more"></span>

<p>基础系统环境需要安装 Python36 virtualenv virtualenvwrapper supervisor 。如果你的环境还没准备好，可以参照此文根据自己环境<br>调整相关操作。如果你的环境已经配置完成可以按照此文愉快的安装。如果你想安装前面提到的环境可以参考下面几篇文章。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建 jupyter 虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkvirtualenv jupyter</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ipython jupyter</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="生成-jupyter-配置文件"><a href="#生成-jupyter-配置文件" class="headerlink" title="生成 jupyter 配置文件"></a>生成 jupyter 配置文件</h3><p>一般会直接生成在家目录 <code>~/.jupyter/jupyter_notebook_config.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>

<h3 id="生成必要配置参数"><a href="#生成必要配置参数" class="headerlink" title="生成必要配置参数"></a>生成必要配置参数</h3><p>为了服务器数据安全，我们采用设置密码和设置 https 保证安全登录。当然我们的 https 证书是自己颁发的。</p>
<h4 id="生成加密密码"><a href="#生成加密密码" class="headerlink" title="生成加密密码"></a>生成加密密码</h4><p>进入 ipython ，生成 sha1 密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from notebook.auth import passwd</span><br><span class="line">passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[3]: &#x27;sha1:5c82f59da5a3:a68e8360e2cab6336fbbfa3d141f9a617aec7dba&#x27;</span><br></pre></td></tr></table></figure>

<p>输入两次密码。密码是不回显的！</p>
<h4 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:4096 -keyout ~/.jupyter/jkey.key -out ~/.jupyter/jcert.pem</span><br></pre></td></tr></table></figure>

<p>会提示输入一些内容，如果你不知道该填什么的话，那就回车默认好了~</p>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>修改文件 <code>/.jupyter/jupyter_notebook_config.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.password = <span class="string">&#x27;sha1:5c82f59da5a3:a68e8360e2cab6336fbbfa3d141f9a617aec7dba&#x27;</span></span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">&#x27;/opt/jupyte_notebook/&#x27;</span></span><br><span class="line">c.NotebookApp.certfile = <span class="string">&#x27;/home/user/.jupyter/jcert.pem&#x27;</span></span><br><span class="line">c.NotebookApp.keyfile = <span class="string">&#x27;/home/user/.jupyter/jkey.key&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ol>
<li><code>password</code> 要填你上面密码生成的 hash 值</li>
<li><code>notebook_dir</code> 置了jupyter的notebook路径，即访问jupyter首页时，看到的文件列表就是该目录下的。记得授权给启动用户，要不然可能会出现无法访问</li>
<li>最后两条配置的文件路径记得要写对应文件的绝对路径！</li>
</ol>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><strong>增加防火墙端口</strong></p>
<p>如果你使用了 firewalld 记得开发端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8888/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="测试启动"><a href="#测试启动" class="headerlink" title="测试启动"></a>测试启动</h3><p>执行命令启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<p>然后浏览器访问页面</p>
<h3 id="supervisord-启动"><a href="#supervisord-启动" class="headerlink" title="supervisord 启动"></a>supervisord 启动</h3><p>编辑文件 <code>/etc/supervisord.d/jupyter_notebook.ini</code> 填入如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:jupyter_notebook]</span><br><span class="line">command = /home/user/.virtualenvs/jupyter/bin/jupyter notebook</span><br><span class="line">autostart = true</span><br><span class="line">startsecs = 5</span><br><span class="line">autorestart = true</span><br><span class="line">startretries = 3</span><br><span class="line">user = kevin</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile_maxbytes = 20MB</span><br><span class="line">stdout_logfile_backups = 10</span><br><span class="line">stdout_logfile = /var/log/supervisor/jupyter_notebook/stdout.log</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><code>command</code> 为你虚拟环境中的启动命令</li>
<li><code>user</code> 用哪个用户启动。如果公网能访问不建议使用 root 用户</li>
<li><code>stdout_logfile</code> 日志存放目录。记得把权限给启动用户。因为会生成备份日志。建议单独放一个文件夹，然后授权给此用户。免得日志写满了没有权限备份日志和建立新文件。这里配置不好的话 supervisor 页面的 <code>tail -f</code> 可能看不到实时打出的日志。</li>
</ol>
<p>执行 <code>supervisorctl</code>进入 supervisor 交互，重新加载 supervisor 配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; upload</span><br></pre></td></tr></table></figure>

<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure>

<p>当然这两个操作都可以在 web 页面上进行。</p>
<p>如果有出错请查看相关日志</p>
<hr>
<p><strong>TODO：</strong></p>
<ol>
<li>使用 nginx 代理</li>
<li>jupyterhub 多用户管理</li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>Jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 配置 Python36 环境</title>
    <url>/2018/04/02/operations/Centos%207%20%E9%85%8D%E7%BD%AE%20python3.6%20%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本文主要记录在 Centos 7 中安装 py36 环境，同时初始化基础环境，如 pip36， virtualenv 等。为以后初始新环境做模板。</p>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>由于 Linux 和 python 起源都比较早，所以不要把 python2.x 卸载，否则会出现系统不可逆损坏！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python36</span><br></pre></td></tr></table></figure>

<p><code>python</code> 命令默认是系统 python2.x 软连接到 <code>python2.x</code> 上的，请勿将该软链接置到 python3.x 上，否可可能会出现系统问题，当然可以通过 livecd 启动然后把软链接更改回来。</p>
<p><strong>后文中的 python 都是指系统中 python2.x</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# python3.6 --version</span><br><span class="line">Python 3.6.3</span><br></pre></td></tr></table></figure>

<h3 id="python3-软链接"><a href="#python3-软链接" class="headerlink" title="python3 软链接"></a>python3 软链接</h3><p>为了方便使用 python3.6，我们做一个 python3 的软链接到 python3.6 上</p>
<p>python36 是链接到 python3.6 上的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin/</span><br><span class="line">ln -s python36 python3</span><br></pre></td></tr></table></figure>

<p>检查环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# python3 --version</span><br><span class="line">Python 3.6.3</span><br></pre></td></tr></table></figure>

<h3 id="配置-pip-使用国内源"><a href="#配置-pip-使用国内源" class="headerlink" title="配置 pip 使用国内源"></a>配置 pip 使用国内源</h3><p>为了更快速更方便的安装 Python 库，我们配置国内 pypi 镜像来加速。</p>
<p>国内可加速的镜像有 <a href="https://opsx.alibaba.com/mirror">阿里云</a> <a href="https://pypi.doubanio.com/simple/">豆瓣</a> <a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">清华源</a></p>
<blockquote>
<p>阿里云速度比较快，但对于更新时效性，清华源的 pypi 更及时，五分钟一次，阿里是每天一次。不过在我看来软件更新来说，我感觉版本迭代也没那么快吧，我们也不一定要用最新版本。所以我选择速度快的。</p>
</blockquote>
<p>在文件</p>
<p><code>~/.pip/pip.conf</code></p>
<p>中添加或修改:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>如果出现 <code>ssl</code> 问题，请将 <code>http</code> 换成 <code>https</code> 或添加 <code>trusted-host</code> 参数</p>
<h3 id="安装-pip3-6"><a href="#安装-pip3-6" class="headerlink" title="安装 pip3.6"></a>安装 pip3.6</h3><p>这个东西有点坑，python3.6 之前，可以通过 yum 安装 <code>python35-pip</code> 。 python36 还没那个包。不过我们可以通过以下方法来安装 pip36 模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有 <code>wget</code> 请执行 <code>yum install wget</code></p>
</blockquote>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3.6 get-pip.py</span><br></pre></td></tr></table></figure>

<p>安装完成后使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pip3 --version</span><br><span class="line">pip 9.0.3 from /usr/local/lib/python3.6/site-packages (python 3.6)</span><br></pre></td></tr></table></figure>

<p>如果你的系统没有为 python 安装 pip ，<code>pip --version</code> 也应该为 pyhon3.6 。当然即使有了，可以修改 <code>/usr/local/bin/pip</code> 文件指向 pip3 或者使用软链接。</p>
<p><strong>后文中 pip 都是指 pip3</strong></p>
<h3 id="安装虚拟环境-Virtualenvwrapper"><a href="#安装虚拟环境-Virtualenvwrapper" class="headerlink" title="安装虚拟环境 Virtualenvwrapper"></a>安装虚拟环境 Virtualenvwrapper</h3><p>详细内容参考 <a href="https://blog.csdn.net/leafage_m/article/details/72854559">Virtualenv和Virtualenvwrapper的配置使用</a> </p>
<p>里面包含 Winwows 和 Linux 的安装使用说明</p>
<blockquote>
<p>virtualenv is a tool to create isolated Python environments.</p>
</blockquote>
<p>virtualenv是用来创建一个独立的Python虚拟环境的工具，通过virtualenv可以创建一个拥有独立的python版本和安装库的虚拟开发环境。这样一来我们就可以在虚拟环境中安装各种各种所需要的库，从而不会造成本地的库过多所引起的使用混乱。同时也可以创建不同的python版本来完成不同的需求开发。</p>
<p>对应的Virtualenvwrapper是在使用virtualenv的一个扩展。</p>
<blockquote>
<p>virtualenvwrapper is a set of extensions to Ian Bicking’s virtualenv tool. The extensions include wrappers for creating and deleting virtual environments and otherwise managing your development workflow, making it easier to work on more than one project at a time without introducing conflicts in their dependencies.</p>
</blockquote>
<p>通过wrapper可以方便的管理虚拟环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line">pip install virtualenvwrapper</span><br></pre></td></tr></table></figure>

<p>但是安装之后并不能直接使用，我们需要配置之后才能使用相关命令。</p>
<p>配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<p>生效环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>加入上面的环境变量是为了防止 python 没有安装 virtualenvwrapper，而报 <code>/usr/bin/python: No module named virtualenvwrapper</code> 提示。当然如果你安装了可以不加</p>
<p>其他用户使用，请注销登录后使用该用户登录。以便初始化 <code>source /usr/local/bin/virtualenvwrapper.sh</code> 。</p>
<p>第一条是配置 virtualenvwrapper 默认解释器为 python3 ，第二条是用 virtualenvwrapper</p>
<h4 id="使用-virtualenvwrapper"><a href="#使用-virtualenvwrapper" class="headerlink" title="使用 virtualenvwrapper"></a>使用 virtualenvwrapper</h4><ol>
<li>创建 python 虚拟环境</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkvirtualenv testenv</span><br><span class="line">Using base prefix &#x27;/usr&#x27;</span><br><span class="line">New python executable in /root/.virtualenvs/testenv/bin/python3.6</span><br><span class="line">Also creating executable in /root/.virtualenvs/testenv/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/.virtualenvs/testenv/bin/predeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/.virtualenvs/testenv/bin/postdeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/.virtualenvs/testenv/bin/preactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/.virtualenvs/testenv/bin/postactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/.virtualenvs/testenv/bin/get_env_details</span><br><span class="line">(testenv) [root@localhost ~]# </span><br><span class="line">(testenv) [root@localhost ~]# ll ~/.virtualenvs/testenv/</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr  3 03:24 bin</span><br><span class="line">drwxr-xr-x 2 root root   24 Apr  3 03:24 include</span><br><span class="line">drwxr-xr-x 3 root root   23 Apr  3 03:24 lib</span><br><span class="line">lrwxrwxrwx 1 root root    3 Apr  3 03:24 lib64 -&gt; lib</span><br><span class="line">-rw-r--r-- 1 root root   60 Apr  3 03:24 pip-selfcheck.json</span><br><span class="line"></span><br><span class="line">(testenv) [root@localhost ~]# </span><br></pre></td></tr></table></figure>

<p>初次创建完成虚拟环境，会自动使用。退出虚拟环境请使用 <code>deactivate</code></p>
<ol start="2">
<li>使用虚拟环境</li>
</ol>
<p>使用 <code>workon</code> 命令，直接 <code>tab</code> 提示即可列出当前虚拟环境。指定名称后使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# workon test</span><br><span class="line">testenv   test_env  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关于 virtualenv 和 virtualenvwrapper 的更多使用方法请参考官方文档。另外再推荐一个虚拟环境管理工具 <code>pipenv</code> 。请自行权衡利弊后选择使用</li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Deepin 使用记录</title>
    <url>/2018/03/23/operations/Deepin%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文是在我安装好 Deepin 15.5 之后做的系统环境初始化记录。方便以后安装新系统直接按照以前的习惯初始化环境。其中包含基础环境配置，和常见服务安装，如<br>Redis 等。 </p>
<span id="more"></span>

<blockquote>
<p>操作系统 Deepin 15.5</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe psmouse  ##启用触摸板</span><br><span class="line">sudo rmmod psmouse     ##禁用触摸板</span><br></pre></td></tr></table></figure>

<h3 id="取消搜狗輸入法快捷鍵"><a href="#取消搜狗輸入法快捷鍵" class="headerlink" title="取消搜狗輸入法快捷鍵"></a>取消搜狗輸入法快捷鍵</h3><h3 id="修改-apt-源为-清华源"><a href="#修改-apt-源为-清华源" class="headerlink" title="修改 apt 源为 清华源"></a>修改 apt 源为 清华源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Generated by deepin-installer</span><br><span class="line">deb [by-hash=force] https://mirror.tuna.tsinghua.edu.cn/deepin/ panda main contrib non-free</span><br><span class="line"># deb [by-hash=force] http://packages.deepin.com/deepin panda main contrib non-free</span><br><span class="line">#deb-src http://packages.deepin.com/deepin panda main contrib non-free</span><br></pre></td></tr></table></figure>

<h3 id="使用-ll-命令。"><a href="#使用-ll-命令。" class="headerlink" title="使用 ll 命令。"></a>使用 <code>ll</code> 命令。</h3><p>如果有需要也可以修改 root 目录中的，这样sudo下也可以使用</p>
<p>vim ~/.bashrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># some more ls aliases</span><br><span class="line">alias ll=&#x27;ls -l&#x27;</span><br><span class="line">alias la=&#x27;ls -A&#x27;</span><br><span class="line">#alias l=&#x27;ls -CF&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="升级-python-为-3-6"><a href="#升级-python-为-3-6" class="headerlink" title="升级 python 为 3.6"></a>升级 python 为 3.6</h3><p>修改 python3 命令默认使用 python3.6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin/</span><br><span class="line">rm -rf python3</span><br><span class="line">ln -s python3.6 python3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：python 默认是软连接到 python2.x 上的，不可以把 python 作为默认使用 python3.x。如果这样可以的话那 Linux 就没有存在 python2.x 的意义了。但是由于 Linux 起源和 python 比较早，致使现在 Linux 系列都依赖于 python2。如果更改或者卸载 python2 会造成系统问题。</p>
</blockquote>
<!--more-->

<h3 id="安装-python3-pip"><a href="#安装-python3-pip" class="headerlink" title="安装 python3-pip"></a>安装 python3-pip</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure>

<h3 id="配置-pip-使用清华源"><a href="#配置-pip-使用清华源" class="headerlink" title="配置 pip 使用清华源"></a>配置 pip 使用清华源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line"> index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h3 id="配置-root-用户使用"><a href="#配置-root-用户使用" class="headerlink" title="配置 root 用户使用"></a>配置 root 用户使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -r ~/.pip /root/</span><br></pre></td></tr></table></figure>

<h3 id="创建-pip-链接-pip3"><a href="#创建-pip-链接-pip3" class="headerlink" title="创建 pip 链接 pip3"></a>创建 pip 链接 pip3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin/</span><br><span class="line">ln -s pip3 pip</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 pip 安装，默认会安装到家目录 <code>~/.local/</code> 下面，包会在 <code>.local/lib/</code> 对应 python 版本。也会在 <code>.local/bin/</code> 生成对应的可执行文件。<br>而使用 <code>sudo pip install</code> 则会装在 <code>/usr/local/lib/</code> 对应的 python 版本下。<br>这里的python版本为你安装 pip 时的版本</p>
</blockquote>
<h3 id="安装-virtualenv"><a href="#安装-virtualenv" class="headerlink" title="安装 virtualenv"></a>安装 virtualenv</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br></pre></td></tr></table></figure>

<h3 id="安装-shadowsocks-客户端"><a href="#安装-shadowsocks-客户端" class="headerlink" title="安装 shadowsocks 客户端"></a>安装 shadowsocks 客户端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>

<h4 id="创建-ss-配置文件"><a href="#创建-ss-配置文件" class="headerlink" title="创建 ss 配置文件"></a>创建 ss 配置文件</h4><p>sudo vim /etc/shadowsocks.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;server&quot; : &quot;IP&quot;,</span><br><span class="line">&quot;server_port&quot; : 8388,</span><br><span class="line">&quot;password&quot; : &quot;pass&quot;,</span><br><span class="line">&quot;method&quot; : &quot;aes-256-cfb&quot;,</span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;localPort&quot; : 1080,</span><br><span class="line">&quot;timeout&quot;:120&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>sslocal -c /etc/shadowsocks.conf</code></p>
<h4 id="意外问题"><a href="#意外问题" class="headerlink" title="意外问题"></a>意外问题</h4><ol>
<li>AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</li>
</ol>
<p>错误重现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sslocal -c /etc/shadowsocks.conf </span><br><span class="line">INFO: loading config from /etc/shadowsocks.conf</span><br><span class="line">2018-03-24 00:31:11 INFO     loading libcrypto from libcrypto.so.1.1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/bin/sslocal&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    sys.exit(main())</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/local.py&quot;, line 39, in main</span><br><span class="line">    config = shell.get_config(True)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/shell.py&quot;, line 262, in get_config</span><br><span class="line">    check_config(config, is_local)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/shell.py&quot;, line 124, in check_config</span><br><span class="line">    encrypt.try_cipher(config[&#x27;password&#x27;], config[&#x27;method&#x27;])</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/encrypt.py&quot;, line 44, in try_cipher</span><br><span class="line">    Encryptor(key, method)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/encrypt.py&quot;, line 83, in __init__</span><br><span class="line">    random_string(self._method_info[1]))</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/encrypt.py&quot;, line 109, in get_cipher</span><br><span class="line">    return m[2](method, key, iv, op)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/crypto/openssl.py&quot;, line 76, in __init__</span><br><span class="line">    load_openssl()</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/crypto/openssl.py&quot;, line 52, in load_openssl</span><br><span class="line">    libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)</span><br><span class="line">  File &quot;/usr/lib/python3.6/ctypes/__init__.py&quot;, line 361, in __getattr__</span><br><span class="line">    func = self.__getitem__(name)</span><br><span class="line">  File &quot;/usr/lib/python3.6/ctypes/__init__.py&quot;, line 366, in __getitem__</span><br><span class="line">    func = self._FuncPtr((name_or_ordinal, self))</span><br><span class="line">AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</span><br></pre></td></tr></table></figure>

<p>错误解决：<a href="https://blog.csdn.net/blackfrog_unique/article/details/60320737">安装shadowsocks服务报错问题</a></p>
<p>这个问题是由于在openssl1.1.0版本中，废弃了EVP_CIPHER_CTX_cleanup函数，如官网中所说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EVP_CIPHER_CTX was made opaque in OpenSSL 1.1.0. As a result, EVP_CIPHER_CTX_reset() appeared and EVP_CIPHER_CTX_cleanup() disappeared.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EVP_CIPHER_CTX_init() remains as an alias for EVP_CIPHER_CTX_reset().  </span><br></pre></td></tr></table></figure>

<p>修改方法：</p>
<ol>
<li>用vim打开文件：</li>
</ol>
<p><code>vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</code></p>
<p>(该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)</p>
<ol start="2">
<li><p>跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）</p>
</li>
<li><p>进入编辑模式</p>
</li>
<li><p>将第52行</p>
</li>
</ol>
<p>libcrypto.EVP_CIPHER_CTX_<code>cleanup</code>.argtypes = (c_void_p,) </p>
<p>改为</p>
<p>libcrypto.EVP_CIPHER_CTX_<code>reset</code>.argtypes = (c_void_p,)</p>
<ol start="5">
<li>再次搜索cleanup（全文件共2处，此处位于111行），将</li>
</ol>
<p>libcrypto.EVP_CIPHER_CTX_<code>cleanup</code>(self._ctx)<br>改为</p>
<p>libcrypto.EVP_CIPHER_CTX_<code>reset</code>(self._ctx)</p>
<ol start="6">
<li>保存并退出</li>
<li>启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录</li>
<li>问题解决</li>
</ol>
<h4 id="配置-Chrome-使用-代理"><a href="#配置-Chrome-使用-代理" class="headerlink" title="配置 Chrome 使用 代理"></a>配置 Chrome 使用 代理</h4><p>下载 Chrome 扩展程序</p>
<p><a href="http://note.youdao.com/noteshare?id=ee6e65186fd5a78358a3d503e95c4746">http://note.youdao.com/noteshare?id=ee6e65186fd5a78358a3d503e95c4746</a></p>
<p>下载扩展程序备份数据</p>
<p><a href="http://note.youdao.com/noteshare?id=8042047a6a81df37c561165c9775c6e4">http://note.youdao.com/noteshare?id=8042047a6a81df37c561165c9775c6e4</a></p>
<ol>
<li>Chrome 扩展安装</li>
</ol>
<p>在 Chrome 中 按下 <code>Alt + E</code> 组合键，<code>更多工具</code> ==&gt; <code>扩展程序</code>；或者直接浏览器输入 <code>chrome://extensions/</code></p>
<p>打开 <code>扩展程序</code> ，将下载的插件拖入页面以安装插件。</p>
<p>安装完成后打开插件，选择<code>导入/导出</code> ==&gt; <code>从备份文件恢复</code></p>
<p>然后选择下载的扩展程序备份数据。</p>
<ol start="2">
<li>使用插件</li>
</ol>
<p>浏览器右上角点击插件图标，选择 <code>auto switch</code> ，浏览器打开谷歌应该可以访问了。</p>
<h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><h3 id="配置-JAVA-环境变量"><a href="#配置-JAVA-环境变量" class="headerlink" title="配置 JAVA 环境变量"></a>配置 JAVA 环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># JAVA ENV</span><br><span class="line">JAVA_HOME=/usr/local/share/jdk1.8.0_161</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>

<h3 id="安装-Idea-Pycharm"><a href="#安装-Idea-Pycharm" class="headerlink" title="安装 Idea Pycharm"></a>安装 Idea Pycharm</h3><h3 id="配置桌面启动器"><a href="#配置桌面启动器" class="headerlink" title="配置桌面启动器"></a>配置桌面启动器</h3><p><code>cd /usr/share/applications</code></p>
<p><code>vim idea.desktop</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Name=Ieda</span><br><span class="line">Comment=this is idea</span><br><span class="line">Exec=/opt/software/idea-IU-173.4674.33/bin/idea.sh</span><br><span class="line">Icon=/opt/software/idea-IU-173.4674.33/bin/idea.png</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Development</span><br></pre></td></tr></table></figure>

<p>Pycharm 相同</p>
<h3 id="安装便签"><a href="#安装便签" class="headerlink" title="安装便签"></a><a href="https://jingyan.baidu.com/article/d8072ac484c739ec95cefd23.html">安装便签</a></h3><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a><a href="https://wiki.deepin.org/index.php?title=Docker">安装 Docker</a></h3><h4 id="免sudo使用docker命令"><a href="#免sudo使用docker命令" class="headerlink" title="免sudo使用docker命令"></a><a href="https://blog.csdn.net/baidu_36342103/article/details/69357438">免sudo使用docker命令</a></h4><p>如果还没有 docker group 就添加一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>将用户加入该 group 内。然后退出并重新登录就生效啦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure>

<p>重启 docker 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>

<p>切换当前会话到新 group 或者重启 X 会话</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newgrp - docker</span><br></pre></td></tr></table></figure>

<p>注意:最后一步是必须的，否则因为 groups 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。</p>
<h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a><a href="https://blog.csdn.net/yjqyyjw/article/details/73293455">安装 Redis</a></h3><blockquote>
<p>注意：下面的操作和给出链接的安装目录不一样，切勿两边操作。</p>
</blockquote>
<ol>
<li>下载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://redis.io/download</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解压</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf ~/Downloads/redis-3.2.11.tar.gz -C /tmp/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译并安装</li>
</ol>
<p><strong>编译</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp/redis-3.2.11/</span><br><span class="line">sudo make </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后几行的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    CC redis-benchmark.o</span><br><span class="line">    LINK redis-benchmark</span><br><span class="line">    INSTALL redis-check-rdb</span><br><span class="line">    CC redis-check-aof.o</span><br><span class="line">    LINK redis-check-aof</span><br><span class="line"></span><br><span class="line">Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)</span><br><span class="line"></span><br><span class="line">make[1]: Leaving directory &#x27;/tmp/redis-3.2.11/src&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>编译测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 如果在 make test 出现 <code>You need tcl 8.5 or newer in order to run the Redis test</code> 这个错误，请参考 <a href="https://blog.csdn.net/luyee2010/article/details/18766911">https://blog.csdn.net/luyee2010/article/details/18766911</a> 后，执行如下操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz  </span><br><span class="line">sudo tar xzvf tcl8.6.1-src.tar.gz  -C /usr/local/  </span><br><span class="line">cd  /usr/local/tcl8.6.1/unix/  </span><br><span class="line">sudo ./configure  </span><br><span class="line">sudo make  </span><br><span class="line">sudo make install  </span><br></pre></td></tr></table></figure>

<p>编译测试最后输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  79 seconds - integration/replication</span><br><span class="line">  54 seconds - unit/geo</span><br><span class="line">  113 seconds - unit/type/list-3</span><br><span class="line">  102 seconds - integration/replication-psync</span><br><span class="line">  99 seconds - unit/obuf-limits</span><br><span class="line"></span><br><span class="line">\o/ All tests passed without errors!</span><br><span class="line"></span><br><span class="line">Cleanup: may take some time... OK</span><br><span class="line">make[1]: Leaving directory &#x27;/tmp/redis-3.2.11/src&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make install PREFIX=/usr/local/share/redis</span><br></pre></td></tr></table></figure>

<p>这里 <code>PREFIX</code> 为指定安装到该位置。要确保对这个目录有写入权限。<br>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd src &amp;&amp; make install</span><br><span class="line">make[1]: Entering directory &#x27;/tmp/redis-3.2.11/src&#x27;</span><br><span class="line"></span><br><span class="line">Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">make[1]: Leaving directory &#x27;/tmp/redis-3.2.11/src&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>增加配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/share/redis/ect/</span><br><span class="line">sudo cp /tmp/redis-3.2.11/redis.conf /usr/local/share/redis/ect/</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>如需要在后台运行，把该项的值改为yes</td>
</tr>
<tr>
<td>pdifile</td>
<td>把pid文件放在/var/run/redis.pid，可以配置到其他地址</td>
</tr>
<tr>
<td>bind</td>
<td>指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项</td>
</tr>
<tr>
<td>port</td>
<td>监听端口，默认为6379</td>
</tr>
<tr>
<td>timeout</td>
<td>设置客户端连接时的超时时间，单位为秒</td>
</tr>
<tr>
<td>loglevel</td>
<td>等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice</td>
</tr>
<tr>
<td>logfile</td>
<td>配置log文件地址，默认使用标准输出，即打印在命令行终端的端口上</td>
</tr>
<tr>
<td>database</td>
<td>设置数据库的个数，默认使用的数据库是0</td>
</tr>
<tr>
<td>save</td>
<td>设置redis进行数据库镜像的频率</td>
</tr>
<tr>
<td>rdbcompression</td>
<td>在进行镜像备份时，是否进行压缩</td>
</tr>
<tr>
<td>dbfilename</td>
<td>镜像备份文件的文件名</td>
</tr>
<tr>
<td>dir</td>
<td>数据库镜像备份的文件放置的路径</td>
</tr>
<tr>
<td>slaveof</td>
<td>设置该数据库为其他数据库的从数据库</td>
</tr>
<tr>
<td>masterauth</td>
<td>当主数据库连接需要密码验证时，在这里设定</td>
</tr>
<tr>
<td>requirepass</td>
<td>设置客户端连接后进行任何其他指定前需要使用的密码</td>
</tr>
<tr>
<td>maxclients</td>
<td>限制同时连接的客户端数量</td>
</tr>
<tr>
<td>maxmemory</td>
<td>设置redis能够使用的最大内存</td>
</tr>
<tr>
<td>appendonly</td>
<td>开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态</td>
</tr>
<tr>
<td>appendfsync</td>
<td>设置appendonly.aof文件进行同步的频率</td>
</tr>
<tr>
<td>vm_enabled</td>
<td>是否开启虚拟内存支持</td>
</tr>
<tr>
<td>vm_swap_file</td>
<td>设置虚拟内存的交换文件的路径</td>
</tr>
<tr>
<td>vm_max_momery</td>
<td>设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0</td>
</tr>
<tr>
<td>vm_page_size</td>
<td>设置虚拟内存页的大小</td>
</tr>
<tr>
<td>vm_pages</td>
<td>设置交换文件的总的page数量</td>
</tr>
<tr>
<td>vm_max_thrrads</td>
<td>设置vm IO同时使用的线程数量</td>
</tr>
</tbody></table>
<h4 id="编写-redis-启动文件"><a href="#编写-redis-启动文件" class="headerlink" title="编写 redis 启动文件"></a>编写 redis 启动文件</h4><pre><code>sudo vim /etc/systemd/system/redis.service
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]  </span><br><span class="line">Description=redis </span><br><span class="line">After=network.target  </span><br><span class="line">   </span><br><span class="line">[Service]  </span><br><span class="line"># Type=forking</span><br><span class="line">PIDFile=/var/run/redis_6379.pid</span><br><span class="line">ExecStart=/usr/local/share/redis/bin/redis-server /usr/local/share/redis/etc/redis.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true  </span><br><span class="line">   </span><br><span class="line">[Install]  </span><br><span class="line">WantedBy=multi-user.target   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可参考 <a href="https://blog.csdn.net/chwshuang/article/details/68489968">Systemctl 管理 Redis</a></p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">28769:M 24 Mar 23:49:14.920 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br></pre></td></tr></table></figure>

<p>这个警告，可以参照警告描述操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">28769:M 24 Mar 23:49:14.920 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br></pre></td></tr></table></figure>

<p>这个警告，分两步操作。</p>
<p>第一步：</p>
<p><code>sudo echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></p>
<p>第二步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo touch /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>关于创建该文件可以参考 <a href="https://wiki.deepin.org/index.php?title=%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F">自启动程序</a></p>
<p>然后编辑该文件，加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">if test -f /sys/kernel/mm/redhat_transparent_hugepage/enabled; then</span><br><span class="line">   echo never &gt; /sys/kernel/mm/redhat_transparent_hugepage/enabled</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这一步是在开机自启的时候，检测第一步操作的文件内容是否为 <code>never</code> 然后写入更改。讲白了就是做到开机禁用</p>
</blockquote>
<p>参考 <a href="http://www.cnblogs.com/kerrycode/archive/2015/07/23/4670931.html">透明大叶介绍</a></p>
<h4 id="安装-Mariadb"><a href="#安装-Mariadb" class="headerlink" title="安装 Mariadb"></a>安装 Mariadb</h4>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix 集群安装（Centos 7.2）</title>
    <url>/2018/04/02/operations/Zabbix%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%EF%BC%88Centos%207.2%EF%BC%89/</url>
    <content><![CDATA[<p>本文主要介绍 Zabbix 集群安装记录。操作环境以 Centos 7 和 Zabbix 3.4 安装三节点集群。</p>
<span id="more"></span>

<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ol>
<li>centos 7.2 操作系统</li>
<li>zibbix 3.4.2</li>
</ol>
<p><strong>集群环境</strong></p>
<table>
<thead>
<tr>
<th>hostname</th>
<th>ip</th>
</tr>
</thead>
<tbody><tr>
<td>server</td>
<td>192.168.80.101</td>
</tr>
<tr>
<td>agent1</td>
<td>192.168.80.102</td>
</tr>
<tr>
<td>agent2</td>
<td>192.168.80.103</td>
</tr>
</tbody></table>
<p><strong>server 主机安装的服务</strong></p>
<ol>
<li>LNMP 一键安装包，安装了 Nginx、Mariadb、PHP</li>
<li>安装 zabbix web 管理页面</li>
<li>安装 Zabbix-server 节点</li>
<li>安装 Zabbix-agent 节点</li>
</ol>
<p><strong>agent1 主机 安装的服务</strong></p>
<p>agent 主机就是需要监控的主机，所以只要安装 zabbix-agent 服务就可以了。</p>
<p>然后可以通过 Web 管理页面将 agent 节点添加进去做监控</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="server-节点"><a href="#server-节点" class="headerlink" title="server 节点"></a>server 节点</h3><h4 id="安装-LNMP-LAMP"><a href="#安装-LNMP-LAMP" class="headerlink" title="安装 LNMP / LAMP"></a>安装 LNMP / LAMP</h4><p>执行 lnmp 一键安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz &amp;&amp; tar zxf lnmp1.5.tar.gz &amp;&amp; <span class="built_in">cd</span> lnmp1.5 &amp;&amp; ./install.sh lnmp</span><br></pre></td></tr></table></figure>

<p>安装 </p>
<ul>
<li>mariadb</li>
<li>php</li>
<li>nginx</li>
</ul>
<p><strong>调整参数</strong></p>
<p>vim /usr/local/php/etc/php.ini</p>
<p>修改 393 行参数为 300</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">393 max_input_time = 300</span><br></pre></td></tr></table></figure>

<p>重新加载 php。即可 继续</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lnmp php-fpm reload</span><br></pre></td></tr></table></figure>

<h4 id="安装-Zabbix3-4"><a href="#安装-Zabbix3-4" class="headerlink" title="安装 Zabbix3.4"></a>安装 Zabbix3.4</h4><ol>
<li>下载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O zabbix-3.4.11.tar.gz  https://excellmedia.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/3.4.11/zabbix-3.4.11.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装依赖库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install net-snmp-devel libxml2-devel libcurl-devel libevent libevent-devel gcc</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解压编译</li>
</ol>
<p>在编译时可以指定在编译内容，这里在 server 主机同时编译了 zabbix-server 和 zabbix-agent 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf zabbix-3.4.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zabbix-3.4.11</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/zabbix --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2</span><br></pre></td></tr></table></figure>

<p>如果要使用加密，需增加 <code>--with-openssl</code> 参数进行编译</p>
<p><strong>错误解决</strong></p>
<p><code>error: MySQL library not found</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y mariadb-devel</span><br></pre></td></tr></table></figure>

<p><code>error: Invalid Net-SNMP directory - unable to find net-snmp-config</code></p>
<p>解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install net-snmp-devel</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建用户和用户组</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd zabbix</span><br><span class="line">useradd -r -g zabbix zabbix</span><br><span class="line">chown -R zabbix:zabbix /usr/<span class="built_in">local</span>/zabbix</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>准备 mysql</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p</span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> zabbix <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> zabbix.<span class="operator">*</span> <span class="keyword">to</span> zabbix<span class="variable">@localhost</span> identified <span class="keyword">by</span> <span class="string">&#x27;zabbix&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>

<p><strong>导入顺序不能错</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uzabbix -pzabbix zabbix &lt; database/mysql/schema.sql</span><br><span class="line">mysql -uzabbix -pzabbix zabbix &lt; database/mysql/images.sql</span><br><span class="line">mysql -uzabbix -pzabbix zabbix &lt; database/mysql/data.sql</span><br></pre></td></tr></table></figure>

<p>在使用完全分离的集群的搭建的时候，下面两点注意下：</p>
<ul>
<li>如果只是代理可以不用导入 <code>database/mysql/images.sql</code></li>
<li>如果只是代理可以不用导入 <code>database/mysql/data.sql</code></li>
</ul>
<ol start="6">
<li>创建日志目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /var/<span class="built_in">log</span>/zabbix</span><br><span class="line">chown zabbix:zabbix /var/<span class="built_in">log</span>/zabbix</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>配置</li>
</ol>
<p><strong>配置 zabbix-server 服务</strong></p>
<p><code>vim /usr/local/zabbix/etc/zabbix_server.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LogFile=/var/log/zabbix/server.log</span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPort=3306</span><br><span class="line">DBPassword=zabbix</span><br><span class="line">DBSocket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>

<p><strong>配置 zabbix-agent 服务</strong></p>
<p>注意 agent 被他们写成 <code>agentd</code></p>
<p>vim /usr/local/zabbix/etc/zabbix_agentd.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LogFile=/var/log/zabbix/agentd.log</span><br><span class="line">Server=127.0.0.1</span><br><span class="line">ServerActive=127.0.0.1</span><br><span class="line">Hostname=server</span><br></pre></td></tr></table></figure>

<p>这里有几点要注意的：</p>
<ul>
<li><code>DBSocket=/tmp/mysql.sock</code> 这一项要打开，要不然会连不上数据库</li>
<li><code>Hostname</code> 最好指定一个名词，如果在 Web 上出现问题方便查找</li>
</ul>
<ol start="8">
<li>配置启动服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/zabbix/sbin/* /usr/<span class="built_in">local</span>/sbin/</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/zabbix/bin/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">cp /root/zabbix-3.4.11/misc/init.d/tru64/zabbix_* /etc/init.d/</span><br><span class="line">chmod +x /etc/init.d/zabbix_*</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>启动 server 和 agent</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/zabbix_server start</span><br><span class="line">/etc/init.d/zabbix_agentd start</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>注册到服务中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --add zabbix_server</span><br><span class="line">chkconfig --add zabbix_agentd</span><br></pre></td></tr></table></figure>

<p>配置开机自启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig zabbix_server on</span><br><span class="line">chkconfig zabbix_agentd on</span><br></pre></td></tr></table></figure>

<p>后面启动的时候可以使用服务方式启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service zabbix_server start</span><br><span class="line">service zabbix_server stop</span><br></pre></td></tr></table></figure>

<p>如果报错 <code>service zabbix_server does not support chkconfig</code></p>
<p>只需要编辑对应的文件在 <code>#!/bin/sh</code> 后 加入一行内容就好了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 10 90</span></span><br></pre></td></tr></table></figure>

<p>检查端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@server zabbix-3.4.11]# netstat -ntlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      912/nginx: master p </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      895/sshd            </span><br><span class="line">tcp        0      0 0.0.0.0:10050           0.0.0.0:*               LISTEN      11967/zabbix_agentd </span><br><span class="line">tcp        0      0 0.0.0.0:10051           0.0.0.0:*               LISTEN      11907/zabbix_server </span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      1383/mysqld         </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      895/sshd            </span><br><span class="line">tcp6       0      0 :::10050                :::*                    LISTEN      11967/zabbix_agentd </span><br><span class="line">tcp6       0      0 :::10051                :::*                    LISTEN      11907/zabbix_server</span><br></pre></td></tr></table></figure>

<p>看看 <code>zabbix_server</code> / <code>zabbix_agentd</code> 是否都起来了。如果没有可用查看日志检查</p>
<h4 id="部署-Web"><a href="#部署-Web" class="headerlink" title="部署 Web"></a>部署 Web</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/wwwroot/default/zabbix</span><br><span class="line"><span class="built_in">cd</span> /root/zabbix-3.4.11/frontends/php</span><br><span class="line">cp -a . /home/wwwroot/default/zabbix/</span><br></pre></td></tr></table></figure>

<h5 id="访问-Web-初始化引导"><a href="#访问-Web-初始化引导" class="headerlink" title="访问 Web 初始化引导"></a>访问 Web 初始化引导</h5><p>访问zabbix：<a href="http://ip/zabbix/index.php">http://ip/zabbix/index.php</a> ，初始化安装的默认账号：Admin，密码：zabbix</p>
<h3 id="agent-节点安装"><a href="#agent-节点安装" class="headerlink" title="agent 节点安装"></a>agent 节点安装</h3><ol>
<li>下载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O zabbix-3.4.11.tar.gz  https://excellmedia.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/3.4.11/zabbix-3.4.11.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装依赖库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install net-snmp-devel libxml2-devel libcurl-devel libevent libevent-devel gcc</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解压编译</li>
</ol>
<p>在编译时可以指定在编译内容，这里在 server 主机同时编译了 zabbix-server 和 zabbix-agent 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf zabbix-3.4.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zabbix-3.4.11</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/zabbix --enable-agent</span><br></pre></td></tr></table></figure>

<p>如果要使用加密，需增加 <code>--with-openssl</code> 参数进行编译。当然前提是 server 节点支持加密</p>
<ol start="4">
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建用户和用户组</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd zabbix</span><br><span class="line">useradd -r -g zabbix zabbix</span><br><span class="line">chown -R zabbix:zabbix /usr/<span class="built_in">local</span>/zabbix</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>创建日志目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /var/<span class="built_in">log</span>/zabbix</span><br><span class="line">chown zabbix:zabbix /var/<span class="built_in">log</span>/zabbix</span><br></pre></td></tr></table></figure>

<p><strong>可选</strong>：加密配置</p>
<p>生成 PSK string ，并保存 <code>/usr/local/zabbix/etc/zabbix_agentd.psk</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rand -hex 32 &gt; /usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.psk</span><br></pre></td></tr></table></figure>

<p>授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown zabbix:zabbix /usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.psk</span><br><span class="line">chmod 644 /usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.psk</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>配置</li>
</ol>
<p><strong>配置 zabbix-agent 服务</strong></p>
<p>注意 agent 被他们写成 <code>agentd</code></p>
<p><code>vim /usr/local/zabbix/etc/zabbix_agentd.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LogFile=/var/log/zabbix/agentd.log</span><br><span class="line">Server=192.168.80.101</span><br><span class="line">ServerActive=192.168.80.101</span><br><span class="line">Hostname=agent1</span><br></pre></td></tr></table></figure>

<p><strong>加密配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TLSConnect=psk</span><br><span class="line">TLSAccept=psk</span><br><span class="line">TLSPSKFile=/usr/local/zabbix/etc/zabbix_agentd.psk</span><br><span class="line">TLSPSKIdentity=PSK001</span><br></pre></td></tr></table></figure>

<p>这里有几点要注意的：</p>
<ul>
<li>要正确配置 server ip</li>
<li><code>Hostname</code> 最好指定一个名词，如果在 Web 上出现问题方便查找</li>
</ul>
<ol start="8">
<li>配置启动服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/zabbix/sbin/* /usr/<span class="built_in">local</span>/sbin/</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/zabbix/bin/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">cp /root/zabbix-3.4.11/misc/init.d/tru64/zabbix_agentd /etc/init.d/</span><br><span class="line">chmod +x /etc/init.d/zabbix_agentd</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>启动 server 和 agent</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/zabbix_agentd start</span><br></pre></td></tr></table></figure>

<p>配置开机自启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig zabbix_agentd on</span><br></pre></td></tr></table></figure>

<p>如果报错 <code>service zabbix_agentd does not support chkconfig</code></p>
<p>只需要编辑对应的文件在 <code>#!/bin/sh</code> 后 加入一行内容就好了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 10 90</span></span><br></pre></td></tr></table></figure>

<p><strong>加密检测</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zabbix_get-s127.0.0.1-k<span class="string">&quot;system.cpu.load[all,avg1]&quot;</span>--tls-connect=psk--tls-psk-identity=<span class="string">&quot;PSK001&quot;</span>--tls-psk-file=/usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.psk</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>在 Web 页面添加到主机中</li>
</ol>
<hr>
<p>记录</p>
<p>通过 yum 安装后的服务启动文件</p>
<p>cat /usr/lib/systemd/system/zabbix-server.service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Zabbix Server</span><br><span class="line">After=syslog.target</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;CONFFILE=/etc/zabbix/zabbix_server.conf&quot;</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/zabbix-server</span><br><span class="line">Type=forking</span><br><span class="line">Restart=on-failure</span><br><span class="line">PIDFile=/run/zabbix/zabbix_server.pid</span><br><span class="line">KillMode=control-group</span><br><span class="line">ExecStart=/usr/sbin/zabbix_server -c $CONFFILE</span><br><span class="line">ExecStop=/bin/kill -SIGTERM $MAINPID</span><br><span class="line">RestartSec=10s</span><br><span class="line">TimeoutSec=0</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>cat /usr/lib/systemd/system/zabbix-agent.service </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Zabbix Agent</span><br><span class="line">After=syslog.target</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;CONFFILE=/etc/zabbix/zabbix_agentd.conf&quot;</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/zabbix-agent</span><br><span class="line">Type=forking</span><br><span class="line">Restart=on-failure</span><br><span class="line">PIDFile=/run/zabbix/zabbix_agentd.pid</span><br><span class="line">KillMode=control-group</span><br><span class="line">ExecStart=/usr/sbin/zabbix_agentd -c $CONFFILE</span><br><span class="line">ExecStop=/bin/kill -SIGTERM $MAINPID</span><br><span class="line">RestartSec=10s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 项目工程化</title>
    <url>/2018/10/12/programming/python/Python%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<p>如果你是新手，请先参考 <a href="https://docs.python-guide.org/">The Hitchhiker’s Guide to Python!</a> 。<br>当然它有<a href="https://pythonguidecn.readthedocs.io/zh/latest/">中文版</a> </p>
<span id="more"></span>

<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><h3 id="1-语言版本"><a href="#1-语言版本" class="headerlink" title="1. 语言版本"></a>1. 语言版本</h3><p>Python version 3.6</p>
<p><a href="https://www.python.org/downloads/release/python-366/">Python 3.6</a> / <a href="https://repo.anaconda.com/archive/">Anaconda 5.2.0(Python 3.6.5)</a> / <a href="https://repo.continuum.io/miniconda/">Mininconda3-4.5.4(Python 3.6)</a></p>
<p>在这里推荐使用 Miniconda 或者 Anaconda 安装 Python。方便管理 Python。上面各处的版本均为对应对心的 Python 3.6 版本。在使用 conda 安装 Python 的时候，推荐将 conda 注册到 PATH 中。</p>
<h3 id="2-虚拟环境工具"><a href="#2-虚拟环境工具" class="headerlink" title="2. 虚拟环境工具"></a>2. 虚拟环境工具</h3><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>建议开发中使用</p>
<h4 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h4><p>集中化管理虚拟环境，建议部署的时候使用。</p>
<h4 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h4><p>类似于 Node.js 的 npm 或者 Ruby 的 bundler 的项目依赖管理器。它是一种更高级的工具，但是还不是很稳定。</p>
<p>直到在写这篇文章，pipenv 仍会因为 pip 18.1 的更新出现不可预测的 Bug。暂时不推荐使用。</p>
<h3 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h3><h4 id="Pycharm-IntelliJ-IDEA"><a href="#Pycharm-IntelliJ-IDEA" class="headerlink" title="Pycharm / IntelliJ IDEA"></a>Pycharm / IntelliJ IDEA</h4><p>两者都有 JetBrains 开发。<a href="http://www.jetbrains.com/pycharm/">Pycharm</a> 专注 Python 开发。而后者更侧重于 Java 开发。IDEA可以通过 Python 插件使用前者大多数特性。</p>
<p>推荐 Pycharm。</p>
<p>工具依赖 Java 环境，运行前请确保系统存在 JRE (Java Runtime Environment)。</p>
<h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p><a href="https://code.visualstudio.com/">Visual Studio Code IDE</a> 是由微软开发的一款免费的、轻量的、开源的 IDE。支持 Mac、Windows 和 Linux。可通过安装 <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python 插件</a> 使其支持 Python 开发。</p>
<h2 id="二、开发规范"><a href="#二、开发规范" class="headerlink" title="二、开发规范"></a>二、开发规范</h2><h3 id="1-语言使用规范"><a href="#1-语言使用规范" class="headerlink" title="1. 语言使用规范"></a>1. 语言使用规范</h3><ul>
<li><a href="https://www.python.org/dev/peps/pep-0008/">Style Guide for Python Code</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0020/">The Zen of Python</a></li>
<li><a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md">Google Python Style Guide</a> </li>
</ul>
<p>前两者是 Python 指定的语言规范和风格规范。最后一个是 Google 社区根据Python官方规范和使用过程中总结的经验结合在一起推出的一套Python开源规范。</p>
<h3 id="2-项目开发规范"><a href="#2-项目开发规范" class="headerlink" title="2. 项目开发规范"></a>2. 项目开发规范</h3><h3 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h3><h4 id="3-1-一般项目结构"><a href="#3-1-一般项目结构" class="headerlink" title="3.1 一般项目结构"></a>3.1 一般项目结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project_name</span><br><span class="line">|-- docs</span><br><span class="line">|-- project_name</span><br><span class="line">    |-- project_module</span><br><span class="line">|-- tests</span><br><span class="line">|-- scripts</span><br><span class="line">|-- setup.cfg</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- tox.ini</span><br><span class="line">|-- README.md</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Django-项目结构"><a href="#3-2-Django-项目结构" class="headerlink" title="3.2 Django 项目结构"></a>3.2 Django 项目结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project_name</span><br><span class="line">|-- docs</span><br><span class="line">|-- apps</span><br><span class="line">    |-- app1</span><br><span class="line">|-- static</span><br><span class="line">|-- templates</span><br><span class="line">|-- project_name</span><br><span class="line">|-- manage.py</span><br><span class="line">|-- pytest.ini</span><br><span class="line">|-- scripts</span><br><span class="line">|-- setup.cfg</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- tox.ini</span><br><span class="line">|-- README.md</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Python 风格指南</title>
    <url>/2020/08/04/programming/python/google_python_style_guide/</url>
    <content><![CDATA[<p><a id="s1-background"></a><br><a id="1-background"></a></p>
<p><a id="background"></a></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>在 Google ， Python 是主要使用的动态语言之一。该风格之南表述了一些在 Python 编程中 <strong>应该做</strong> 和 <strong>不应该</strong> 的事情。</p>
<p>为了帮你正确地格式化代码，我们准备了 <a href="https://google.github.io/styleguide/google_python_style.vim">Vim 的配置文件</a> 。<br>对于 Emacs ，使用默认的应该没什么问题。</p>
<p>很多个团队在使用 <a href="https://github.com/google/yapf/">yapf</a> 来自动格式化来避免在格式上的争论。</p>
<p><a id="s2-python-language-rules"></a><br><a id="2-python-language-rules"></a></p>
<p><a id="python-language-rules"></a></p>
<h2 id="2-Python-语言规范"><a href="#2-Python-语言规范" class="headerlink" title="2 Python 语言规范"></a>2 Python 语言规范</h2><p><a id="s2.1-lint"></a><br><a id="21-lint"></a></p>
<p><a id="lint"></a></p>
<h3 id="2-1-Lint"><a href="#2-1-Lint" class="headerlink" title="2.1 Lint"></a>2.1 Lint</h3><p>在你的代码上运行 <code>pylint</code> </p>
<p><a id="s2.1.1-definition"></a><br><a id="211-definition"></a></p>
<p><a id="definition"></a></p>
<h4 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h4><p><code>pylint</code> 是一个可以在 Python 源代码中发现 Bugs 和风格问题的工具。它可以发现一些通常由编译器捕获的问题，像 C 和 c++ 等<br>动态程度较低的语言。由于Python的动态特性，一些警告可能是不正确的;然而，虚假得警告应该相当少见。</p>
<h4 id="2-1-2-Pros"><a href="#2-1-2-Pros" class="headerlink" title="2.1.2 Pros"></a>2.1.2 Pros</h4><p>捕获容易出错的错误，例如错别字，在分配前使用vars等。</p>
<h4 id="2-1-3-Cons"><a href="#2-1-3-Cons" class="headerlink" title="2.1.3 Cons"></a>2.1.3 Cons</h4><p><code>pylint</code> 并不完美。要利用它，有时我们需要：</p>
<ul>
<li>围绕它写</li>
<li>禁止其警告</li>
<li>对其进行改进</li>
</ul>
<h4 id="2-1-4-Decision"><a href="#2-1-4-Decision" class="headerlink" title="2.1.4 Decision"></a>2.1.4 Decision</h4><p>确定在你的代码中运行  <code>pylint</code> 。</p>
<p>如果不适当，请禁用警告，以免隐藏其他问题。要取消显示警告，可以设置行级注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = <span class="string">&#x27;something awful&#x27;</span>  <span class="comment"># Bad Idea... pylint: disable=redefined-builtin</span></span><br></pre></td></tr></table></figure>

<p><code>pylint</code> 警告均由符号名称(<code>empty-docstring</code>) 标识， Google 特定警告以 <code>g-</code> 开头。</p>
<p>如果从符号名称中看不到禁用的原因，请添加说明。以这种方式进行禁用的优势在于，我们可以轻松地搜索抑制并重新进行禁用。</p>
<p>要获取 <code>pylint</code> 警告列表可以这样操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pylint --list-msgs</span><br></pre></td></tr></table></figure>

<p>获取特定消息的详细信息，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pylint --help-msg=C6409</span><br></pre></td></tr></table></figure>

<p>推荐使用 <code>pylint：disable</code> 而不是使用旧的 <code>pylint：disable-msg</code> 形式。</p>
<p>可以通过删除函数开头的变量来消除未使用的参数警告。记得添加注释解释为什么删除。 <code>Unused</code> 就可以了。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">viking_cafe_order</span>(<span class="params">spam, beans, eggs=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">del</span> beans, eggs  <span class="comment"># Unused by vikings.</span></span><br><span class="line">    <span class="keyword">return</span> spam + spam + spam</span><br></pre></td></tr></table></figure>

<p>取消警告的其他常见形式包括使用 <code>_</code> 作为未使用参数的标识符，或在参数名称前加上 <code>unused_</code> 前缀，<br>或将其分配给 <code>_</code> 。虽然可以这么做，但不再鼓励。一些中断调用程序按名称传递参数，并且不强制要求参数实际上未使用。</p>
<h3 id="2-2-Imports"><a href="#2-2-Imports" class="headerlink" title="2.2 Imports"></a>2.2 Imports</h3><p><code>import</code> 语句仅用在包和模块，不要用在类和函数上。对于 <a href="#typing-imports">typing module</a> 导入是特例。</p>
<h4 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h4><p>Re-usability mechanism for sharing code from one module to another.</p>
<h4 id="2-2-2-优点"><a href="#2-2-2-优点" class="headerlink" title="2.2.2 优点"></a>2.2.2 优点</h4><p>命名空间管理约定很简单。每个标识符的来源以一致的方式表示； <code>x.Obj</code> 表示 <code>Obj</code> 对象定义在 <code>x</code> 模块中。</p>
<h4 id="2-2-3-缺点"><a href="#2-2-3-缺点" class="headerlink" title="2.2.3 缺点"></a>2.2.3 缺点</h4><p>模块名称仍然可以冲突。一些模块名称很长。</p>
<h4 id="2-2-4-判断"><a href="#2-2-4-判断" class="headerlink" title="2.2.4 判断"></a>2.2.4 判断</h4><ul>
<li>使用 <code>import x</code> 导入一个包或模块。</li>
<li>使用 <code>from x import y </code> ， <code>x</code> 包的前缀， <code>y</code> 是不带</li>
</ul>
<p><a id="typing-imports"></a></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Logging 使用实践</title>
    <url>/2021/03/31/programming/python/python_logging/</url>
    <content><![CDATA[<p>日志是开发过程中一个重要的环节，贯穿开发到部署。良好的日志习惯能提高开发调试效率，而且可以在程序出问题时，快速精准定位问题所在，及时修复<br>BUG。</p>
<span id="more"></span>

<h2 id="一、Python-日志基础"><a href="#一、Python-日志基础" class="headerlink" title="一、Python 日志基础"></a>一、Python 日志基础</h2><p>相关文章：</p>
<p><a href="https://docs.python.org/zh-cn/3/howto/logging.html#logging-basic-tutorial">日志 HOWTO</a></p>
<p><a href="https://docs.python.org/zh-cn/3/library/logging.html">Python 的日志记录工具</a></p>
<h2 id="二、Python-日志实践"><a href="#二、Python-日志实践" class="headerlink" title="二、Python 日志实践"></a>二、Python 日志实践</h2><p>下面开始实践，基础内容不在赘述，其中要点会引用相关文档</p>
<h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h3><p>本情况适用于临时需要使用日志系统，或者简单使用的场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.warning(<span class="string">&#x27;I love you ~&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;I love you too ~~~&#x27;</span>)  <span class="comment"># 这条日志是永远不会打印出来的，它永远不会回爱你。</span></span><br><span class="line">logging.error(<span class="string">&#x27;I hate you !&#x27;</span>)  <span class="comment"># 这条日志会打印出来！</span></span><br></pre></td></tr></table></figure>

<p>输入如下：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">WARNING:root:I love you ~</span><br><span class="line">ERROR:root:I hate you !</span><br></pre></td></tr></table></figure>

<p>根据文档 <a href="https://docs.python.org/zh-cn/3/howto/logging.html#logging-levels">日志级别</a> 中描述，日志分为多个等级。<br>从上述示例中可以看到日志的默认等级是 <code>WARNING</code> ，低于此等级的日志默认情况下是不会输出的。</p>
<p>在实际开发中，推荐使用日志的方式来输出程序信息，而不是使用 <code>print</code> 。当你在开发的时候先使用了 <code>print</code> 输出信息，在后期需要<br>改用日志的时候，就会改动很多代码。而且使用日志后，可以很方便的调整日志等级，过滤你想看到的内容。</p>
<h4 id="1-1-自定义日志配置"><a href="#1-1-自定义日志配置" class="headerlink" title="1.1 自定义日志配置"></a>1.1 自定义日志配置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%dT%H:%M:%S.%s+0800&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&#x27;I love you~&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;I love you too ~&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">2021-03-31T16:30:14.1617179414+0800 - root - DEBUG - I love you~</span><br><span class="line">2021-03-31T16:30:14.1617179414+0800 - root - INFO - I love you too ~</span><br></pre></td></tr></table></figure>

<p>上述示例为日志配置了日志级别，日志格式和时间格式。其中使用了 <code>DEBUG</code> 级别显示日志，使用日志格式字符串显示格式化的日志内容，<br>而且在显示时间上也做了格式化，符合 <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> 。</p>
<p>日志格式化参数可以参考 <a href="https://docs.python.org/zh-cn/3/library/logging.html#logrecord-attributes">LogRecord 属性</a> 中<br>包含的属性名称。如果需要显示更详细的日志信息，可以自行添加格式化字段，如 <code>filename</code> 、 <code>process</code> 、 <code>thread</code> 等。</p>
<p>推荐的几个日志格式：</p>
<p><strong>简单信息:</strong></p>
<p><code>%(asctime)s - %(name)s - %(levelname)s - %(message)s</code></p>
<p>输出示例：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">2021-03-31T17:05:29.1617181529+0800 - root - DEBUG - I love you~</span><br><span class="line">2021-03-31T17:05:29.1617181529+0800 - root - INFO - I love you too ~</span><br></pre></td></tr></table></figure>

<p><strong>一般信息:</strong></p>
<p><code>%(asctime)s - %(name)s - %(levelname)s - %(module)s - %(process)d %(thread)d - %(message)s</code></p>
<p>输出示例：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">2021-03-31T17:05:42.1617181542+0800 - root - DEBUG - simple_logger - 19146 140370774697792 - I love you~</span><br><span class="line">2021-03-31T17:05:42.1617181542+0800 - root - INFO - simple_logger - 19146 140370774697792 - I love you too ~</span><br></pre></td></tr></table></figure>

<p><strong>详细信息:</strong></p>
<p><code>%(asctime)s - %(name)s - %(levelname)s - %(module)s - %(process)d %(thread)d - %(pathname)s:%(lineno)d %(message)s</code></p>
<p>输出示例：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">2021-03-31T17:05:54.1617181554+0800 - root - DEBUG - simple_logger - 19343 139933362054976 - /foo/simple_logger.py:13 I love you~</span><br><span class="line">2021-03-31T17:05:54.1617181554+0800 - root - INFO - simple_logger - 19343 139933362054976 - /foo/simple_logger.py:14 I love you too ~</span><br></pre></td></tr></table></figure>

<h4 id="1-2-增加日志对象"><a href="#1-2-增加日志对象" class="headerlink" title="1.2 增加日志对象"></a>1.2 增加日志对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(</span><br><span class="line">    fmt=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%dT%H:%M:%S.%s+0800&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建控制台 handler</span></span><br><span class="line">console_handler = logging.StreamHandler()</span><br><span class="line">console_handler.setFormatter(formatter)</span><br><span class="line">console_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件 handler</span></span><br><span class="line">file_handler = logging.FileHandler(filename=<span class="string">&#x27;foo.log&#x27;</span>)</span><br><span class="line">file_handler.setFormatter(formatter)</span><br><span class="line">file_handler.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 foo logger</span></span><br><span class="line">foo_logger = logging.getLogger(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">foo_logger.addHandler(console_handler)</span><br><span class="line">foo_logger.addHandler(file_handler)</span><br><span class="line">foo_logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 bar logger</span></span><br><span class="line">bar_logger = logging.getLogger(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">bar_logger.addHandler(console_handler)</span><br><span class="line">bar_logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">foo_logger.debug(<span class="string">&#x27;This debug msg&#x27;</span>)</span><br><span class="line">foo_logger.info(<span class="string">&#x27;This info msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar_logger.debug(<span class="string">&#x27;This debug msg&#x27;</span>)</span><br><span class="line">bar_logger.info(<span class="string">f&#x27;This info msg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">2021-03-31T16:40:18.1617180018+0800 - foo - DEBUG - This debug msg</span><br><span class="line">2021-03-31T16:40:18.1617180018+0800 - foo - INFO - This info msg</span><br><span class="line">2021-03-31T16:40:18.1617180018+0800 - foo - DEBUG - This debug msg</span><br><span class="line">2021-03-31T16:40:18.1617180018+0800 - foo - INFO - This info msg</span><br></pre></td></tr></table></figure>

<h3 id="2-日志配置文件"><a href="#2-日志配置文件" class="headerlink" title="2. 日志配置文件"></a>2. 日志配置文件</h3><p><a href="https://docs.python.org/zh-cn/3/library/logging.config.html#configuration-dictionary-schema">配置字典的 Schema</a> 配置字段都在<br> <a href="https://docs.python.org/zh-cn/3/library/logging.config.html#dictionary-schema-details">Schema 详情</a> 中。</p>
<p>在 <a href="https://docs.python.org/zh-cn/3/howto/logging.html#configuring-logging">配置日志记录</a> 中讲了配置日志的几种方式。</p>
<p>下面通过几个 Example 配置说明</p>
<h4 id="2-1-Dict"><a href="#2-1-Dict" class="headerlink" title="2.1 Dict"></a>2.1 Dict</h4><p>logging.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.config <span class="keyword">import</span> dictConfig</span><br><span class="line"></span><br><span class="line">LOGGING_CONFIG = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;require_debug_false&#x27;</span>: &#123;</span><br><span class="line">            <span class="comment"># 这里的小括号是使用了日志自定义日志对象。参考 https://docs.python.org/zh-cn/3/library/logging.config.html#user-defined-objects</span></span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugFalse&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;require_debug_true&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;detailed&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.Formatter&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(asctime)s %(name)-15s %(levelname)-8s %(processName)-10s %(message)s&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console_handle&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="comment"># 这里的 stream 是 StreamHandler 的参数。该参数也可以是 ext://sys.stderr</span></span><br><span class="line">            <span class="comment"># 参考 https://docs.python.org/zh-cn/3/library/logging.config.html#access-to-external-objects</span></span><br><span class="line">            <span class="string">&quot;stream&quot;</span>: <span class="string">&quot;ext://sys.stdout&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;access_handle&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.FileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;access-file.log&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;detailed&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;rotating_file_handle&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;rotating-file.log&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;detailed&#x27;</span>,</span><br><span class="line">            <span class="comment"># 后面三个参数是 RotatingFileHandler 的参数。</span></span><br><span class="line">            <span class="comment"># 参考 https://docs.python.org/zh-cn/3/library/logging.config.html#dictionary-schema-details 的 handles</span></span><br><span class="line">            <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;errors_handle&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.FileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;error.log&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;detailed&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;access&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;access_handle&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;foo&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;access_handle&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># logger 的 name 的点可以起到日志分级的作用。子级 foo.bar 日志可以传递到父级 foo ，并被捕获。</span></span><br><span class="line">        <span class="comment"># 所以在创建日志对象的时候推荐使用 `logging.getLogger(__name__)`。这样可以使用Python的包的层级。</span></span><br><span class="line">        <span class="comment"># 参考 https://docs.python.org/zh-cn/3/library/logging.html#logger-objects</span></span><br><span class="line">        <span class="string">&#x27;foo.bar&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;access_handle&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console_handle&#x27;</span>, <span class="string">&#x27;access_handle&#x27;</span>, <span class="string">&#x27;errors_handle&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logging.config.dictConfig(LOGGING_CONFIG)</span><br></pre></td></tr></table></figure>

<p>在 Python 中使用字典形式是常见的操作，因为这是最早支持的方式。在 <code>python 3.2</code> 引入了 yaml 的方式</p>
<h4 id="2-2-yaml"><a href="#2-2-yaml" class="headerlink" title="2.2 yaml"></a>2.2 yaml</h4><p>logging.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">disable_existing_loggers:</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">formatters:</span></span><br><span class="line">  <span class="attr">simple:</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">  <span class="attr">console:</span></span><br><span class="line">    <span class="attr">class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">formatter:</span> <span class="string">simple</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="string">ext://sys.stdout</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">  <span class="attr">simpleExample:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">handlers:</span> [<span class="string">console</span>]</span><br><span class="line">    <span class="attr">propagate:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">uvicorn.error:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">INFO</span></span><br><span class="line">  <span class="attr">uvicorn.acdess:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">INFO</span></span><br><span class="line">    <span class="attr">propagate:</span> <span class="literal">False</span></span><br><span class="line">    <span class="attr">handles:</span> [<span class="string">access</span>]</span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">  <span class="attr">handlers:</span> [<span class="string">console</span>]</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<p>先安装 yaml 解析工具。这里使用 pyyaml，其他解析库参考 <a href="https://yaml.org/">yaml</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyyaml</span><br></pre></td></tr></table></figure>

<p>编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.config <span class="keyword">import</span> dictConfig</span><br><span class="line"><span class="keyword">from</span> yaml <span class="keyword">import</span> load</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> yaml <span class="keyword">import</span> CLoader <span class="keyword">as</span> Loader, CDumper <span class="keyword">as</span> Dumper</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> yaml <span class="keyword">import</span> Loader, Dumper</span><br><span class="line"></span><br><span class="line">LOGGING_CONFIG = load(<span class="built_in">open</span>(<span class="string">&#x27;logging.yaml&#x27;</span>), Loader=Loader)</span><br><span class="line">logging.config.dictConfig(LOGGING_CONFIG)</span><br></pre></td></tr></table></figure>

<p>上面对于参数都已经做了说明，yaml 示例就不在作解释。</p>
<h4 id="2-3-ini"><a href="#2-3-ini" class="headerlink" title="2.3 ini"></a>2.3 ini</h4><p>参考 <a href="https://docs.python.org/zh-cn/3/library/logging.config.html#configuration-file-format">配置文件格式</a></p>
<p>logging.ini / logging.cfg / logging.conf</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[loggers]</span></span><br><span class="line"><span class="attr">keys</span>=root,simpleExample</span><br><span class="line"></span><br><span class="line"><span class="section">[handlers]</span></span><br><span class="line"><span class="attr">keys</span>=consoleHandler</span><br><span class="line"></span><br><span class="line"><span class="section">[formatters]</span></span><br><span class="line"><span class="attr">keys</span>=simpleFormatter</span><br><span class="line"></span><br><span class="line"><span class="section">[logger_root]</span></span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">handlers</span>=consoleHandler</span><br><span class="line"></span><br><span class="line"><span class="section">[logger_simpleExample]</span></span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">handlers</span>=consoleHandler</span><br><span class="line"><span class="attr">qualname</span>=simpleExample</span><br><span class="line"><span class="attr">propagate</span>=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[handler_consoleHandler]</span></span><br><span class="line"><span class="attr">class</span>=StreamHandler</span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">formatter</span>=simpleFormatter</span><br><span class="line"><span class="attr">args</span>=(sys.stdout,)</span><br><span class="line"></span><br><span class="line"><span class="section">[formatter_simpleFormatter]</span></span><br><span class="line"><span class="attr">format</span>=%(asctime)s - %(name)s - %(levelname)s - %(message)s</span><br><span class="line">datefmt=</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.config <span class="keyword">import</span> fileConfig</span><br><span class="line"></span><br><span class="line">fileConfig(<span class="string">&#x27;logging.ini&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>相对来说，yaml 格式在可读性上更强。但是在可操作性上，字典格式可以直接写在 python 文件中，而且可以根据变量灵活判断。</p>
<h3 id="3-声明式定义日志级别"><a href="#3-声明式定义日志级别" class="headerlink" title="3. 声明式定义日志级别"></a>3. 声明式定义日志级别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> RotatingFileHandler</span><br><span class="line"></span><br><span class="line"><span class="comment"># format</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Handler</span></span><br><span class="line">rotating_file_handle = RotatingFileHandler(<span class="string">&#x27;rotating-file.log&#x27;</span>, maxBytes=<span class="number">1024</span>, backupCount=<span class="number">10</span>)</span><br><span class="line">rotating_file_handle.setLevel(logging.DEBUG)</span><br><span class="line">rotating_file_handle.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">stream_handler = logging.StreamHandler()</span><br><span class="line">stream_handler.setLevel(logging.DEBUG)</span><br><span class="line">stream_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loagger</span></span><br><span class="line">logging.root.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">foo_logger = logging.getLogger(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">foo_logger.setLevel(logging.DEBUG)</span><br><span class="line">foo_logger.addHandler(rotating_file_handle)</span><br><span class="line"></span><br><span class="line">foot_bar_logger = logging.getLogger(<span class="string">&#x27;foo.bar&#x27;</span>)</span><br><span class="line">foot_bar_logger.setLevel(logging.WARN)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Logging</tag>
      </tags>
  </entry>
  <entry>
    <title>大规模分解API优先转换。在PayPal学习的经验教训–第1部分</title>
    <url>/2020/08/27/api-design/paypal_api_first_part1/</url>
    <content><![CDATA[<blockquote>
<p>本文是 <a href="https://www.infoq.com/articles/paypal-api-first-part1/?itm_source=infoq&itm_campaign=user_page&itm_medium=link">Untangling an API-First Transformation at Scale. Lessons Learnt at PayPal – Part 1</a><br>的翻译，仅供学习交流。如有翻译不当，请斧正。所有权归原作者，侵删。</p>
</blockquote>
<p><strong>要点</strong></p>
<ul>
<li>在大型组织中实现以 API 优先的转换既是技术难题，也是人员问题。</li>
<li>组织架构将极大地影响您的API优先成功策略</li>
<li>将转型本身视为产品可促进长期成功</li>
<li>流程和治理是必要的，但要轻量并使其适合您的客户</li>
<li>要低估对工具，基础架构和使其有效运行所需的人员的投资</li>
</ul>
<span id="more"></span> 

<h2 id="制定API策略"><a href="#制定API策略" class="headerlink" title="制定API策略"></a>制定API策略</h2><p>过不了多久，对外公开您的核心系统就会成为僵局。真正的产品是基于这些内部内容构建的应用程序和体验。大多数产品投资都导致了垂直集成的解决方案，这些解决<br>方案只能提供相对有限的功能。投资一个完全不同得用例集或者不同得产品线通常是计较困难或不可行的。在这种情况下，很自然得就将基础架构视为浸没成本[^1]或<br>仅为内部系统。很难以不同得方式思考它。</p>
<p>大人，时代变了。现在每家公司或多或少的都有一个 API 策略，该策略通过以可重用服务的形式公开结果，努力利用其很大一部分技术投资。高级别目标是通过使<br>核心业务功能易于访问和可重用来加速业务敏捷性。降低集成成本不仅对内部速度产生积极影响，而且还挺提高了结合客户、合作伙伴和收购对象的灵活性与速度。整体<br>式，垂直排列的一团烂泥的时代快要结束了。现在统称为 “微服务”，他是通过精心设计和记录 API 公开的，且有清晰的有限上线文和语义上不同的业务价值。</p>
<h2 id="API-经济"><a href="#API-经济" class="headerlink" title="API 经济"></a>API 经济</h2><p>为什么要改变？ API 经济的出现改变了规则。</p>
<p>世界上一些价值最高的公司 Facebook 、Google 、Amazon 前不就都发现打开和服[^2] 并为外部开发人员提供更多的核心产品的访问权是利用其技术投资的好<br>方法，加强产品组合，扩大合作机会。他们建立了强化共享和重复使用原则的文化，这对于实现这一目标至关正要。这促进了 API 的经济发展，使许多新产品的构建<br>和市场测试比以前更快、更便宜。 API 提供商从以下方面收益：更多的客户、更多的流量、更深的集成，以及至少对于某些人而言，是数十亿美元新业务的开始。<br>甚至 Twitter 都将其早起的成功归功于 API 策略，即使以后他们撤回了。</p>
<p>第二梯队，像 Twilio 和 Stripe 这样的公司，完全跳过了传统的 “产品” 部分。他们将 API 本身作为其核心产品，并专注于提供出色的开发人员体验，以此<br>作为其首要任务。他们的客户迅速集成，并从基本必须的功能中收益，而不必自己构建和维护许多不可区分的功能。敏捷度提高。黑客马拉松开始了。应用和初创企业<br>爆炸式增长。它成为构建新体验，迭代和验证产品与市场的契合度的默认方法。</p>
<p>为了保持竞争优势，您的组织还需要采用 API 优先的方法。在您如何看待和思考您的技术产品组合方面将产生重大改变。</p>
<h2 id="实现您的未来"><a href="#实现您的未来" class="headerlink" title="实现您的未来"></a>实现您的未来</h2><p>对于较新的公司来说，他们可能已经像第二梯队那样做了。但是如果您是一家拥有大量现有基础设施和客户的大、成熟公司，该怎么办？在继续经营业务的同时如何进行过度？</p>
<p>首先，您的技术前景可能看起来完全不同。你的遗留代码库（可能受 SOA 影响，但在 “微服务” 还没成为一个词之前就已经开发了）可能不太理想。这些年来，您<br>可能积累了很多技术债务，并且您可能没有一种文化来固有地清华清晰得组件化和重用原则。测试可能参差不齐，各种重组和废弃醒目可能遗留下来的骨架。文档可能<br>有很多不足之处。这不是一个开始进行重大微服务转换的良好水平的基础。正如我们所说，存在许多 “挑战” 。</p>
<p>另一个主要的考虑因素是组织的变化。高管人员可能会相信 API 优先策略的必要性，但他们对实现该战略所需要的承诺的理解可能有所不同。了解自己在这个范围内的位置对你的成功非常重要。</p>
<p>极端情况下，你开始了一个新项目，所有进度停止，当务之急是所有人都完全参与这个项目，其他工作都要搁置。这种情况非常少见。如果您现在处于这种情况，直接<br>开干。把它看做一个庞大的项目，并快速实施。但您想再这么做几乎不可能了。</p>
<p>实际上您可能在两者之间。可能会承诺降低开发速度，但是走的会更远，并且在未来需要更新技术。作为转型的领导者，这感觉更加混乱。这其中有许多困难和重要的<br>问题，而这些问题没有明显的答案。如何确定优先级？那些团队会这样做？如何进行协调？什么时候做？您的工作变得更加复杂。它不在是一个项目。现在他是一个复杂<br>的转型，可能会持续数年，并且与祖师变革和技术变革一样重要。</p>
<h2 id="给你的产品带上帽子-Put-on-Your-Product-Hat"><a href="#给你的产品带上帽子-Put-on-Your-Product-Hat" class="headerlink" title="给你的产品带上帽子(Put on Your Product Hat)"></a>给你的产品带上帽子(Put on Your Product Hat)</h2><p>在 PayPal，我们已经实施了三年以上。我们采用一种以客户为中心的方法，从一个非常单一的、孤立得体系结构过渡到一组松耦合的 150 多种服务，他们具有精心<br>设计的现代 API 。</p>
<p>有一种将此过程视为工程醒目的趋势。我们没有。相反，我们将其视为更大得组织变更问题，而“产品”是我们设计和构建 API 的根本转变。因此，我们被迫确定和<br>服务所有关键的“客户”，即构建和使用 API 的开发人员以及支持它们的执行人员。它们决定了我们的战略，我们建立的工具，沟通方式以及衡量成功的方式。<br>识别客户并关注他们的满意度是一项基本的原则。这种心态使我们成功的关键，并且它将继续形象我们今天如何管理该计划。</p>
<p>虽然没有两家公司是相同的，但我们学到的许多经验教训和使用的方法都是用于同一条道路上的其他组织。</p>
<p>为了解决这个问题，我们使用成为 “3P” 的框架组织工作。</p>
<ul>
<li><strong>产品</strong> - 用于管理 API 和基础服务实现组合的基础结构，标准和工具</li>
<li><strong>产品组合</strong> - 业务功能的目录，表示为 API 和基础服务</li>
<li><strong>计划</strong> - 用于激励祖师行为和技术投资变化的指标，培训和杠杆</li>
</ul>
<p>本文是这三部分的第一篇，后面将会更详细的阐述这些方面。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>在一个由几十到大约 50 或 60 个开发人员组成的小公司中，核心利息相关者进入会议室，在白板上定制计划，分担责任并开始工作并不困难。将计划和目标达成共识，<br>并且在进行一些迭代和过程更正后，您可能最后会得到一组很好得集成且紧密结合的 API 和代表平台的基础服务。您的时间轴可能以月为单位，或者以季度为单位。</p>
<p>在大型组织中，情况有所不同。您可能有成千上万的开发人员分布在多个业务部门和地区，所有这些业务都有不同的目标，而且通常具有不同的技术栈。由于许多原因，<br>其中最重要的 <a href="https://en.wikipedia.org/wiki/Dunbar%27s_number">Dunbar的数字</a> 您无法和每个人沟通，达成共识并开始工作。你需要的是一种更<br>分散、弹性的东西，这种东西能增强你的目标，而不依赖于脆弱的共识或大规模的项目协调。在这种情况下，“产品”实际是个是支持转换的基础（而不是 API本身）。<br>这本身就是一项重大投资。至少，它可能包括以下内容：</p>
<ul>
<li>定义 API 通用原则和标准的文档</li>
<li>开发 API 时要确保良好的开发规范</li>
<li>包含清晰可观的衡量方法在内的治理方法</li>
<li>某种集中式门户网站，用于合并 API 以及管理流程和指标</li>
</ul>
<h2 id="原则于标准"><a href="#原则于标准" class="headerlink" title="原则于标准"></a>原则于标准</h2><p>在 PayPal ， 我们开始思考那些共同思想指导我们朝着现实良好封装服务的目标迈进，这些服务公开了设计良好、可重复使用的 API 。这些成为了我们的核心原则，<br>并构成了我们随后的标准文档。</p>
<ul>
<li><strong>松耦合</strong>: 服务和消费者必须相互松散耦合</li>
<li><strong>封装</strong>: 域服务只能通过其他服务契约[^3]访问它不拥有的数据和功能。</li>
<li><strong>稳定性</strong>: 服务契约[^3]必须具有可测试的生命周期，并且使用寿命长</li>
<li><strong>可重用行</strong>: 服务必须开发为可在多个上下文中和由多个使用者重用</li>
<li><strong>基于契约[^3]</strong>: 功能和数据只能通过标准化服务契约[^3]公开</li>
<li><strong>一致性</strong>: 服务必须遵循一组通用的原则，交互方式，词汇和共享类型</li>
<li><strong>易于使用</strong>: 服务必须易于使用并且可有消费者组成</li>
<li><strong>可外部化</strong>: 服务的设计必须使它们提供的功能易于外部化。</li>
</ul>
<p>我们将 REST/json 作为主要接口标准，并开发了全面的<a href="https://github.com/paypal/api-standards">风格指南</a>，<br>以帮助确保数百个可能在组织中构建服务端团队的一致性。其中包括 URL 结构、标头用法、查询参数、版本控制、资源命名、安全性、日志记录、错误处理、超媒体等内容。</p>
<p>我们还必须解决的是 API 契约[^3]档使用哪些格式。我们希望所有服务开发人员都使用相同得格式来记录其 API ，以便我们可以利用通用的工具和基础架构。</p>
<p>当我们开始时， API 市场还不成熟，实际上并没有事实上的 API 文档标准。最后我们采用了 <a href="https://developers.google.com/discovery/v1/reference/apis">Google 发现文档</a><br>（GDD），因此看起来还不错，也比大多数更好。从社区支持和采用的角度看，这很快就无济于事。我们最终为 GDD 开发了相当多得工具和支持，直到 2015 年中期<br>左右我们大多数开发人员都希望使用 OpenAPI（也叫 Swagger）。大约在那时，我们决定将所有 API 迁移到 OpenAPI 规范，并加入了<br><a href="https://openapis.org/">OpenAPI Initiative</a> （OAI）。它的使用，使我们减少在基础设施的投资，获得了更大的收益。总体而言，它更强大，并且我们<br>的开发商更愿意使用。</p>
<h2 id="参与过程"><a href="#参与过程" class="headerlink" title="参与过程"></a>参与过程</h2><p>当你说 “管理” 一词是，大多数人会反感。感觉就像是 “大公司” 一词，是 “官僚主义” 和 “傲慢” 的同义词。人们想逃避。实际情况是，如果你要在大型，高度分散<br>的大型组织中强制执行标准和一致性，则不可避免地需要执行某种过程。重要得是要意识到这不仅仅是技术问题。与改变人类行为的真正难题相比，这相对容易。<br>良好的意图很好，但是需要某种形式的非可选过程来增强您想要的结果。就是说，是过程尽可能简单，轻巧和快速以最小化摩擦最大程度地提高满意度才是非常重要的。</p>
<p>我们开发的基本参与流程如下：</p>
<p><img src="https://res.infoq.com/articles/paypal-api-first-part1/en/resources/1Picture1.jpg"></p>
<p>当构建 API 的团队提交概述其计划，包括用例以及通常提议的设计的提议时，该过程开始。</p>
<ul>
<li>**标准(Alignment)**：一支中心团队于领域架构师和产品负责人协作，确定名称，命名空间，资源等。目标是是 API 适应更大得产品组合的范围，<br>  并确保从外而内的角度“有道理”（稍后会有更多介绍）。</li>
<li>**审核(Review)**：团队使用标准格式记录API，并且跨领域的API设计专家团队提供有关如何提高可用性，一致性以及如何满足预期标准的反馈和建议。<br>  通常，这需要经过数次完善。</li>
<li>**评分(Score)**：指定的API设计提交者根据一组反映设计标准的规范标准对API设计进行评分。</li>
<li>**验证(Verify)**：API所有者验证其已审阅且由源代码控制的 API 契约[^3]是否与其基础服务实现相匹配。他们使用 API 一致性工具将CI作业中的请求/响应<br>  样本与版本化的API合同进行比较，并生成分数。</li>
</ul>
<p>验证后，将部署基础API服务实现，并适当更新 API 的生命周期状态。客户现在知道该文档的哪个版本与他们的集成有关。</p>
<p>值得暂停一下以重申在此过程中客户满意度的重要性。这是我们在一开始就不足的领域。我们发现，尽管我们在设计流程方面做得很好，但我们还没有做好大规模操作<br>的准备。我们从根本上低估了所需的基础架构，而我们的手工步骤太多了。花费了太长时间，没有设定客户期望，并且每个问题和每个延迟都成为该过程的错误。<br>有很多投诉，我们需要迅速解决，否则可能会破坏整个工作。</p>
<p>该解决方案是多方面的，包括以下内容：</p>
<ul>
<li><strong>加强自动化</strong> 许多步骤需要手动将事物从一种状态转移到另一种状态，更新数据并发出通知。通过自动化和自助服务，我们大大减少了盲目的工作，<br>  提高了响应速度，并使客户满意。您无法在电子表格中进行管理。</li>
<li><strong>设定现实的期望</strong> 按照定义，对开发人员施加新流程是一项新工作。开发人员需要了解 API 审查是他们需要纳入计划和说明的内容。他们还需要了解在软件<br>  开发生命周期中何时进行操作（提示：尽可能早地进行）。广泛的宣传和培训有助于设定切合实际的期望并提高满意度。</li>
<li><strong>倾听并迅速做出反应</strong> 您无法在第一时间得到正确的解决方案，因此请与客户交谈，并通过快速进行更改来向他们表明您的关心。这可以建立信任，<br>  并增强他们在下次参与时对流程的奉献精神。如果大多数开发人员了解更广阔的视野，他们希望您成功。他们会支持您并保持耐心，<br>  但您应归功于他们来倾听并偿还这种信任。</li>
</ul>
<p>我们设法在大约四分之一的时间内大幅度减少了客户的投诉，直到今天，我们仍在不断重复这些方面的工作。如果能必须重来一次的话，<br>我们会启动时首先做更好的基础架构支持，其次是在营销和拓展方面花费更多时间来教育团队，设定期望并倾听反馈。与任何产品发布一样，如果要给您的客户一个<br>良好得体验并建立一个积极的反馈循环，最好延迟一点启动时间。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>大公司往往是非常受指标驱动的。每个产品和程序都可以归结为一个或两个指标以及仪表板上的状态。为了获得成功，您需要仔细考虑所衡量的内容，<br>与业务价值的关系以及如何为您的旅程设定正确的里程碑。</p>
<p>在 API 驱动的转换中，两个高级业务收益是降低集成成本和提高业务敏捷性。将您的业务功能重构为精心设计和记录良好的 API ，可以更轻松地在内部和外部与<br>合作伙伴和客户进行集成，并且可以使您以不同得创新方式快速重新组合功能。通过最大限度地减少多余得投资并扩展可寻址的市场，<br>这可以缩短产品上市时间并提高效率。不幸的是，很难直接归因和衡量这两个好处。您可能要做的最好得事情就是找到一个间接的指标，<br>该指标通过共识可以与这些更广泛得好处相关联。</p>
<p>我们解决这个问题的方法是开发一个成熟度模型，该模型表示 API 接近理想程度的一种质量得分。在这种情况下，“理想”是完全封装的服务，<br>该服务遵循所有API设计标准并且运行良好。这个想法是，当大多数业务功能通过高成熟度 API 服务公开时，业务利益将得到最佳实现。</p>
<p>以我们的标准为起点，我们创建了标准，并将其放置在1到5的范围内。我们还添加了一些标准，这些标准用于衡量 API 是否适合更广泛的业务能力组合，<br>并通过纳入<a href="https://blog.csdn.net/solaris_navi/article/details/5336481">SLA 标准</a>来鼓励某些运营属性通过对成熟度模型进行版本控制<br>并控制每个标准在规模上的位置，我们已经能够逐步将API产品组合推向更理想的状态。我们根据失败的最低评分标准衡量每个API的成熟度得分。<br>这使我们能够使用简单的成熟度指标（对所有服务进行标准化）来汇总API产品组合的整体质量。</p>
<p><img src="https://res.infoq.com/articles/paypal-api-first-part1/en/resources/1Picture2.jpg"></p>
<p>上图是我们的一次记分记录，其中显示了 API 的成熟度评估。每个图像代表一个标准，这些标准源自我们要强制执行的标准。开发人员使用它可以快速了解通过了<br>哪些条件以及失败了的条件。他们单击每个按钮，深入研究细节，进行更正，并更新分数，直到达到成熟目标。在过去的几年中，我们同时改进了模型和基础架构。<br>现在，我们支持成熟度模型的多个同步版本，这使我们能够随着时间的推移不断发展和完善我们的标准，而不会破坏现有API的成熟度级别。<br>API可以在迭代和发布新得接口版本时升级到新的模型版本。</p>
<h2 id="开发者网站"><a href="#开发者网站" class="headerlink" title="开发者网站"></a>开发者网站</h2><p>这部分基础架构可能是最重要的。鉴于大型组织的规模，您确实需要一个中心位置来整合所有 API ，所有文档，参与过程以及总体计划状态和进度。<br>这最终成为内部开发人员门户，与组织的行为进行沟通和协调至关重要。</p>
<p>刚开始，PayPal发生了一件非常有趣的事情。在启动我们的网站之前，我们已经在内部 Wiki 上开发了大部分标准和文档。没有人注意。<br>它丢失在混乱得文档和更新的文档中，而这些文档往往出现在任何长期的公司 Wiki 中。</p>
<p>作为实验，我们决定创建一个简单的网站，该网站的大部分静态内容与 Wiki上 已有的内容相同，为 95％ 。我们在 Intranet 上为其提供了不错的视觉设计和<br>一流的URL。我们花了一个星期来建造它。几乎一夜之间，情况发生了变化。高管们开始把这个网站称为“PayPal的未来”。它出现在演示文稿中，我们开始产生流量，<br>人们开始认真对待它。我们真正要做的只是改变包装，但观念却发生了根本变化。我们以为这会有所作为，但幅度真得让我们感到惊讶。突然，我们有了信誉，<br>并有了一定的发展动力。</p>
<p>这是一个转折点。那一刻也强化了从产品而不是从技术角度考虑程序的重要性。最后，我们要做的就是改变人们的行为。技术改造实际上只是副产品。为此，<br>您需要专注于客户并从他们的角度进行思考。这是我们的一课，我们已经将网站和程序发展为更加以客户为中心和更强大的功能。现在，<br>它是 PayPal 中访问量最大得内部应用程序之一。除了其他东西，这个网站提供：</p>
<ul>
<li>所有 API 的清单，包括接口，文档，样本，指标，所有权，反馈机制和成熟度评估详细信息。</li>
<li>所有标准文档，版本信息和指南。</li>
<li>版本化 API 合同的生命周期状态管理。</li>
<li>在整个开发生命周期中提出和跟踪新API状态的参与过程。</li>
<li>计划级别的报告和成熟度级别的仪表板，以及达到里程碑的进度。</li>
</ul>
<p>这项投资并非微不足道，但实现该计划的目标绝对至关重要。</p>
<p>在下一篇文章中，我们将探讨如何使用此基础结构来帮助塑造API产品组合本身。其主要目标是在API之间建立清晰的边界，以鼓励以可预测的有用方式分解整体。</p>
<p>关于作者</p>
<p>Erik Hogan近二十年来一直在学习成为一名出色的产品经理意味着什么。大部分时间都花在了了解如何成为可以扩展的客户拥护者和可信赖的领导者上。他非常满意，<br>可以将复杂得问题分解为可重复使用的部分，并为工程提供准确执行快速执行所需的功能。最近，他一直在使用简单性，讲故事和专注等基本产品概念来影响组织变革，<br>这是一种非常不同的“产品”。同样，当他的妻子要求她的成功标准时，他仍然会生气。</p>
<p>[^1]: 被舍弃的选项中可能获得的最高价值；还指厂商把相同得生产要素投入到其他行业当中去可以获得的最高收益。 沉没成本（Sunk Cost，也叫沉淀成本）<br>    是指由于过去的决策已经发生了的，而不能由现在或将来的任何决策改变的成本。<br>[^2]: 打开和服指的是向未来的新合伙人披露某一项目或本公司的内部运作情况。<br>[^3]: 契约，原文直译为 <code>合同</code> ，表达的意思是 API（服务） 接口的全部信息，包括接口名称，参数，返回值，消息头等内容。</p>
]]></content>
      <tags>
        <tag>api-design</tag>
      </tags>
  </entry>
  <entry>
    <title>大规模分解API优先转换。在PayPal学习的经验教训–第2部分</title>
    <url>/2020/08/28/api-design/paypal_api_first_part2/</url>
    <content><![CDATA[<blockquote>
<p>本文是 <a href="https://www.infoq.com/articles/paypal-api-first-part2/?itm_source=infoq&itm_campaign=user_page&itm_medium=link">Untangling an API-first Transformation at Scale. Lessons Learnt at PayPal – Part 2</a><br>的翻译，仅供学习交流。如有翻译不当，请斧正。所有权归原作者，侵删。</p>
</blockquote>
<p><strong>要点</strong></p>
<ul>
<li>为您的业务定义业务能力分类法</li>
<li>在谈论和思考您的API时采用API产品心态</li>
<li>开发以客户为中心的流程来管理您的API产品组合</li>
<li>将服务实现工件与API分离</li>
<li>您的API转换是一种文化变革，而不是一次性项目</li>
</ul>
<p>这是一个由三部分组成的系列文章的第二部分，该系列文章探讨了PayPal如何采用更为API优先的方法来构建平台服务。在第一部分中，我们探讨了迁移到松散耦合，<br>API驱动的体系结构的原因，以及使该过程大规模运行所需的一些基础结构。在本文中，我们将仔细研究如何管理API本身的产品组合。</p>
<span id="more"></span>

<h2 id="充分利用每一项API投资"><a href="#充分利用每一项API投资" class="headerlink" title="充分利用每一项API投资"></a>充分利用每一项API投资</h2><p>您正在不断构建新功能。从理论上讲，这些投资中的每一项都是由正当，合理地战略和路线图驱动的。</p>
<p>现实更加混乱。我们倾向于将路线图视为优先投资的连续体，以帮助我们实现战略目标。但是，随着我们缩短时间范围，出现了一些实际情况。首先是我们的立即<br>执行计划往往因为一小部分高知名度项目和关键合作伙伴关系而严重影响。部分原因是希望有一些切实得目标可以团结起来，也可能是紧急项目需要先完成。<br>我们可能已经与一个大客户签订了重要协议。我们可能已经收购了一家需要整合的公司。这样的功能可能需要在假期之前推出。这些都是非常<br>真实的项目，具有非常真实的日期。事实证明，当实际上，我们漂亮得、战略上一致得、哲学上合理得路线图看起来更受事件驱动。</p>
<p>这有问题吗？好吧，没有，从使团队朝着共同目标努力并确保我们专注于业务最重要得优先事项的角度出发。它有助于调整组织。它在战术层面上提出的挑战是，<br>我们已经将精美得平台愿景缩减为一小组狭义的解决方案。底层工人（负责实际完成工作的人员）自然会为其成功进行优化。他们的环境成为当前的项目，<br>这意味着他们倾向于在这些解决方案范围内做出决策。</p>
<p>在API优先组织中，这是一个巨大的挑战。我们正在尝试构建一组可重用的功能，这些功能不会过度偏向任何特定的合作伙伴或项目。我们希望我们的技术投资能够<br>最大程度地发挥其效用，这意味着构建可在多种环境中使用的通用，可重用的API。我们不仅需要满足直接项目推动投资的需求，而且还要满足我们看不到的所有其他<br>项目的需求。然而，可以看出，我们路线图的狭窄，以项目为导向的成功标准滋生了张力，其最大目标是最大化平台服务效用。考虑到这些限制，我们如何防止在<br>服务设计中做出会限制我们未来业务敏捷性的狭窄近视决策？</p>
<h2 id="识别您的业务能力"><a href="#识别您的业务能力" class="headerlink" title="识别您的业务能力"></a>识别您的业务能力</h2><p>问题空间的定义对解决问题的思路有很大影响。确保您始终在构建平台功能，而只盯着如何解决明确定义组成业务的功能。这是你需要思考的。</p>
<p>业务功能代表您的业务为支持运行所需的业务流程所需的核心，可重用的构建块。通过定义业务能力分类法，您可以建立一种共享的语言，所有域都可以使用该语言来<br>描述任何给定流程中的逻辑关系。这是一个稳定的，业务驱动（而不是技术驱动）的环境，可以在其中讨论随着时间的推移保持相对一致的解决方案。<br>它还提供了企业如何看待其投资与技术如何利用它们之间的关键链接。</p>
<p>在小公司里，能力是非常有限的。在资源高度受限的情况下，你可能会构建一些让你的业务与众不同的核心服务，并利用其他服务提供商来做一些通用的事情，<br>比如消息传递、身份识别、支付等等。管理他们并不难，因为他们都是核心开发者。将它们写下来并明确定义仍然是非常有益的，但是管理它们可能由<br>一个首席架构师或一小群紧密联系的涉众来完成。很少需要正式的过程，或者一般忽略。</p>
<p>随着团队的发展，事情也会发生变化。如果你有数百个分散在多个业务部门和产品线的团队，跟踪你所拥有的并避免重复投资就会变得很困难。<br>为了解决这个问题，您需要一些模型或系统来跟踪和管理扩展组织中的 API 投资组合。这本身就是一件“事情”。</p>
<p>当我们开始在 PayPal 重建平台时，我们很清楚我们的目标是什么。我们花费了大部分时间来分解各种业务流程，以确定我们的核心业务能力。由于您永远不会<br>完全理解数千万行代码，所以它并不完美，但是遵循 8-2 规则，它为我们提供了一个很好的入门分类法，我们可以使用它来分类和管理将来要构建的 API 。<br>也许最重要的是，它给了我们一种描述最终状态边界的通用语言。我们利用这一点与领域所有者就他们正在构建的api和服务进行了建设性的、可讨论的<br>（而且基本上是一致得）对话。</p>
<p>这个简单得示例说明了我们如何定义功能并将其分配给组。这些组表示包含相关功能的高级域。注意，这是整个模型的一个非常简化的快照。</p>
<p><img src="https://res.infoq.com/articles/paypal-api-first-part2/en/resources/Picture-api.jpg"></p>
<p>总共，我们确定了七个或八个高级域中的70多种业务功能。在过去的几年中，随着业务的发展，我们对模型进行了微调，并更好地了解了我们的各种业务流程，<br>但是原始模型始终是有用得基线。</p>
<p>这种做法对你在行业中寻找其他的例子是有帮助的。在我们的案例中，我们很大程度上依赖于为银行业开发的模型，因为我们有许多相同的行业概念。特别是<br> <a href="https://bian.org/servicelandscape/">BIAN模型</a>非常有帮助。在我们的业务扩展到传统银行业务之外的地方，我们利用其他行业的能力扩充了BIAN。<br>我们还必须发明一些独特的业务。这些特例很有趣，它们典型地代表了你所做的最差异化和防御性的投资[^1]。</p>
<p>在整个过程中，我们与公司的团队一起验证我们的假设，并得到他们的支持。领域架构师是关键贡献者，不过您必须小心，不要让当前的实现架构过度影响<br>业务架构定义。请记住，业务能力边界和语言应该由客户用例和支持它们所需的流程驱动。如果你的最终结果对组织之外的人没有意义，你可能需要重新审视它，<br>努力消除内部实施和组织偏见。这是一场持续的斗争。</p>
<h2 id="向API产品观念转变"><a href="#向API产品观念转变" class="headerlink" title="向API产品观念转变"></a>向API产品观念转变</h2><p>在定义业务能力边界时，不仅应该假定以客户为中心的观点，而且在定义实际 API 时也必须这样做。业界花了一段时间才明白这一点，但事实是 API 就是产品。<br>它们是给客户使用，解决问题的，所以它们必须很容易理解，而且使用体验要足够好。你甚至可以把其中的一些卖给客户，赚到真金白银。对于工程和产品领域的<br>许多人来说，这是一种新的想法。</p>
<p>原因很容易理解。API 的产生源于工程连接系统的需要和改进组件化的愿望。它们是“如何”的一部分，而且它们在当前项目之外的效用对许多人来说并不明显–<br>尤其是产品经理。还请记住，我们的短期路线图倾向于根据相对狭窄的项目结果来定义成功。将 API 设计决策偏向于直接的项目优化而不是通用得可重用性是一种<br>很自然得倾向——这通常需要更多的工作。在执行的压力和压力下，不清楚为什么你应该关心驱动你下一份薪水的外部环境。你必须在最后期限前完成任务。</p>
<p>在冲刺中，所有决定都是战术性的。</p>
<p>在 API 优先策略中，如果您设计接口良好，着眼于通用得可重用性，那么它们将成为构建块，在其之上构建未来的业务流程和产品。你今天的投资将来会有回报的。<br>因此，挑战在于克服对项目优化决策的偏见，并采用 API 产品思维。让我们看看鼓励这样做的一些属性和行为。</p>
<h2 id="像客户一样说话"><a href="#像客户一样说话" class="headerlink" title="像客户一样说话"></a>像客户一样说话</h2><p>第一件事是从客户的角度开始谈论您的 API 。您确定的业务功能集是使用从外到内看对人有意义的语言定义的。内部概念、代码和首字母缩略词在API分类法或<br>描述它们的文档中没有位置。使用以客户为中心的语言有助于将概念性业务功能和相关api与底层物理实现解耦。它使您的 API 更容易被领域外的人理解和使用。<br>这是至关重要的。</p>
<p>第二步是认真对待 API 和资源的命名。这看起来很简单，但是在理解您的 API 投资组合时，名称是非常重要的。有时候，很容易忘记阅读和理解API的人。<br>而计算机只会按照您的要求进行操作-名称无关紧要。实际上，人是根据您提供的API词汇阅读，理解，概念化和综合解决方案。如果您选择一堆含糊或不直观的<br>资源名称，则会增加认知负担，并给开发人员客户增加生活的难度。集成的成本对于任何想要使用它们的人来说都是上升的。</p>
<h2 id="管理您的API产品组合"><a href="#管理您的API产品组合" class="headerlink" title="管理您的API产品组合"></a>管理您的API产品组合</h2><p>如果您阅读了本系列的第一篇文章，您会注意到一个称为“标准(Alignment)”的步骤。你会在这一步确定底层 API ，这一步很关键。在此，您需要考虑API将支持<br>的通用用例，并选择最好得名词和动词来表示接口的资源和动作。</p>
<p>一个最佳实践是写下API要解决的用例。如果你强迫自己写出好的客户用例，你会从中发现你想要的资源和动作(Actions)的关键词。路径(endpoint)几乎是自己<br>写的。在更广泛得 API 组合环境中验证它的位置也变得容易得多。</p>
<p>挑战在于，大多数产品经理不参与 API 设计，而大多数开发人员也不从用例的角度考虑他们的 API 。开发人员倾向于从实现的角度来考虑问题。<br>如果你让一个开发人员写一个用例，他们通常会写出这样的东西:</p>
<blockquote>
<p>我需要收集 region_2 数据插入表 legacyFoo 中，以便 oldService_B 可以返回决定。</p>
</blockquote>
<p>这对领域之外的任何人都没有意义，而且很可能导致同样晦涩的 API 。相信我，我遇到逼着更烂的。退后一步并分析导致此需求的业务流程通常会揭示一个用例，<br>类似于以下内容：</p>
<blockquote>
<p>作为消费者，我需要提供成功完成付款交易所需的所有地址信息。</p>
</blockquote>
<p>这是正常人能理解的说法。它开始指向一个称为 “地址” 的潜在资源。回到我们的模型，我们还可以推断，地址可能与身份域内的帐户功相关。<br>现在可以很容易地查看该功能中的其他 API ，以确定这是一个新的资源，还是仅仅是对现有资源的扩展(或可能重复的功能，我们可以避免一起构建)。</p>
<h2 id="得到一些过程-Get-Some-Process"><a href="#得到一些过程-Get-Some-Process" class="headerlink" title="得到一些过程(Get Some Process)"></a>得到一些过程(Get Some Process)</h2><p>当提到“过程”这个词，人们反感。这是“乐趣”和“创意”的对立面。事实上，过程的存在很大程度上是为了实现结果的可伸缩性和结果的一致性。<br>虽然希望和梦想是很好的激励因素，但您需要一些切实得东西来确保您的 API 组合以某种合理的方式发展。挑战在于如何使开发过程快速、高效，<br>以及在开发人员客户眼中增加价值。如果你成功了，你就把这个“过程”变成了开发人员寻找的资产，使他们的生活更容易。这是衡量任何有价值的、<br>长期存在的流程成功与否的关键标准。</p>
<p>在PayPal的主要做法是要求所有 API 都经过一个共同的治理步骤。我们有一个小型的、中心的、很大程度上自治的团队，作为主要的 API 投资组合管理小组。<br>它由与每个业务能力领域的主要涉众和架构师合作的技术产品经理组成。他们与每个团队合作，帮助定义他们的通用用例，推荐最好的词汇表，并最终确定他们的<br>API 名称、资源和端点。</p>
<p>刚开始，这种模式遭到了许多抵制。这只是又一个阻碍我们完成工作的官僚主义步骤。开发人员倾向于等到最后一分钟（通常是在实现几乎完成之后）才参与进来。<br>这给双方都造成了很大的痛苦。随着时间的推移，人们的态度发生了转变。由于团队已经经历过几次，他们已经开始理解使用好得文档公开易于理解的接口的价值。<br>客户问题少了，他们的工作量也少了。</p>
<p>今天，我们看到团队在软件开发生命周期的早期就参与到 API 组合调整过程中。许多人在 SDLC 早期就主动寻求建议，因为他们看到了泛型化方法是如何使接口和<br>实现更简洁的。另外，客户视角和业务架构建模会影响他们对长期实现架构的思考。这有助于他们与业务保持一致。一些团队正在经历 API 和服务的第二次或<br>第三次迭代，因为他们正在朝着更清晰、更简单的模型发展，以帮助他们更容易地为所有客户服务。最重要的是，开发人员已经开始意识到不必自己解决所有这些问题。<br>他们看到了这个过程对解决眼前问题的价值，这鼓励了他们回来。</p>
<h2 id="与您的客户交谈"><a href="#与您的客户交谈" class="headerlink" title="与您的客户交谈"></a>与您的客户交谈</h2><p>当然，获得客户反馈，了解他们的需求并验证其满意度是良好产品管理的主要行为。当将API视为产品时，您的主要客户是开发人员。</p>
<p>这不是大多数人对API的看法。同样， API 开发通常由项目目标驱动，这是衡量成功的标准。 API 是达到目的的一种手段。我们如何改变行为方式，<br>以便真正考虑开发人员实际使用您的API的经验？</p>
<p>我们在PayPal采取了一些措施来鼓励这一点：</p>
<ul>
<li>在设计审查期间，我们鼓励 API 开发人员联系他们的客户，获取有关他们的设计反馈，并与他们合作以确保其文档透彻和易于理解。</li>
<li>所有 API 合约均在著名的 Github 仓库中进行管理，鼓励每个人订阅，查看更改并提交请求请求。</li>
<li>API 门户包含指向团队松弛渠道的链接，因此客户可以轻松地获得帮助并提出问题。</li>
<li>我们会将所有拉取请求发布到 Slack ，因此 API 客户可以更轻松地关注他们感兴趣的 API ，并在情况发生变化时得到通知。</li>
<li>客户的建议，错误和问题可以通过 API 门户提交，并在包含 API 规范的同一 Github 存储库中自动进行跟踪。</li>
</ul>
<p>所有这些工具都有帮助，但归根结底，API 开发人员必须有理由关心其客户的体验。激励措施必须统一起来，并被管理层视为重要。需要某种形式的工具来衡量<br>每个 API 开发人员在满足其客户期望方面做得如何。这是我们刚刚开始探索的一个领域，我们正在寻找其他方法来增强行为，从而提高 API 客户的满意度。同样，<br>这是一种文化变革，需要时间。它不一定存在于组织的 DNA 中，您将需要尝试各种方法来构建这种思想。</p>
<h2 id="产品管理的作用"><a href="#产品管理的作用" class="headerlink" title="产品管理的作用"></a>产品管理的作用</h2><p>我们一直将 API 作为产品来讨论，但没有真正解决产品管理的角色。它很可能因组织的不同而不同。如果你有一个技术性很强的产品管理职能，<br>他们很可能会高度参与其中，并想在其中发挥主导作用。他们会从本质上了解通过领导这次对话可以带来的需要和价值。这样，API产品组合管理就变成了一个跨<br>所有领域的联合体，而产品是一个高度参与的利益相关者。如果你就是这样的人，那么你应该感到幸运。</p>
<p>如果你没有一个固有的技术产品管理团队，那么组建一个中央团队来扮演这个角色并提供跨平台的一致性可能是唯一实际的、短期的解决方案。这在很大程度上取决于<br>组织的动态、文化和成熟度级别。随着时间的推移，当您加强您的产品组的技术技能集(并调整激励措施)时，您可能还能够朝着更加分散的模型发展。<br>我们也看到一些领域有非常积极得产品经理参与其中，所以混合的方法可能也是合适的。您需要确定组织中产品经理的实际参与程度，并针对具体情况定制方法。</p>
<h2 id="逻辑与物理解耦"><a href="#逻辑与物理解耦" class="headerlink" title="逻辑与物理解耦"></a>逻辑与物理解耦</h2><p>当我们讨论 API 时，我们讨论的是服务交互应该如何行为的逻辑定义。实现API的服务是实际的、被部署和服务请求的物理工件。很容易假设它们之间的关系总是1:1。<br>你应该质疑这个假设。</p>
<p>我们发现这种关系可以是很多的。这有几个原因：</p>
<ul>
<li>在逐步使用新 API 服务取代相同契约的老服务的过程中，会有一段重叠期，其中一些接口(endpoint)由遗留服务提供服务，而另一些接口由新服务提供服务。<br>  其优点是可以在每个版本中替换遗留服务的一小部分，并且可以减轻替换大型复杂服务的风险。</li>
<li>两个 API 之间存在大量实现重叠，并且开发人员希望通过同一服务为这两个 API 提供服务，以节省时间和开发工作。</li>
<li>API的读写活动完全不平衡，架构解决方案是将读写分为单独的服务。</li>
<li>有许多糟糕的、没有长远考虑的或组织结构驱动的架构决策可能导致 1:1 比例之外的结果。基本上，糟糕的设计或日期驱动的决策有时会损害完全封装、<br>  良好绑定的服务到 API 关系的目标。</li>
</ul>
<p>一个明显的含义是，您可能应该将 API 规范维护在与实现代码不同的存储库中。这使您可以轻松地将 API 与服务的关系以及生命周期解耦。事实证明，<br>API 生命周期由您的 API 版本控制和向后兼容策略决定。服务的生命周期可能由正交的问题驱动，例如错误修复和对操作质量（如性能和可用性）的改进。<br>只要始终遵守 API 合同本身，去耦就可以使每个人独立发展。</p>
<p>解耦还强化了API约定本身就是一等公民的概念。它应该驱动实现(API优先)，而不是反过来。当维护每个工件的过程中有明确的分离时，这种角色转换更容易加强。</p>
<p>在处理过程中，控制问题很重要。在 PayPal ，我们对谁可以合并 API 存储库中的更改保持非常严格的控制。每项变更均与投资组合保持一致，<br>并根据标准进行评估以产生成熟度分数。集中团队开始完成大部分工作。随着我们的成熟，我们已经培训和委托了整个组织中的开发人员以更加联合的方式进行操作<br>（在下一篇文章中有更多介绍）。即便如此，我们仍努力避免开发人员合并自己的更改，并鼓励尽可能多得跨域协作和审查。</p>
<p>最后，人们一直在与<a href="https://en.wikipedia.org/wiki/Conway%2527s_law">康韦定律</a>斗争。</p>
<blockquote>
<p>设计系统的组织…是否被限制生产复制这些组织的通信<a href="https://en.wikipedia.org/wiki/Organizational_structure">结构</a>的设计<br>(organizations which design systems … are constrained to produce designs which are copies of the communication<br>structures of these organizations)</p>
<p>– 康威</p>
</blockquote>
<p>开发人员在团队中找到价值。在重组后，团队喜欢做的第一件事就是创建一个以其团队命名的新服务——slicedbreadserv。该项目代表了他们未来的<br>工作以及对组织的贡献。稳定、长期有效的 API 是我们的目标。就像任何产品一样，删除的代价很高。比较，重组经常发生，并且通常是由非常不同的力量驱动的。<br>将 API 平台产品的定义与底层实现更改的想法分离开来是好的。你可以试着控制其中一个。另一个你肯定不能。</p>
<h2 id="This-is-a-Lifestyle"><a href="#This-is-a-Lifestyle" class="headerlink" title="This is a Lifestyle"></a>This is a Lifestyle</h2><p>我们在开发 API 组合管理学科的过程中，学到了很多东西。将思维和行为转变为更以客户为中心、API产品驱动的方法是可行的。有时这很痛苦，<br>出力不讨好，困难重重，但通过倾听和接受双方开发人员的需求，我们设法不断完善程序并提高内部客户满意度。</p>
<p>有一句经常被重复的谚语:开发人员是懒惰的。我们不相信。当有有趣的问题需要解决时，开发人员会努力工作。他们渴望知识和技能，使他们能够更快、<br>更优雅地解决问题。最重要的是，他们不想把同一个问题解决两次。</p>
<p>API产品的承诺之一，设计第一的系统设计方法是你可以同时为更多得人解决同样的问题。它令人着迷且优雅。理解需要时间，但一旦理解，就会产生强大的力量。<br>我们实现的方法和过程帮助我们引导组织沿着这条道路前进。你永远不会真正达到目标，但是从文化变化的角度而不是从项目的角度来处理问题，影响深远的。</p>
<p>在最后一篇文章中，我们将探讨计划管理对调整组织，推销概念，提供培训以及创建各种鼓励采用的激励机制的重要性。</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>Erik Hogan近二十年来一直在学习成为一名出色的产品经理意味着什么。大部分时间都花在了了解如何成为可以扩展的客户拥护者和可信赖的领导者上。<br>他非常满意，可以将复杂得问题分解为可重复使用的部分，并为工程提供准确执行快速执行所需的功能。最近，他一直在使用简单性，<br>讲故事和专注等基本产品概念来影响组织变革，这是一种非常不同的“产品”。同样，当他的妻子要求她的成功标准时，他仍然生气。</p>
<p>[^1]: 大概想表达一种独属于你的特色， 也是你区别其他同行产品的竞争力。<br>[^2]: 直译是在这一步，你可以确定 API 在更广泛的功能组合中所处的位置。</p>
]]></content>
      <tags>
        <tag>api-design</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM 使用</title>
    <url>/2017/02/14/operations/LVM%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文主要介绍 LVM 的概念和基本使用。环境在 Centos 7　系统上做演示，旨在记录 LVM 基本概念，和常用操作命令，方便以后回忆。</p>
<span id="more"></span>

<blockquote>
<p>LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制，它由Heinz Mauelshagen在Linux 2.4内核上实现，目前最新版本为：稳定版1.0.5，开发版 1.1.0-rc2，以及LVM2开发版。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和 分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组 （volumegroup），形成一个存储池。 管理员可以在卷组上随意创建逻辑卷组 （logical volumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配，例如按照使用用途进行定义：“development”和“sales”，而不是使用物理磁盘名“sda”和“sdb”。而且当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的 文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可。</p>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="物理存储介质（Physical-StorageMedia）"><a href="#物理存储介质（Physical-StorageMedia）" class="headerlink" title="物理存储介质（Physical StorageMedia）"></a>物理存储介质（Physical StorageMedia）</h3><p>指系统的物理存储设备：磁盘、分区，如：/dev/hda、/dev/sda等，是存储系统最底层的存储单元。</p>
<h3 id="PV：物理卷（Physical-Volume）"><a href="#PV：物理卷（Physical-Volume）" class="headerlink" title="PV：物理卷（Physical Volume）"></a>PV：物理卷（Physical Volume）</h3><p>指磁盘分区或从逻辑上与磁盘分区具有同样功能的设备（如RAID），是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。</p>
<h3 id="VG：卷组（Volume-Group，）"><a href="#VG：卷组（Volume-Group，）" class="headerlink" title="VG：卷组（Volume Group，）"></a>VG：卷组（Volume Group，）</h3><p>类似于非LVM系统中的物理磁盘，其由一个或多个物理卷PV组成。可以在卷组上创建一个或多个LV（逻辑卷）。</p>
<h3 id="LV：逻辑卷（Logical-Volume）"><a href="#LV：逻辑卷（Logical-Volume）" class="headerlink" title="LV：逻辑卷（Logical Volume）"></a>LV：逻辑卷（Logical Volume）</h3><p>类似于非LVM系统中的磁盘分区，逻辑卷建立在卷组VG之上。在逻辑卷LV之上可以建立文件系统（比如/home或者/usr等）。</p>
<h3 id="PE：物理块（Physical-Extent）"><a href="#PE：物理块（Physical-Extent）" class="headerlink" title="PE：物理块（Physical Extent）"></a>PE：物理块（Physical Extent）</h3><p>每一个物理卷PV被划分为称为PE（Physical Extents）的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。所以物理卷（PV）由大小等同的基本单元PE组成。</p>
<h3 id="LE：逻辑块（Logical-Extent）"><a href="#LE：逻辑块（Logical-Extent）" class="headerlink" title="LE：逻辑块（Logical Extent）"></a>LE：逻辑块（Logical Extent）</h3><p>逻辑卷LV也被划分为可被寻址的基本单位，称为LE。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。</p>
<blockquote>
<p>系统启动LVM时激活VG，并将VGDA加载至内存，来识别LV的实际物理存储位置。当系统进行I/O操作时，就会根据VGDA建立的映射机制来访问实际的物理位置。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>本次使用 Centos 7 操作系统，
[root@localhost ~]# uname -a 
Linux localhost.localdomain 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
<p>首先确定系统中是否安装了lvm工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep lvm </span><br><span class="line">mesa-private-llvm-3.6.2-2.el7.x86_64</span><br><span class="line">lvm2-2.02.130-5.el7.x86_64</span><br><span class="line">lvm2-libs-2.02.130-5.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>如果命令结果输入类似于上例，那么说明系统已经安装了LVM管理工具；如果命令没有输出则说明没有安装LVM管理工具，则需要从网络下载或者从光盘装LVM rpm工具包。</p>
<h2 id="创建管理"><a href="#创建管理" class="headerlink" title="创建管理"></a>创建管理</h2><h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><p>使用分区工具（如：fdisk等）创建分区，如果不创建分区也可以直接使用整个磁盘。</p>
<p><strong>查看磁盘</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdc：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：85.9 GB, 85899345920 字节，167772160 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x0005e789</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sda2         1026048   167772159    83373056   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdd：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">磁盘 /dev/mapper/centos-root：81.1 GB, 81075896320 字节，158351360 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">磁盘 /dev/mapper/centos-swap：4294 MB, 4294967296 字节，8388608 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br></pre></td></tr></table></figure>

<p><strong>创建分区</strong> 使用 /dev/sdb 磁盘创建一个 2G 的分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk /dev/sdb          #使用 fdisk 分区工具对 sdb 分区</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0x2285b981 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m          # 显示菜单</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition          # 删除一个分区</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu          # 显示菜单</span><br><span class="line">   n   add a new partition          # 创建一个新的分区</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table          # 显示分区列表</span><br><span class="line">   q   quit without saving changes          # 不保存退出</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&#x27;s system id          # 更改分区类型</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit          # 写入磁盘信息并退出</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n          # 新建一个分区</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):          # 回车使用默认，创建主分区</span><br><span class="line">Using default response p</span><br><span class="line">分区号 (1-4，默认 1)：          # 回车使用默认，创建分区号为1</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：           # 回车使用默认起始扇区</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：+2G       # 创建大小为 2G</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 2 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p          # 显示分区列表</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x2285b981</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048     4196351     2097152   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n          # 创建一个分区大小为 1G 的主分区</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): </span><br><span class="line">Using default response p</span><br><span class="line">分区号 (2-4，默认 2)：</span><br><span class="line">起始 扇区 (4196352-10485759，默认为 4196352)：</span><br><span class="line">将使用默认值 4196352</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (4196352-10485759，默认为 10485759)：+1G</span><br><span class="line">分区 2 已设置为 Linux 类型，大小设为 1 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n          创建分区，使用磁盘剩余空间作为此分区大小</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): </span><br><span class="line">Using default response p</span><br><span class="line">分区号 (3,4，默认 3)：</span><br><span class="line">起始 扇区 (6293504-10485759，默认为 6293504)：</span><br><span class="line">将使用默认值 6293504</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (6293504-10485759，默认为 10485759)：        # 不填写数值，默认使用剩余空间</span><br><span class="line">将使用默认值 10485759</span><br><span class="line">分区 3 已设置为 Linux 类型，大小设为 2 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x2285b981</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048     4196351     2097152   83  Linux</span><br><span class="line">/dev/sdb2         4196352     6293503     1048576   83  Linux</span><br><span class="line">/dev/sdb3         6293504    10485759     2096128   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">正在同步磁盘。</span><br></pre></td></tr></table></figure>

<h3 id="创建物理卷"><a href="#创建物理卷" class="headerlink" title="创建物理卷"></a>创建物理卷</h3><p>创建物理卷的命令为 pvcreate，利用该命令将希望添加到卷组的所有 <strong>分区</strong> 或者 <strong>磁盘</strong> 创建为物理卷。将整个磁盘创建为物理卷的命令为：</p>
<p>将 <strong>分区</strong> 创建为物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate /dev/sdb1           # 使用sdb1 分区创建物理卷</span><br><span class="line">  Physical volume &quot;/dev/sdb1&quot; successfully created</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb2</span><br><span class="line">  Physical volume &quot;/dev/sdb2&quot; successfully created</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb3</span><br><span class="line">  Physical volume &quot;/dev/sdb3&quot; successfully created</span><br></pre></td></tr></table></figure>

<p>将 <strong>磁盘</strong>创建为物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate /dev/sdc          # 使用 sdc 磁盘创建物理卷</span><br><span class="line">  Physical volume &quot;/dev/sdc&quot; successfully created</span><br></pre></td></tr></table></figure>

<h3 id="查看物理卷"><a href="#查看物理卷" class="headerlink" title="查看物理卷"></a>查看物理卷</h3><p>查看物理卷的命令是 pvdisplay，可以查看当前系统的物理卷详情。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvdisplay</span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sda2</span><br><span class="line">  VG Name               centos</span><br><span class="line">  PV Size               79.51 GiB / not usable 3.00 MiB</span><br><span class="line">  Allocatable           yes (but full)</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              20354</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          20354</span><br><span class="line">  PV UUID               Gv6gjF-lcaF-1KOP-mJK1-ejyA-80fc-FUuf0f</span><br><span class="line">   </span><br><span class="line">  &quot;/dev/sdc&quot; is a new physical volume of &quot;5.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdc</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               5.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               8x7NNq-FK15-1GLo-UeyK-6nIl-fLr2-FAs2ZH</span><br><span class="line">   </span><br><span class="line">  &quot;/dev/sdb2&quot; is a new physical volume of &quot;1.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdb2</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               1.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               XA4A2B-W52C-7EoE-lsuv-5KxJ-dLdJ-QGPv1H</span><br><span class="line">   </span><br><span class="line">  &quot;/dev/sdb3&quot; is a new physical volume of &quot;2.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdb3</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               2.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               9DKGiX-RdYb-re1b-P7dq-ZtkX-OGHe-0sqeB8</span><br><span class="line">   </span><br><span class="line">  &quot;/dev/sdb1&quot; is a new physical volume of &quot;2.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdb1</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               2.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               6ep0dc-VUtR-SdJ8-ZzG6-n1n4-ndkO-ufPXZy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面 sda2 是我系统的物理卷，后面为我们前面创建的。</p>
</blockquote>
<h3 id="创建卷组"><a href="#创建卷组" class="headerlink" title="创建卷组"></a>创建卷组</h3><p>创建卷组的命令为vgcreate，将使用pvcreate建立的物理卷创建为一个完整的卷组：</p>
<pre><code>vgcreate VolumeGroupName PhysicalDevicePath [PhysicalDevicePath...]
</code></pre>
<p>vgcreate命令第一个参数是指定该卷组的逻辑名：web_document。后面参数是指定希望添加到该卷组的所有分区和磁盘。vgcreate 在创建卷组web_document以外，还设置使用大小为4MB的PE（默认为4MB），这表示卷组上创建的所有逻辑卷都以4MB为增量单位来进行扩充 或缩减。由于内核原因，PE大小决定了逻辑卷的最大大小，4MB的PE决定了单个逻辑卷最大容量为256GB，若希望使用大于256G的逻辑卷则创建卷组 时指定更大的PE。PE大小范围为8KB到512MB，并且必须总是2的倍数（使用-s指定，具体请参考manvgcreate）。（centos 6.2系统已发现没有这种限制）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate test_volume /dev/sdb1 /dev/sdc         # 后面指定添加的物理卷</span><br><span class="line">  Volume group &quot;test_volume&quot; successfully created</span><br></pre></td></tr></table></figure>

<h3 id="查看卷组"><a href="#查看卷组" class="headerlink" title="查看卷组"></a>查看卷组</h3><p>查看卷组的命令为 vgdisplay，可以查看某个卷组的详细信息。</p>
<p>因为前面分区 sdb1 大小为 2G，所以创建的物理卷 sdb1 大小为 2G 。sdc 磁盘为5G。 上面把它们分给 test_volume 卷组。所以此时卷组的剩余空间为 2G，即有 2G 空间可以再分配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay           # 不指定参数时，会查看所有卷组</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_volume</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               6.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              1790</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       1790 / 6.99 GiB</span><br><span class="line">  VG UUID               jzKmzc-IJbU-cQR8-clm3-dWIC-Nvzb-pdCFPf</span><br><span class="line">   </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               79.51 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              20354</span><br><span class="line">  Alloc PE / Size       20354 / 79.51 GiB</span><br><span class="line">  Free  PE / Size       0 / 0   </span><br><span class="line">  VG UUID               Abfqd4-N3hG-BJR1-2j2a-VYFQ-cRXI-OtmJmR</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vgdisplay test_volume          # 指定查看某个卷组</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_volume</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               6.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              1790</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       1790 / 6.99 GiB          # 剩余空间为 7G</span><br><span class="line">  VG UUID               M54Oct-igCs-FOwl-kI0S-Bf4f-sXOi-nIw5Yw</span><br></pre></td></tr></table></figure>

<h3 id="激活卷组"><a href="#激活卷组" class="headerlink" title="激活卷组"></a>激活卷组</h3><p>为了立即使用卷组而不是重新启动系统，可以使用vgchange来激活卷组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgchange -ay test_volume </span><br><span class="line">  0 logical volume(s) in volume group &quot;test_volume&quot; now active</span><br></pre></td></tr></table></figure>

<h3 id="扩展卷组"><a href="#扩展卷组" class="headerlink" title="扩展卷组"></a>扩展卷组</h3><p>当系统安装了新的磁盘并创建了新的物理卷，而要将其添加到已有卷组时，就需要使用vgextend 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate /dev/sdd</span><br><span class="line">  Physical volume &quot;/dev/sdd&quot; successfully created</span><br><span class="line">[root@localhost ~]# vgextend test_volume /dev/sdd</span><br><span class="line">  Volume group &quot;test_volume&quot; successfully extended</span><br><span class="line">[root@localhost ~]# vgdisplay test_volume        </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_volume</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        3</span><br><span class="line">  Metadata Sequence No  2</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                3</span><br><span class="line">  Act PV                3</span><br><span class="line">  VG Size               11.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              3069</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       3069 / 11.99 GiB          # 7G + 5G </span><br><span class="line">  VG UUID               M54Oct-igCs-FOwl-kI0S-Bf4f-sXOi-nIw5Yw</span><br></pre></td></tr></table></figure>

<h3 id="减小卷组"><a href="#减小卷组" class="headerlink" title="减小卷组"></a>减小卷组</h3><p>要从一个卷组中删除一个物理卷，首先要确认要删除的物理卷没有被任何逻辑卷正在使用，就要使用pvdisplay命令察看一个该物理卷信息：<br>如果某个物理卷正在被逻辑卷所使用，就需要将该物理卷的数据备份到其他地方，然后再删除。删除物理卷的命令为vgreduce：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgreduce test_volume /dev/sdc</span><br><span class="line">  Removed &quot;/dev/sdc&quot; from volume group &quot;test_volume&quot;</span><br><span class="line">[root@localhost ~]# vgdisplay test_volume        </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_volume</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               6.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              1790</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       1790 / 6.99 GiB</span><br><span class="line">  VG UUID               M54Oct-igCs-FOwl-kI0S-Bf4f-sXOi-nIw5Yw</span><br></pre></td></tr></table></figure>

<h3 id="删除卷组"><a href="#删除卷组" class="headerlink" title="删除卷组"></a>删除卷组</h3><p>当不再使用某个卷组，可以删除它。删除前，请务必备份好资料！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgremove test_volume </span><br><span class="line">  Volume group &quot;test_volume&quot; successfully removed</span><br><span class="line">[root@localhost ~]# vgdisplay           # 查看所有卷组， test_volume 消失</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               79.51 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              20354</span><br><span class="line">  Alloc PE / Size       20354 / 79.51 GiB</span><br><span class="line">  Free  PE / Size       0 / 0   </span><br><span class="line">  VG UUID               Abfqd4-N3hG-BJR1-2j2a-VYFQ-cRXI-OtmJmR</span><br></pre></td></tr></table></figure>

<h3 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h3><p>使用 lvcreate 创建逻辑卷。该命令就在卷组 test_volume 上创建名字为 testLV，大小为 3G 的逻辑卷，并且设备入口为 /dev/test_volume/testLV （test_volume 为卷组名， testLV 为逻辑卷名）。 创建之前，请先查看卷组的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate -L 3G -n testLV test_volume </span><br><span class="line">  Logical volume &quot;testLV&quot; created.</span><br></pre></td></tr></table></figure>

<h3 id="查看逻辑卷"><a href="#查看逻辑卷" class="headerlink" title="查看逻辑卷"></a>查看逻辑卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay /dev/test_volume/testLV     # 不加参数查看全部逻辑卷</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/test_volume/testLV</span><br><span class="line">  LV Name                testLV</span><br><span class="line">  VG Name                test_volume</span><br><span class="line">  LV UUID                dmtbfb-XxQK-WnL1-K5BB-FdWA-FZ1z-aeexLn</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost.localdomain, 2017-02-11 22:00:00 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                3.00 GiB</span><br><span class="line">  Current LE             768</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:2</span><br></pre></td></tr></table></figure>

<h3 id="创建文件系统，并使用"><a href="#创建文件系统，并使用" class="headerlink" title="创建文件系统，并使用"></a>创建文件系统，并使用</h3><p><strong>创建文件系统</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs.ext4 /dev/test_volume/testLV    </span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">文件系统标签=</span><br><span class="line">OS type: Linux</span><br><span class="line">块大小=4096 (log=2)</span><br><span class="line">分块大小=4096 (log=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">196608 inodes, 786432 blocks</span><br><span class="line">39321 blocks (5.00%) reserved for the super user</span><br><span class="line">第一个数据块=0</span><br><span class="line">Maximum filesystem blocks=805306368</span><br><span class="line">24 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">        32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成                            </span><br><span class="line">正在写入inode表: 完成                            </span><br><span class="line">Creating journal (16384 blocks): 完成</span><br><span class="line">Writing superblocks and filesystem accounting information: 完成 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>挂载到目录</strong></p>
<blockquote>
<p><em>注意：</em> 挂载到目录之前，请备份好目录内的文件！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount /dev/test_volume/testLV /home/MyVolume/</span><br></pre></td></tr></table></figure>

<p><strong>配置开机自动挂载文件系统</strong></p>
<p>编辑 /etc/fstab 文件，追加文件系统信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/fstab </span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># /etc/fstab</span><br><span class="line"># Created by anaconda on Fri Feb 10 16:38:19 2017</span><br><span class="line">#</span><br><span class="line"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span><br><span class="line"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><br><span class="line">#</span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=5725d92e-05b1-4f52-bc62-4de75b503be0 /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line">/dev/test_volume/testLV         /home/MyVolume/ ext4    default         1 2</span><br></pre></td></tr></table></figure>

<h3 id="删除一个逻辑卷"><a href="#删除一个逻辑卷" class="headerlink" title="删除一个逻辑卷"></a>删除一个逻辑卷</h3><p>删除逻辑卷之前需要将其卸载后才能删除。请备份文件系统内文件！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# umount /home/MyVolume/</span><br><span class="line">[root@localhost ~]# lvremove /dev/test_volume/testLV </span><br><span class="line">Do you really want to remove active logical volume testLV? [y/n]: y</span><br><span class="line">  Logical volume &quot;testLV&quot; successfully removed</span><br></pre></td></tr></table></figure>

<h3 id="扩展逻辑卷"><a href="#扩展逻辑卷" class="headerlink" title="扩展逻辑卷"></a>扩展逻辑卷</h3><p>LVM提供了方便调整逻辑卷大小的能力，扩展逻辑卷大小的命令是lvextend。扩展之前请先查看卷组可用空间大小。如果可用空间不足，可用使用新的磁盘创建物理卷后添加至卷组。</p>
<p><strong>查看卷组大小</strong>   可用空间为 3G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay test_volume </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_volume</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  6</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               6.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              1790</span><br><span class="line">  Alloc PE / Size       768 / 3.00 GiB</span><br><span class="line">  Free  PE / Size       1022 / 3.99 GiB          # 可用空间为 3G </span><br><span class="line">  VG UUID               WDFqaI-Qopl-fDJM-eeMl-3U20-aCpc-umR44I</span><br></pre></td></tr></table></figure>

<p><strong>扩展卷组</strong>   扩展后可用为 6G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgextend test_volume /dev/sdb3</span><br><span class="line">  Volume group &quot;test_volume&quot; successfully extended</span><br><span class="line">[root@localhost ~]# vgdisplay test_volume         </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_volume</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        3</span><br><span class="line">  Metadata Sequence No  7</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                3</span><br><span class="line">  Act PV                3</span><br><span class="line">  VG Size               8.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              2301</span><br><span class="line">  Alloc PE / Size       768 / 3.00 GiB</span><br><span class="line">  Free  PE / Size       1533 / 5.99 GiB          # 可用空间为 6G</span><br><span class="line">  VG UUID               WDFqaI-Qopl-fDJM-eeMl-3U20-aCpc-umR44I</span><br></pre></td></tr></table></figure>

<p><strong>查看当前逻辑卷</strong>  逻辑卷大小为 3G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay /dev/test_volume/testLV </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/test_volume/testLV</span><br><span class="line">  LV Name                testLV</span><br><span class="line">  VG Name                test_volume</span><br><span class="line">  LV UUID                k3WITF-SIK1-MVhz-MdNr-exdX-5qIm-2d2IOr</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost.localdomain, 2017-02-11 22:17:13 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                3.00 GiB</span><br><span class="line">  Current LE             768</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:2</span><br></pre></td></tr></table></figure>

<p><strong>扩展逻辑卷</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvextend -L 6G /dev/test_volume/testLV </span><br><span class="line">  Size of logical volume test_volume/testLV changed from 3.00 GiB (768 extents) to 6.00 GiB (1536 extents).</span><br><span class="line">  Logical volume testLV successfully resized.</span><br></pre></td></tr></table></figure>

<p><strong>查看扩展后的逻辑卷</strong>  逻辑卷大小为 6G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay /dev/test_volume/testLV </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/test_volume/testLV</span><br><span class="line">  LV Name                testLV</span><br><span class="line">  VG Name                test_volume</span><br><span class="line">  LV UUID                k3WITF-SIK1-MVhz-MdNr-exdX-5qIm-2d2IOr</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost.localdomain, 2017-02-11 22:17:13 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                6.00 GiB</span><br><span class="line">  Current LE             1536</span><br><span class="line">  Segments               2</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:2</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当向已经格式化文件系统的卷组中扩展物理卷的时候，请在创建物理卷之前将磁盘或分区格式化相应的系统。比如当我们想要向系统根目录扩展空间，因为 Centos 系统安装为 ext4 文件系统。所有需要将分区格式化为 ext4 后再扩展！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LVM具有很好的可伸缩性，使用起来非常方便。可以方便地对卷组、逻辑卷的大小进行调整，更进一步调整文件系统的大小。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>lvm</tag>
      </tags>
  </entry>
  <entry>
    <title>连接 Kerberos 集群指南</title>
    <url>/2019/05/06/operations/%E8%BF%9E%E6%8E%A5%20Kerberos%20%E9%9B%86%E7%BE%A4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>本文主要介绍客户端在使用 Kerberos 的时候如何连接 Kerberos 集群，使用 Kerberos 安全认证。其中包含 Windows 客户端， Linux 客户端安装使用记录。</p>
<span id="more"></span>

<h2 id="Kerberos-介绍"><a href="#Kerberos-介绍" class="headerlink" title="Kerberos 介绍"></a>Kerberos 介绍</h2><p>Kerberos 简介</p>
<p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=9213b35de9f81a4c2632ebcfef110764/a5c27d1ed21b0ef485f59977dfc451da81cb3efd.jpg" alt="kerberos_pic"></p>
<p><strong>Kerberos</strong>是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。这个词又指<a href="https://baike.baidu.com/item/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2">麻省理工学院</a>为这个协议开发的一套计算机软件。</p>
<p>先来看看Kerberos协议的前提条件：</p>
<p>如下图所示，Client与KDC， KDC与Service 在协议工作前已经有了各自的共享密钥，并且由于协议中的消息无法穿透防火墙，这些条件就限制了Kerberos协议往往用于一个组织的内部。</p>
<p><img src="http://qiniu.iclouds.work/Fmaqh-qBfq-rXFuXcSUNxplf9Ibu.png" alt="kerberos"></p>
<p><strong>过程</strong></p>
<p>Kerberos协议分为两个部分：</p>
<ol>
<li><p>Client向KDC发送自己的身份信息，KDC从Ticket Granting Service得到TGT(ticket-granting ticket)， 并用协议开始前Client与KDC之间的密钥将TGT加密回复给Client。</p>
<p>此时只有真正的Client才能利用它与KDC之间的密钥将加密后的TGT解密，从而获得TGT。</p>
<p>（此过程避免了Client直接向KDC发送密码，以求通过验证的不安全方式）</p>
</li>
<li><p>Client利用之前获得的TGT向KDC请求其他Service的Ticket，从而通过其他Service的身份鉴别。</p>
<p>Kerberos协议的重点在于第二部分，简介如下：</p>
<p><img src="http://qiniu.iclouds.work/Fkxqfdj7TUx0InXKX3w6QkbNawBp.png" alt="kerberos"></p>
<ul>
<li>Client将之前获得TGT和要请求的服务信息(服务名等)发送给KDC，KDC中的Ticket Granting Service将为Client和Service之间生成一个Session Key用于Service对Client的身份鉴别。然后KDC将这个Session Key和用户名，用户地址（IP），服务名，有效期, 时间戳一起包装成一个Ticket(这些信息最终用于Service对Client的身份鉴别)发送给Service， 不过Kerberos协议并没有直接将Ticket发送给Service，而是通过Client转发给Service.所以有了第二步。</li>
<li>此时KDC将刚才的Ticket转发给Client。由于这个Ticket是要给Service的，不能让Client看到，所以KDC用协议开始前KDC与Service之间的密钥将Ticket加密后再发送给Client。同时为了让Client和Service之间共享那个秘密(KDC在第一步为它们创建的Session Key)， KDC用Client与它之间的密钥将Session Key加密随加密的Ticket一起返回给Client。</li>
<li>为了完成Ticket的传递，Client将刚才收到的Ticket转发到Service. 由于Client不知道KDC与Service之间的密钥，所以它无法算改Ticket中的信息。同时Client将收到的Session Key解密出来，然后将自己的用户名，用户地址（IP）打包成Authenticator用Session Key加密也发送给Service。</li>
<li>Service 收到Ticket后利用它与KDC之间的密钥将Ticket中的信息解密出来，从而获得Session Key和用户名，用户地址（IP），服务名，有效期。然后再用Session Key将Authenticator解密从而获得用户名，用户地址（IP）将其与之前Ticket中解密出来的用户名，用户地址（IP）做比较从而验证Client的身份。</li>
<li>如果Service有返回结果，将其返回给Client。</li>
</ul>
</li>
</ol>
<h2 id="Kerberos-Client-配置"><a href="#Kerberos-Client-配置" class="headerlink" title="Kerberos Client 配置"></a>Kerberos Client 配置</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>准备</p>
<p>同步时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone <span class="string">&quot;Asia/Shanghai&quot;</span> <span class="comment"># 设置系统时区</span></span><br><span class="line">timedatectl set-ntp <span class="literal">true</span> <span class="comment"># 联网自动同步到 NTP 时间服务器</span></span><br></pre></td></tr></table></figure>



<p>根据 <a href="https://help.ubuntu.com/lts/serverguide/kerberos.html.en">Ubuntu 官方文档</a> <strong>Kerberos Linux Client</strong> 一节操作</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install krb5-user</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置</li>
</ol>
<p>修改 <code>/etc/krb5.conf</code> ，配置如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[libdefaults]</span><br><span class="line">  renew_lifetime = 7d</span><br><span class="line">  forwardable = true</span><br><span class="line">  default_realm = TENDATA.CN</span><br><span class="line">  ticket_lifetime = 24h</span><br><span class="line">  dns_lookup_realm = false</span><br><span class="line">  dns_lookup_kdc = false</span><br><span class="line">  default_ccache_name = /tmp/krb5cc_%&#123;uid&#125;</span><br><span class="line">  #default_tgs_enctypes = aes des3-cbc-sha1 rc4 des-cbc-md5</span><br><span class="line">  #default_tkt_enctypes = aes des3-cbc-sha1 rc4 des-cbc-md5</span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">  default = FILE:/var/log/krb5kdc.log</span><br><span class="line">  admin_server = FILE:/var/log/kadmind.log</span><br><span class="line">  kdc = FILE:/var/log/krb5kdc.log</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">  TENDATA.CN = &#123;</span><br><span class="line">    admin_server = m1.node.hadoop</span><br><span class="line">    kdc = 192.168.10.1</span><br><span class="line">    kdc = 192.168.10.2</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置域名解析</li>
</ol>
<p>修改 hosts 文件，增加如下解析记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.10.1  m1.node.hadoop</span><br><span class="line">192.168.10.2  m2.node.hadoop</span><br><span class="line">192.168.10.3  m3.node.hadoop</span><br><span class="line"></span><br><span class="line">192.168.10.10 d1.node.hadoop</span><br><span class="line">192.168.10.11 d2.node.hadoop</span><br><span class="line">192.168.10.12 d3.node.hadoop</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 Kerberos Client</li>
</ol>
<p>使用 <code>kinit</code> 获取 tgt </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kevin@ubuntu-kevin:~$ kinit whg</span><br><span class="line">Password for whg@TENDATA.CN: </span><br><span class="line"></span><br><span class="line">kevin@ubuntu-kevin:~$ klist</span><br><span class="line">Ticket cache: FILE:/tmp/krb5cc_1000</span><br><span class="line">Default principal: whg@TENDATA.CN</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2019-05-06T09:45:56  2019-05-07T09:45:55  krbtgt/TENDATA.CN@TENDATA.CN</span><br></pre></td></tr></table></figure>

<p>使用 <code>kdestroy</code> 销毁 tgt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kevin@ubuntu-kevin:~$ kdestroy </span><br><span class="line"></span><br><span class="line">kevin@ubuntu-kevin:~$ klist </span><br><span class="line">klist: No credentials cache found (filename: /tmp/krb5cc_1000)</span><br></pre></td></tr></table></figure>

<p>命令使用参数和其他命令请阅读 <a href="https://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/index.html">Kerberos 用户命令</a> </p>
<ol start="5">
<li>访问相关服务</li>
</ol>
<p>使用 <code>curl</code> 访问 Kerberos 认证的页面。</p>
<p>正常访问不会出现 <code>Error 401 Authentication required</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kevin@ubuntu-kevin:~$ curl -k --negotiate -u: -H &quot;Content-Type: application/json&quot; -X GET http://m1.node.hadoop:50070/</span><br><span class="line">&lt;!--</span><br><span class="line">   Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">   contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">   this work for additional information regarding copyright ownership.</span><br><span class="line">   The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">   (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">   the License.  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">       http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">   Unless required by applicable law or agreed to in writing, software</span><br><span class="line">   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">   See the License for the specific language governing permissions and</span><br><span class="line">   limitations under the License.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span><br><span class="line">    &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;REFRESH&quot; content=&quot;0;url=dfshealth.html&quot; /&gt;</span><br><span class="line">&lt;title&gt;Hadoop Administration&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>或者访问 <code>curl -L -k --negotiate -u: -H &quot;Content-Type: application/json&quot; -X GET http://m1.node.hadoop:50070/webhdfs/v1/?op=LISTSTATUS</code> 正常出现 HDFS 文件列表(JSON 格式数据)，没有 401 错误即代表正常访问</p>
<p><strong>Error 401 Authentication required</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Error 401 Authentication required<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>HTTP ERROR 401<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Problem accessing /webhdfs/v1/. Reason:</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>    Authentication required<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><p>准备</p>
<p>同步时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone <span class="string">&quot;Asia/Shanghai&quot;</span> <span class="comment"># 设置系统时区</span></span><br><span class="line">timedatectl set-ntp <span class="literal">true</span> <span class="comment"># 联网自动同步到 NTP 时间服务器</span></span><br></pre></td></tr></table></figure>

<ol>
<li>安装 Kerberos Client</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install krb5-workstation</span><br></pre></td></tr></table></figure>

<p>其余步骤和 Ubuntu 操作相同。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 默认已经支持 Kerberos，但需要使用 加入 Active Directory ，以获取 tgt。在使用 openladp 的情况下需要配置 AD proxy，这种方式比较麻烦。MIT 提供 <a href="https://web.mit.edu/kerberos/dist/index.html">Kerberos for Windows</a> 来更方便的使用 Kerberos 认证。</p>
<p>没有使用 Windows 默认 kerberos 支持，当有程序调用Windows 集成身份验证的时候也就会认证失败。例如 IE，Chrome 浏览器登陆 Kerberos 认证的网站时，会出现 <code>HTTP ERROR 403</code> 错误。</p>
<p>参考文章：<a href="https://www.simba.com/products/Hive/doc/ODBC_InstallGuide/win/content/odbc/hi/kerberos.htm">Configuring Kerberos Authentication for Windows</a> </p>
<p>注意：在选择 kfw 版本应该与后面安装浏览器版本一致，推荐安装 64-bit kfw，因为会向下兼容</p>
<ol>
<li>下载安装</li>
</ol>
<p><a href="https://web.mit.edu/kerberos/dist/index.html">Kerberos for Windows</a></p>
<p>安装时推荐选择 “Complete” 安装</p>
<p><img src="http://qiniu.iclouds.work/FldFbui6VkQsUeIxVUS9zBIpFXKd.png" alt="kerberos_for_windows_install"></p>
<ol start="2">
<li>配置</li>
</ol>
<p>kfw 64位 默认安装在 <code>C:\Program Files\MIT\Kerberos</code> 下，当然这不是重点。 kfw 会加载 <code>C:\ProgramData\MIT\Kerberos5\krb5.ini</code> 的配置文件。</p>
<blockquote>
<p><code>ProgramData</code> 目录默认是隐藏的。</p>
</blockquote>
<p>修改该配置文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[libdefaults]</span><br><span class="line">  renew_lifetime = 7d</span><br><span class="line">  forwardable = true</span><br><span class="line">  default_realm = TENDATA.CN</span><br><span class="line">  ticket_lifetime = 24h</span><br><span class="line">  dns_lookup_realm = false</span><br><span class="line">  dns_lookup_kdc = false</span><br><span class="line">  default_ccache_name = /tmp/krb5cc_%&#123;uid&#125;</span><br><span class="line">  #default_tgs_enctypes = aes des3-cbc-sha1 rc4 des-cbc-md5</span><br><span class="line">  #default_tkt_enctypes = aes des3-cbc-sha1 rc4 des-cbc-md5</span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">  default = FILE:/var/log/krb5kdc.log</span><br><span class="line">  admin_server = FILE:/var/log/kadmind.log</span><br><span class="line">  kdc = FILE:/var/log/krb5kdc.log</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">  TENDATA.CN = &#123;</span><br><span class="line">    admin_server = m1.node.hadoop</span><br><span class="line">    kdc = 192.168.10.1</span><br><span class="line">    kdc = 192.168.10.2</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置系统属性：</li>
</ol>
<p>打开 <code>控制面板</code> -&gt; 选择 <code>系统和安全</code> -&gt; 选择 <code>系统</code> -&gt; 选择 <code>高级系统设置</code> 打开 <code>系统属性</code> 面板 -&gt; 点击 <code>高级</code> 选项卡 -&gt; 打开环境变量</p>
<p>新建系统变量，变量名称为 <code>KRB5CCNAME</code> 变量值为 <code>C:\temp\krb5cache</code>  。前提时 <code>C:\temp\</code> 目录存在，<code>krb5cache</code> 不需要创建，在使用 <code>kinit</code> 命令的时候会自动生成该文件。</p>
<p>如果 <code>krb5.ini</code> 的配置文件不在默认目录可以使用变量名 <code>KRB5_CONFIG</code> 指定，变量值为该文件的绝对路径</p>
<ol start="4">
<li>使用</li>
</ol>
<p>在 CMD 中使用 <code>kinit</code> 获取 tgt。</p>
<p>由于 Windows 支持 Kerberos ，所有部分命令默认时 Windows 的。比如 <code>klist</code> 。</p>
<p>修改环境变量，让 kfw 命令覆盖 Windows。</p>
<p>编辑 <code>Path</code> 环境变量，将 <code>kerberos</code> 变量上移至最上面即可。</p>
<p><img src="http://qiniu.iclouds.work/Fhof90F5SjgN4s9uGD-JU9-52gdx.png" alt="up_kerberos_bin"></p>
<p>在 CMD 中使用 <code>klist</code> 即可查看以获取的 tgt</p>
<p><strong>注意：</strong></p>
<p>由于 Java 也实现了 kerberos client 认证机制，在 JDK 的 <code>bin</code> 目录提供了 <code>kinit</code> 、 <code>klist</code> 等相关命令，在配置Path 环境变量时，Kerberos 的优先级应该比 JDK 的要高。</p>
<p>**403 ** 分析：</p>
<p>在没有安装 kfw 时，系统已经具有 <code>klist</code> 命令，该命令位于 <code>C:\WINDOWS\system32</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;klist</span><br><span class="line"></span><br><span class="line">当前登录 ID 是 0:0x73218</span><br><span class="line"></span><br><span class="line">缓存的票证: (0)</span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;klist sessions</span><br><span class="line"></span><br><span class="line">当前登录 ID 是 0:0x73218</span><br><span class="line">[0] 会话 0 0:0x136dc999 DESKTOP-5KM5T43\Administrator NTLM:Network</span><br><span class="line">[1] 会话 0 0:0x134bf7a2 DESKTOP-5KM5T43\Administrator NTLM:Network</span><br></pre></td></tr></table></figure>

<p>相关命令使用前查看 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/klist">klist</a> </p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>根据 <a href="https://docs.oracle.com/javase/10/security/introduction-jaas-and-java-gss-api-tutorials1.htm#JSSEC-GUID-202DE2FD-E2CA-44D1-9391-50127913538E">Java Platform, Standard Edition Security Developer’s Guide</a> 描述，Java 为开发人员提供了 JAAS 和 Java GSS-API 来使用 Kerberos 认证。前者是直接认证，后者是使用调用底层认证。</p>
<p><strong>注意：</strong> 根据 JCE 描述，由于一些国家的进口管制限制，一些版本的 JDK 或者 JRE 允许强，但有限的加密策略。所以如果需要无限长度加密策略，需要下载 <code>Java Cryptography Extension (JCE) </code> 支持。详细描述请查看 JCE 压缩包中的 README.txt。而 Kerberos 的加密正式需要无限长度支持。下载地址为 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 8 Download</a> 。下载后解压到 <code>JAVA_HOME\jre\lib\security</code> 即可。</p>
<ol>
<li>配置</li>
</ol>
<p><a href="https://docs.oracle.com/javase/10/security/kerberos-requirements1.htm#JSSEC-GUID-EAA2758B-3071-4CDA-AEF1-D76F5271E998">Kerberos Requirements</a> 中描述了 JDK 是如何使用 Kerberos 的。它支持系统属性值，和 <code>krb5.conf</code> 配置文件读取。为了便于使用，下面仅配置使用 <code>krb5.conf</code> </p>
<p><strong>注意：</strong> 系统属性值比配置有更高的优先级！</p>
<p>JDK 查找配置文件的算法如下：</p>
<ul>
<li><p>系统属性 ``java.security.krb5.conf` 指定文件位置</p>
</li>
<li><p>查找配置文件位置 (java-home 为 JDK 安装目录)</p>
<ul>
<li><code>&lt;java-home&gt;\conf\security</code> (Windows) </li>
<li><code>&lt;java-home&gt;/conf/security</code>  (Solaris, Linux, and macOS)</li>
</ul>
</li>
<li><p>如果上述没有找到，则查找如下位置：</p>
<ul>
<li><p><code>/etc/krb5/krb5.conf</code> (Solaris)</p>
</li>
<li><p><code>C:\Windows\krb5.ini</code> (Windows)</p>
</li>
<li><p><code>/etc/krb5.conf</code> (Linux)</p>
</li>
<li><p><code>~/Library/Preferences/edu.mit.Kerberos</code>, <code>/Library/Preferences/edu.mit.Kerberos</code>, or <code>/etc/krb5.conf</code> (macOS)</p>
</li>
</ul>
</li>
</ul>
<p>所以，在 Windows 中，应该把 <code>krb5.conf</code> 更名为 <code>krb5.ini</code> 放在 <code>C:\Windows\krb5.ini</code> 。</p>
<ol start="2">
<li>验证</li>
</ol>
<p>在 CMD 下，进入到 <code>JAVA_HOME\bin\</code> 中，执行 <code>kinit</code> 和 <code>klist</code> 。关于命令的具体使用，请查看 <a href="https://docs.oracle.com/javase/10/tools/security-tools-and-commands.htm#JSWOR691">Security Tools and Commands</a></p>
<h2 id="浏览器访问-Kerberos-服务"><a href="#浏览器访问-Kerberos-服务" class="headerlink" title="浏览器访问 Kerberos 服务"></a>浏览器访问 Kerberos 服务</h2><p>参考文章 <a href="https://ping.force.com/Support/PingFederate/Integrations/How-to-configure-supported-browsers-for-Kerberos-NTLM">How to configure supported browsers for Kerberos and NTLM</a> </p>
<p>PingFederate Integrated Windows Authentication (IWA)适配器支持Kerberos和NTLM身份验证协议，但是需要配置一些浏览器来使用它们。</p>
<p>对于Kerberos和NTLM身份验证，PingFederate IWA适配器使用SPNEGO(Simple and Protected GSS-API Negotiation)机制协商Kerberos或NTLM作为底层身份验证协议。下面的每个浏览器都支持SPNEGO，但是由于浏览器和操作系统的结合，存在的差异可能会影响在每个实例中协商的协议。</p>
<p>The PingFederate IWA Adapter supports the following browsers:</p>
<ul>
<li>Internet Explorer</li>
<li>Mozilla Firefox</li>
<li>Google Chrome</li>
<li>Apple Safari</li>
</ul>
<h3 id="Internet-Explorer"><a href="#Internet-Explorer" class="headerlink" title="Internet Explorer"></a>Internet Explorer</h3><p>鉴于 Windows 原因，不进行配置。</p>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><blockquote>
<p>当前 Firefox 版本 64.0.2(64-bit) </p>
</blockquote>
<p>参考 <a href="http://people.redhat.com/mikeb/negotiate/">Configuring Firefox for Negotiate Authentication</a> 、 [Integrated Authentication](&lt;<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Integrated_authentication">https://developer.mozilla.org/en-US/docs/Mozilla/Integrated_authentication</a>) </p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ol>
<li>在地址栏中键入about:config，点击 <code>I accept the risk !</code> ，进入配置页面</li>
</ol>
<p><img src="http://qiniu.iclouds.work/FtiywmQmIg8ILbI9UX6kr9VWZePz.png" alt="firefox_config"></p>
<ol start="2">
<li>配置 SPNEGO authentication</li>
</ol>
<p>配置 <code>network.negotiate-auth.trusted-uris</code> 为允许使用浏览器进行SPNEGO身份验证的站点， 支持统配。多个站点使用逗号隔开。</p>
<p><img src="http://qiniu.iclouds.work/FukOO6s6wCNDX5vE-BuJwWmTcQvF.png" alt="forefox_config_negotiate"></p>
<p>然后使用 <code>kinit</code> 获取认证 tgt 之后，打开 Chrome 访问服务页面。没有出现 401 即为正常。</p>
<h4 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h4><p>注意：Firefox 浏览器版本应与前面安装的 kfw 版本一致，否则会出现 401 。如果 kfw 为 64bit 则不用关注这一点。</p>
<p>和 Linux 相同，修改 Firefox 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network.negotiate-auth.trusted-uris</span><br><span class="line">network.auth.use-sspi</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>kinit</code> 获取认证 tgt 之后，打开 Chrome 访问服务页面。没有出现 401 即为正常。</p>
<h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><h4 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h4><p>根据 [Chrome HTTP authentication(<a href="https://www.chromium.org/developers/design-documents/http-authentication">https://www.chromium.org/developers/design-documents/http-authentication</a>) 中 <strong>Integrated Authentication</strong> 描述 Chrome 是支持 Kerberos 和 NTLM 认证的。默认不会启用，只有从代理接收身份验证协商或者在白名单的服务器协商时，才会启用继承身份验证。</p>
<h5 id="Chrome-策略组启用白名单"><a href="#Chrome-策略组启用白名单" class="headerlink" title="Chrome 策略组启用白名单"></a>Chrome 策略组启用白名单</h5><p>添加白名单可以通过 <a href="https://dev.chromium.org/administrators/policy-list-3#AuthServerWhitelist">AuthServerWhitelist</a> 策略设置。多个白名单用以逗号分隔。</p>
<p>参考：<a href="https://dev.chromium.org/administrators/linux-quick-start">Linux Quick Start</a> </p>
<p>对于Chromium，策略配置文件位于/etc/chromium之下，对于谷歌Chrome，策略配置文件位于/etc/opt/chrome之下。在这些目录中保存着两组策略:一组是管理员需要并强制执行的，另一组是推荐给用户但不是必需的。这两组在:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/opt/chrome/policies/managed/</span><br><span class="line">/etc/opt/chrome/policies/recommended/</span><br></pre></td></tr></table></figure>

<p>如果这些目录不存在，请创建它们:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mkdir /etc/opt/chrome/policies</span><br><span class="line">&gt;mkdir /etc/opt/chrome/policies/managed</span><br><span class="line">&gt;mkdir /etc/opt/chrome/policies/recommended</span><br></pre></td></tr></table></figure>

<p>确保非管理员用户无法写入/托管下的文件;否则，他们可能只是覆盖您的策略来获得他们想要的配置!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;chmod -w /etc/opt/chrome/policies/managed</span><br></pre></td></tr></table></figure>

<p>要设置所需的策略，请在 <code>/etc/opt/chrome/policies/managed/</code> 下创建一个名为 <code>test_policy.json</code> 的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;touch /etc/opt/chrome/policies/managed/test_policy.json</span><br></pre></td></tr></table></figure>

<p>在这个文件中，放入以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">          &quot;AuthServerWhitelist&quot;: &quot;.node.hadoop&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这样!下次在该机器上启动谷歌Chrome时，主页将被锁定到这个值。</p>
<p>在地址栏输入 <code>chrome:policy</code> 查看当前策略</p>
<p><img src="http://qiniu.iclouds.work/FhCrKMifE6Nj6ZlQGMqlcRtVKZ1C.png" alt="chrome_policy"></p>
<p>在使用 <code>kinit</code> 获取认证 tgt 之后，打开 Chrome 访问服务页面。没有出现 401 即为正常。</p>
<h5 id="使用命令行参数启动"><a href="#使用命令行参数启动" class="headerlink" title="使用命令行参数启动"></a>使用命令行参数启动</h5><p>根据 <a href="https://www.chromium.org/developers/how-tos/run-chromium-with-flags">Run Chromium with flags</a> 中描述，Chromium(和Chrome)支持接受命令行标志(或“开关”)，以便启用特定功能或修改默认功能。</p>
<p>当前可用参数可以查看 <a href="https://peter.sh/experiments/chromium-command-line-switches/">List of Chromium Command Line Switches</a> 。可以使用 <a href="https://peter.sh/experiments/chromium-command-line-switches/#auth-server-whitelist">–auth-server-whitelist </a> 参数启用白名单功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chrome --auth-server-whitelist=<span class="string">&quot;.node.hadoop&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Windows-2"><a href="#Windows-2" class="headerlink" title="Windows"></a>Windows</h4><p>由于 Chrome 自身不带有 Gssapi，而是调用操作系统类库，而且依赖于 <code>Internet 选项</code> 配置。因此不在配置。</p>
<p>具体内容请参考 <a href="https://www.chromium.org/developers/design-documents/http-authentication">Chrome HTTP authentication</a> 中 <code>Negotiate external libraries</code> 部分</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Kerberos</tag>
      </tags>
  </entry>
  <entry>
    <title>Ambari 整合 Kerberos + Openldap</title>
    <url>/2017/11/20/operations/Ambari%20%E6%95%B4%E5%90%88%20Kerberos%20+%20Openldap/</url>
    <content><![CDATA[<p>本文是在学习 Ambari 集成 Kerberos 做安全认证，同时使用 Openldap 作为 Ambari 和 Kerberos 的后端用户管理时总结的。</p>
<p>在学习的时候参照了许多国内外的安装文档，中间也出了不少问题。都是一点点找，才搞出来。</p>
<p>因为战线拉得比较长，在学习过程中，看了太多的博客，也没太仔细记录博主的连接。没能及时的在文中贴上。如果发现引用，请及时联系我。</p>
<span id="more"></span>

<p>再次感谢走过这条路的前辈们。</p>
<p>文章还有不太详细之处，后期有空会继续补充。</p>
<p>经过测试在使用openldap + Kerberos 实现集中用户认证及授权系统时，先安装 Openldap 做后端数据库，然后安装 Kerberos 使用 Openldap ，接着配置 Openldap 使用 Kerberos 安全认证。最后安装 Ambari，配置 Ambari 使用 Kerberos。</p>
<p>在用户管理方面，LDAP 用来做账号管理，Kerberos作为认证。</p>
<p><img src="FgebwAsqPaPFJTIFecC9xfXoEI3P" alt="Ambari use Kerberos+LDAP"></p>
<p>有关 Ambari 使用 Kerberos 文章</p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ambrri-kerberos/">大数据平台搭建利器 Ambari 之 Kerberos 集成之路</a></p>
<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p><strong>注意：以下操作均是 shell 脚本形式</strong></p>
<ol>
<li>配置静态主机名，配置 hosts 文件</li>
<li>同步时间，写入硬件时钟</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IPADDR=192.168.80.15</span><br><span class="line">HOSTNAME=kdc.kevin.com</span><br><span class="line"></span><br><span class="line">hostnamectl set-hostname kdc.kevin.com</span><br><span class="line">cat &lt;&lt;- EOF &gt;&gt;/etc/hosts</span><br><span class="line"><span class="meta">$</span><span class="bash">IPADDR <span class="variable">$HOSTNAME</span></span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">yum install -y ntp</span><br><span class="line">ntpdate 192.168.80.5</span><br><span class="line">ntpdate 192.168.80.5</span><br><span class="line"><span class="meta">#</span><span class="bash"> ntpdate cn.pool.ntp.org</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Synchronize the system time to hardware clock to system time</span></span><br><span class="line">/sbin/hwclock --systohc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Openldap"><a href="#Openldap" class="headerlink" title="Openldap"></a>Openldap</h2><h3 id="1-LDAP简介"><a href="#1-LDAP简介" class="headerlink" title="1. LDAP简介"></a>1. LDAP简介</h3><p>LDAP（轻量级目录访问协议，Lightweight Directory Access Protocol)是实现提供被称为目录服务的信息服务。目录服务是一种特殊的数据库系统，其专门针对读取，浏览和搜索操作进行了特定的优化。目录一般用来包含描述性的，基于属性的信息并支持精细复杂的过滤能力。目录一般不支持通用数据库针对大量更新操作操作需要的复杂的事务管理或回卷策略。而目录服务的更新则一般都非常简单。这种目录可以存储包括个人信息、web链结、jpeg图像等各种信息。为了访问存储在目录中的信息，就需要使用运行在TCP/IP 之上的访问协议—LDAP。</p>
<p>LDAP目录中的信息是是按照树型结构组织，具体信息存储在条目(entry)的数据结构中。条目相当于关系数据库中表的记录；条目是具有区别名DN （Distinguished Name）的属性（Attribute），DN是用来引用条目的，DN相当于关系数据库表中的关键字（Primary Key）。属性由类型（Type）和一个或多个值（Values）组成，相当于关系数据库中的字段（Field）由字段名和数据类型组成，只是为了方便检索的需要，LDAP中的Type可以有多个Value，而不是关系数据库中为降低数据的冗余性要求实现的各个域必须是不相关的。LDAP中条目的组织一般按照地理位置和组织关系进行组织，非常的直观。LDAP把数据存放在文件中，为提高效率可以使用基于索引的文件数据库，而不是关系数据库。类型的一个例子就是mail，其值将是一个电子邮件地址。</p>
<p>LDAP的信息是以树型结构存储的，在树根一般定义国家(c=CN)或域名(dc=com)，在其下则往往定义一个或多个组织 (organization)(o=Acme)或组织单元(organizational units) (ou=People)。一个组织单元可能包含诸如所有雇员、大楼内的所有打印机等信息。此外，LDAP支持对条目能够和必须支持哪些属性进行控制，这是有一个特殊的称为对象类别(objectClass)的属性来实现的。该属性的值决定了该条目必须遵循的一些规则，其规定了该条目能够及至少应该包含哪些属性。例如：inetorgPerson对象类需要支持sn(surname)和cn(common name)属性，但也可以包含可选的如邮件，电话号码等属性。</p>
<h3 id="2-LDAP简称对应"><a href="#2-LDAP简称对应" class="headerlink" title="2. LDAP简称对应"></a>2. LDAP简称对应</h3><ol>
<li>o – organization（组织-公司）</li>
<li>ou – organization unit（组织单元-部门）</li>
<li>c - countryName（国家）</li>
<li>dc - domainComponent（域名）</li>
<li>sn – suer name（真实名称）</li>
<li>cn - common name（常用名称）</li>
</ol>
<h3 id="3-LDAP组织数据的方式"><a href="#3-LDAP组织数据的方式" class="headerlink" title="3. LDAP组织数据的方式"></a>3. LDAP组织数据的方式</h3><p><img src="http://qiniu.iclouds.work/FnauYneup7vt01kIs1g18dRLDpj3.png" alt="LDAP组织数据的方式"></p>
<h3 id="4-Openldap-安装配置"><a href="#4-Openldap-安装配置" class="headerlink" title="4. Openldap 安装配置"></a>4. Openldap 安装配置</h3><h4 id="4-1-install-opneldap"><a href="#4-1-install-opneldap" class="headerlink" title="4.1 install opneldap"></a>4.1 install opneldap</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y openldap openldap-clients openldap-servers openldap-devel </span><br></pre></td></tr></table></figure>

<h4 id="4-2-start-openldap"><a href="#4-2-start-openldap" class="headerlink" title="4.2 start openldap"></a>4.2 start openldap</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动服务命令</span></span><br><span class="line">systemctl start slapd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入开机启动项</span></span><br><span class="line">systemctl enable slapd</span><br></pre></td></tr></table></figure>

<h4 id="4-3-config-openldap-schema"><a href="#4-3-config-openldap-schema" class="headerlink" title="4.3 config openldap schema"></a>4.3 config openldap schema</h4><p>这里最好把 <code>core.ldif</code> 放在第一行，要不然可能会出现错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/core.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/collective.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/corba.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/duaconf.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/dyngroup.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/java.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/misc.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/openldap.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/pmi.ldif</span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/ppolicy.ldif</span><br></pre></td></tr></table></figure>

<h4 id="4-4-init-openldap"><a href="#4-4-init-openldap" class="headerlink" title="4.4 init openldap"></a>4.4 init openldap</h4><p><code>RootDN: cn=ldapadmin,dc=kevin,dc=com</code> 是Openldap 的超级管理用户</p>
<p><code>RootPW: &#123;SSHA&#125;KB+0AIufB7WpDCvf15u30aD2HSRHyGvZ</code> 是其密码。当然可以直接使用明文</p>
<p>密码是生成哈希口令可以通过 <code>slappasswd</code> 生成。这里的密码明文是 <code>000001</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/openldapConf</span><br><span class="line">cat &lt;&lt;- EOF &gt;/root/openldapConf/db.ldif</span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">replace: olcSuffix</span><br><span class="line">olcSuffix: dc=kevin,dc=com</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">replace: olcRootDN</span><br><span class="line">olcRootDN: cn=ldapadmin,dc=kevin,dc=com</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">replace: olcRootPW</span><br><span class="line">olcRootPW: &#123;SSHA&#125;KB+0AIufB7WpDCvf15u30aD2HSRHyGvZ</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;- EOF &gt;/root/openldapConf/monitor.ldif</span><br><span class="line">dn: olcDatabase=&#123;1&#125;monitor,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">replace: olcAccess</span><br><span class="line">olcAccess: &#123;0&#125;to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external, cn=auth&quot; read by dn.base=&quot;cn=ldapadmin,dc=kevin,dc=com&quot; read by * none</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ldapmodify -Y EXTERNAL -H ldapi:/// -f ~/openldapConf/db.ldif </span><br><span class="line">ldapmodify -Y EXTERNAL -H ldapi:/// -f ~/openldapConf/monitor.ldif </span><br><span class="line"></span><br><span class="line">cat &lt;&lt;- EOF &gt;/root/openldapConf/base.ldif</span><br><span class="line">dn: dc=kevin,dc=com</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: dcObject</span><br><span class="line">objectclass: organization</span><br><span class="line">o: kevin net</span><br><span class="line"></span><br><span class="line">dn: ou=People,dc=kevin,dc=com</span><br><span class="line">objectClass: organizationalUnit</span><br><span class="line">ou: People</span><br><span class="line"></span><br><span class="line">dn: ou=Group,dc=kevin,dc=com</span><br><span class="line">objectClass: organizationalUnit</span><br><span class="line">ou: Group</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ldapadd -x -w 000001 -D &quot;cn=ldapadmin,dc=kevin,dc=com&quot; -f ~/openldapConf/base.ldif</span><br></pre></td></tr></table></figure>

<h4 id="4-5-import-System’s-users"><a href="#4-5-import-System’s-users" class="headerlink" title="4.5 import System’s users"></a>4.5 import System’s users</h4><p>使用 <code>migrationtools</code> 工具导入我们在 机器中创建的测试账户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y migrationtools</span><br><span class="line">sed -i &#x27;/\$DEFAULT_MAIL_DOMAIN = &quot;/s/\(&quot;.*&quot;\)/&quot;kevim.com&quot;/g&#x27; /usr/share/migrationtools/migrate_common.ph</span><br><span class="line">sed -i &#x27;/\$DEFAULT_BASE = &quot;/s/\(&quot;.*&quot;\)/&quot;dc=kevin,dc=com&quot;/g&#x27; /usr/share/migrationtools/migrate_common.ph</span><br><span class="line">sed -i &#x27;/\$EXTENDED_SCHEMA = /s/\([0-9]\)/1/g&#x27; /usr/share/migrationtools/migrate_common.ph</span><br><span class="line"></span><br><span class="line">useradd ldapuser1</span><br><span class="line">useradd ldapuser2</span><br><span class="line"></span><br><span class="line">echo &quot;redhat&quot; | passwd --stdin ldapuser1</span><br><span class="line">echo &quot;redhat&quot; | passwd --stdin ldapuser2</span><br><span class="line"></span><br><span class="line">grep &quot;:10[0-9][0-9]&quot; /etc/passwd &gt; /root/passwd</span><br><span class="line">grep &quot;:10[0-9][0-9]&quot; /etc/group &gt; /root/group</span><br><span class="line"></span><br><span class="line">/usr/share/migrationtools/migrate_passwd.pl /root/passwd ~/openldapConf/users.ldif</span><br><span class="line">/usr/share/migrationtools/migrate_group.pl /root/group ~/openldapConf/groups.ldif</span><br><span class="line"></span><br><span class="line">ldapadd -x -w 000001 -D &quot;cn=ldapadmin,dc=kevin,dc=com&quot; -f ~/openldapConf/users.ldif</span><br><span class="line">ldapadd -x -w 000001 -D &quot;cn=ldapadmin,dc=kevin,dc=com&quot; -f ~/openldapConf/groups.ldif</span><br></pre></td></tr></table></figure>

<p>搜索一下我们刚刚创建的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldapsearch -x cn=ldapuser1 -b dc=kdc,dc=kevin,dc=com</span><br></pre></td></tr></table></figure>

<p>到这里 openldap 就安装配置完成了</p>
<p>可以使用 <a href="http://directory.apache.org/studio/">Apache Directory Studio</a> 工具在可视化界面进行操作。</p>
<h2 id="Kerberos-backend-Openldap"><a href="#Kerberos-backend-Openldap" class="headerlink" title="Kerberos backend Openldap"></a>Kerberos backend Openldap</h2><p>kerberos认证过程</p>
<blockquote>
<p>参考博文：<br><a href="http://blog.sina.com.cn/s/blog_5384e78b0100fhcx.html">http://blog.sina.com.cn/s/blog_5384e78b0100fhcx.html</a></p>
</blockquote>
<h3 id="1-Kerberos-基本原理"><a href="#1-Kerberos-基本原理" class="headerlink" title="1. Kerberos 基本原理"></a>1. Kerberos 基本原理</h3><p>Authentication解决的是“如何证明某个人确确实实就是他或她所声称的那个人” 的问题。对于如何进行Authentication，我们采用这样的方法：如果一个秘密（secret）仅仅存在于A和B，那么有个人对B声称自己就是 A，B通过让A提供这个秘密来证明这个人就是他或她所声称的A。这个过程实际上涉及到3个重要的关于Authentication的方面：</p>
<ul>
<li>Secret 如何表示。</li>
<li>A如何向 B 提供 Secret。</li>
<li>B如何识别 Secret。</li>
</ul>
<p>基于这3个方面，我们把 Kerberos Authentication 进行最大限度的简化：整个过程涉及到 Client 和 Server ，他们之间的这个 ecret 我们用一个 Key（KServer-Client）来表示。 Client 为了让 Server 对自己进行有效的认证，向对方提供如下两组信息：</p>
<ul>
<li>代表 Client 自身 Identity 的信息，为了简便，它以明文的形式传递。</li>
<li>将 Client 的 dentity使用 KServer-Client 作为 Public Key 、并采用对称加密算法进行加密。</li>
</ul>
<p>由于 KServer-Client 仅仅被 Client 和 Server 知晓，所以被 Client 使用 KServer-Client 加密过的Client Identity 只能被 Client 和 Server 解密。同理，Server 接收到 Client 传送的这两组信息，先通过  KServer-Client 对 后者进行解密，随后将机密的数据同前者进行比较，如果完全一样，则可以证明Client能过提供正确的 KServer-Client，而这个世界上，仅仅 只有真正的Client和自己知道KServer-Client，所以可以对方就是他所声称的那个人。</p>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/Fq1RIVUaC5rOUWR_5rFgfEoN7Nny.png" alt="Kerberos 简化认证"></p>
<p>Keberos 大体上就是按照这样的一个原理来进行 Authentication 的。但是 Kerberos 远比这个复杂，我将在后续的章节中不断地扩充这个过程，知道 Kerberos 真实的认证过程。为了使读者更加容易理解后续的部分，在这里我们先给出两个重要的概念：</p>
<ul>
<li>Long-term Key/Master Key：<br>在 Security 的领域中，有的 Key 可能长期内保持不变，比如你在密码，可能几年都不曾改变，这样的 Key、以及由此派生的 Key 被称为 Long-term Key。对于 Long-term Key 的使用有这样的原则：被 Long-term Key 加密的数据不应该在网络上传输。原因很简单，一旦这些被 Long-term Key 加密的数据包被恶意的网络监听者截获，在原则上，只要有充足的时间，他是可以通过计算获得你用于加密的 Long-term Key 的——任何加密算法都不可能做到绝对保密。<br>在一般情况下，对于一个 Account 来说，密码往往仅仅限于该 Account 的所有者知 晓，甚至对于任何 Domain 的 Administrator，密码仍然应该是保密的。但是密码却又是证明身份的凭据，所以必须通过基于你密码的派生的信息 来证明用户的真实身份，在这种情况下，一般将你的密码进行Hash运算得到一个 Hash code , 我们一般管这样的 Hash Code 叫做 Master Key。由于 Hash Algorithm 是不可逆的，同时保证密码和 Master Key 是一一对应的，这样既保证了你密码的保密性，有同时保证你的 Master Key 和密码本身在证明你身份的时候具有相同的效力。</li>
<li>Short-term Key/Session Key：<br>由于被 Long-term Key 加密的数据包不能用于网络传送，所以我们使用另一种 Short-term Key 来加密需要进行网络传输的数据。由于这种Key只在一段时间内有效，即使被加密的数据包被黑客截获，等他把Key计算出来的时候，这个 Key 早就已 经过期了。</li>
</ul>
<h3 id="2-引入Key-Distribution-KServer-Client从何而来"><a href="#2-引入Key-Distribution-KServer-Client从何而来" class="headerlink" title="2. 引入Key Distribution: KServer-Client从何而来"></a>2. 引入Key Distribution: KServer-Client从何而来</h3><p>上面我们讨论了Kerberos Authentication的基本原理：通过让被认证的一方提供一个仅限于他和认证方知晓的Key来鉴定对方的真实身份。而被这个Key加密的数据包需 要在Client和Server之间传送，所以这个Key不能是一个Long-term Key，而只可能是Short-term Key，这个可以仅仅在Client和Server的一个Session中有效，所以我们称这个Key为Client和Server之间的Session Key（SServer-Client）。</p>
<p>现在我们来讨论Client和Server如何得到这个SServer-Client。在这 里我们要引入一个重要的角色：Kerberos Distribution Center-KDC。KDC在整个Kerberos Authentication中作为Client和Server共同信任的第三方起着重要的作用，而Kerberos的认证过程就是通过这3方协作完成。 顺便说一下，Kerberos起源于希腊神话，是一支守护着冥界长着3个头颅的神犬，在keberos Authentication中，Kerberos的3个头颅代表中认证过程中涉及的3方：Client、Server和KDC。</p>
<p>对于一个Windows Domain来说，Domain Controller扮演着KDC的角色。KDC维护着一个存储着该Domain中所有帐户的Account Database（一般地，这个Account Database由AD来维护），也就是说，他知道属于每个Account的名称和派生于该Account Password的Master Key。而用于Client和Server相互认证的SServer-Client就是有KDC分发。下面我们来看看KDC分发SServer- Client的过程。</p>
<p>通过下图我们可以看到KDC分发SServer-Client的简单的过程：首先 Client向KDC发送一个对SServer-Client的申请。这个申请的内容可以简单概括为“我是某个Client，我需要一个Session Key用于访问某个Server ”。KDC在接收到这个请求的时候，生成一个Session Key，为了保证这个Session Key仅仅限于发送请求的Client和他希望访问的Server知晓，KDC会为这个Session Key生成两个Copy，分别被Client和Server使用。然后从Account database中提取Client和Server的Master Key分别对这两个Copy进行对称加密。对于后者，和Session Key一起被加密的还包含关于Client的一些信息。</p>
<p>KDC现在有了两个分别被Client和Server 的Master Key加密过的Session Key，这两个Session Key如何分别被Client和Server获得呢？也许你 马上会说，KDC直接将这两个加密过的包发送给Client和Server不就可以了吗，但是如果这样做，对于Server来说会出现下面 两个问题：</p>
<ul>
<li>由于一个Server会面对若干不同的Client, 而每个Client都具有一个不同的Session Key。那么Server就会为所有的Client维护这样一个Session Key的列表，这样做对于Server来说是比较麻烦而低效的。</li>
<li>由于网络传输的不确定性，可能出现这样一种情况：Client很快获得Session Key，并将这个Session Key作为Credential随同访问请求发送到Server，但是用于Server的Session Key确还没有收到，并且很有可能承载这个Session Key的永远也到不了Server端，Client将永远得不到认证。<br>为了解决这个问题，Kerberos的做法很简单，将这两个被加密的Copy一并发送给Client，属于Server的那份由Client发送给Server。</li>
</ul>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/Fkzz-BixXinr63A3qciytXOy-ZIj.png" alt="kerberos认证过程-2"></p>
<p>可能有人会问，KDC并没有真正去认证这个发送请求的Client是否真的就是那个他所声称的那个人，就把Session Key发送给他，会不会有什么问题？如果另一个人（比如Client B）声称自己是Client A，他同样会得到Client A和Server的Session Key，这会不会有什么问题？实际上不存在问题，因为Client B声称自己是Client A，KDC就会使用Client A的Password派生的Master Key对Session Key进行加密，所以真正知道Client A 的Password的一方才会通过解密获得Session Key。</p>
<h3 id="3-引入Authenticator-为有效的证明自己提供证据"><a href="#3-引入Authenticator-为有效的证明自己提供证据" class="headerlink" title="3. 引入Authenticator - 为有效的证明自己提供证据"></a>3. 引入Authenticator - 为有效的证明自己提供证据</h3><p>通过上面的过程，Client实际上获得了两组信息：一个通过自己Master Key加密的Session Key，另一个被Sever的Master Key加密的数据包，包含Session Key和关于自己的一些确认信息。通过第一节，我们说只要通过一个双方知晓的Key就可以对对方进行有效的认证，但是在一个网络的环境中，这种简单的做法 是具有安全漏洞，为此,Client需要提供更多的证明信息，我们把这种证明信息称为Authenticator，在Kerberos的 Authenticator实际上就是关于Client的一些信息和当前时间的一个Timestamp（关于这个安全漏洞和Timestamp的作用，我 将在后面解释）。</p>
<p>在这个基础上，我们再来看看Server如何对Client进行认证：Client通过自己 的Master Key对KDC加密的Session Key进行解密从而获得Session Key，随后创建Authenticator（Client Info + Timestamp）并用Session Key对其加密。最后连同从KDC获得的、被Server的Master Key加密过的数据包（Client Info + Session Key）一并发送到Server端。我们把通过Server的Master Key加密过的数据包称为Session Ticket。</p>
<p>当Server接收到这两组数据后，先使用他自己的Master Key对Session Ticket进行解密，从而获得Session Key。随后使用该Session Key解密Authenticator，通过比较Authenticator中的Client Info和Session Ticket中的Client Info从而实现对Client的认证。</p>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/Fq7UeqH9hJRfyNCzgGCC11WEGa3v.png" alt="kerberos认证过程-3"></p>
<p>为什么要使用Timestamp？</p>
<p>到这里，很多人可能认为这样的认证过程天衣无缝：只有当Client提供正确的Session Key方能得到Server的认证。但是在现实环境中，这存在很大的安全漏洞。</p>
<p>我们试想这样的现象：Client向Server发送的数据包被某个恶意网络监听者截获，该 监听者随后将数据包座位自己的Credential冒充该Client对Server进行访问，在这种情况下，依然可以很顺利地获得Server的成功认 证。为了解决这个问题，Client在Authenticator中会加入一个当前时间的Timestamp。</p>
<p>在Server对Authenticator中的Client Info和Session Ticket中的Client Info进行比较之前，会先提取Authenticator中的Timestamp，并同当前的时间进行比较，如果他们之间的偏差超出一个可以接受的时间 范围（一般是5mins），Server会直接拒绝该Client的请求。在这里需要知道的是，Server维护着一个列表，这个列表记录着在这个可接受 的时间范围内所有进行认证的Client和认证的时间。对于时间偏差在这个可接受的范围中的Client，Server会从这个这个列表中获得最近一个该 Client的认证时间，只有当Authenticator中的Timestamp晚于通过一个Client的最近的认证时间的情况下，Server采用 进行后续的认证流程。</p>
<p>Time Synchronization的重要性</p>
<p>上述 基于Timestamp的认证机制只有在Client和Server端的时间保持同步的情况才有意义。所以保持Time Synchronization在整个认证过程中显得尤为重要。在一个Domain中，一般通过访问同一个Time Service获得当前时间的方式来实现时间的同步。</p>
<p>双向认证（Mutual Authentication）</p>
<p>Kerberos一个重要的优势在于它能够提供双向认证：不但Server可以对Client 进行认证，Client也能对Server进行认证。</p>
<p>具体过程是这样的，如果Client需要对他访问的Server进行认证，会在它向 Server发送的Credential中设置一个是否需要认证的Flag。Server在对Client认证成功之后，会把Authenticator 中的Timestamp提出出来，通过Session Key进行加密，当Client接收到并使用Session Key进行解密之后，如果确认Timestamp和原来的完全一致，那么他可以认定Server正式他试图访问的Server。</p>
<p>那么为什么Server不直接把通过Session Key进行加密的Authenticator原样发送给Client，而要把Timestamp提取出来加密发送给Client呢？原因在于防止恶意的监 听者通过获取的Client发送的Authenticator冒充Server获得Client的认证。</p>
<h3 id="4-引入Ticket-Granting-Service"><a href="#4-引入Ticket-Granting-Service" class="headerlink" title="4. 引入Ticket Granting  Service"></a>4. 引入Ticket Granting  Service</h3><p>通过上面的介绍，我们发现Kerberos实际上一个基于Ticket的认证方式。 Client想要获取Server端的资源，先得通过Server的认证；而认证的先决条件是Client向Server提供从KDC获得的一个有 Server的Master Key进行加密的Session Ticket（Session Key + Client Info）。可以这么说，Session Ticket是Client进入Server领域的一张门票。而这张门票必须从一个合法的Ticket颁发机构获得，这个颁发机构就是Client和 Server双方信任的KDC， 同时这张Ticket具有超强的防伪标识：它是被Server的Master Key加密的。对Client来说， 获得Session Ticket是整个认证过程中最为关键的部分。</p>
<p>上面我们只是简单地从大体上说明了KDC向Client分发Ticket的过程，而真正在 Kerberos中的Ticket Distribution要复杂一些。为了更好的说明整个Ticket Distribution的过程，我在这里做一个类比。现在的股事很火爆，上海基本上是全民炒股，我就举一个认股权证的例子。有的上市公司在股票配股、增 发、基金扩募、股份减持等情况会向公众发行认股权证，认股权证的持有人可以凭借这个权证认购一定数量的该公司股票，认股权证是一种具有看涨期权的金融衍生 产品。</p>
<p>而我们今天所讲的Client获得Ticket的过程也和通过认股权证购买股票的过程类似。 如果我们把Client提供给Server进行认证的Ticket比作股票的话，那么Client在从KDC那边获得Ticket之前，需要先获得这个 Ticket的认购权证，这个认购权证在Kerberos中被称为TGT：Ticket Granting Ticket，TGT的分发方仍然是KDC。</p>
<p>我们现在来看看Client是如何从KDC处获得TGT的：首先Client向KDC发起对 TGT的申请，申请的内容大致可以这样表示：“我需要一张TGT用以申请获取用以访问所有Server的Ticket”。KDC在收到该申请请求后，生成 一个用于该Client和KDC进行安全通信的Session Key（SKDC-Client）。为了保证该Session Key仅供该Client和自己使用，KDC使用Client的Master Key和自己的Master Key对生成的Session Key进行加密，从而获得两个加密的SKDC-Client的Copy。对于后者，随SKDC-Client一起被加密的还包含以后用于鉴定Client 身份的关于Client的一些信息。最后KDC将这两份Copy一并发送给Client。这里有一点需要注意的是：为了免去KDC对于基于不同 Client的Session Key进行维护的麻烦，就像Server不会保存Session Key（SServer-Client）一样，KDC也不会去保存这个Session Key（SKDC-Client），而选择完全靠Client自己提供的方式。</p>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/Fu_YdcRpNLqf9cA87QH5Z-SmbReO.png" alt="kerberos认证过程-4"></p>
<p>当Client收到KDC的两个加密数据包之后，先使用自己的Master Key对第一个Copy进行解密，从而获得KDC和Client的Session Key（SKDC-Client），并把该Session 和TGT进行缓存。有了Session Key和TGT，Client自己的Master Key将不再需要，因为此后Client可以使用SKDC-Client向KDC申请用以访问每个Server的Ticket，相对于Client的 Master Key这个Long-term Key，SKDC-Client是一个Short-term Key，安全保证得到更好的保障，这也是Kerberos多了这一步的关键所在。同时需要注意的是SKDC-Client是一个Session Key，他具有自己的生命周期，同时TGT和Session相互关联，当Session Key过期，TGT也就宣告失效，此后Client不得不重新向KDC申请新的TGT，KDC将会生成一个不同Session Key和与之关联的TGT。同时，由于Client Log off也导致SKDC-Client的失效，所以SKDC-Client又被称为Logon Session Key。</p>
<p>接下来，我们看看Client如何使用TGT来从KDC获得基于某个Server的 Ticket。在这里我要强调一下，Ticket是基于某个具体的Server的，而TGT则是和具体的Server无关的，Client可以使用一个 TGT从KDC获得基于不同Server的Ticket。我们言归正传，Client在获得自己和KDC的Session Key（SKDC-Client）之后，生成自己的Authenticator以及所要访问的Server名称的并使用SKDC-Client进行加密。 随后连同TGT一并发送给KDC。KDC使用自己的Master Key对TGT进行解密，提取Client Info和Session Key（SKDC-Client），然后使用这个SKDC-Client解密Authenticator获得Client Info，对两个Client Info进行比较进而验证对方的真实身份。验证成功，生成一份基于Client所要访问的Server的Ticket给Client，这个过程就是我们第 二节中介绍的一样了。</p>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/Fr9zMt40ZalrCIf4la3wt3WL-W16.png" alt="kerberos认证过程-4"></p>
<h3 id="5-Kerberos的3个Sub-protocol：整个Authentication"><a href="#5-Kerberos的3个Sub-protocol：整个Authentication" class="headerlink" title="5. Kerberos的3个Sub-protocol：整个Authentication"></a>5. Kerberos的3个Sub-protocol：整个Authentication</h3><p>通过以上的介绍，我们基本上了解了整个Kerberos authentication的整个流程：整个流程大体上包含以下3个子过程：</p>
<ul>
<li>Client向KDC申请TGT（Ticket Granting Ticket）。</li>
<li>Client通过获得TGT向DKC申请用于访问Server的Ticket。</li>
<li>Client最终向为了Server对自己的认证向其提交Ticket。</li>
</ul>
<p>不过上面的介绍离真正的Kerberos Authentication还是有一点出入。Kerberos整个认证过程通过3个sub-protocol来完成。这个3个Sub-Protocol分别完成上面列出的3个子过程。这3个sub-protocol分别为：</p>
<ul>
<li>Authentication Service Exchange</li>
<li>Ticket Granting Service Exchange</li>
<li>Client/Server Exchange</li>
</ul>
<p>下图简单展示了完成这个3个Sub-protocol所进行Message Exchange。</p>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/FluQ4WiVs4G4PjzqHqqRub_yy5Cp.png" alt="kerberos认证过程-5"></p>
<h4 id="5-1-Authentication-Service-Exchange"><a href="#5-1-Authentication-Service-Exchange" class="headerlink" title="5.1 Authentication Service Exchange"></a>5.1 Authentication Service Exchange</h4><p>通过这个Sub-protocol，KDC（确切地说是KDC中的Authentication Service）实现对Client身份的确认，并颁发给该Client一个TGT。具体过程如下：</p>
<p>Client向KDC的Authentication Service发送Authentication Service Request（KRB_AS_REQ）, 为了确保KRB_AS_REQ仅限于自己和KDC知道，Client使用自己的Master Key对KRB_AS_REQ的主体部分进行加密（KDC可以通过Domain 的Account Database获得该Client的Master Key）。KRB_AS_REQ的大体包含以下的内容：</p>
<ul>
<li>Pre-authentication data：包含用以证明自己身份的信息。说白了，就是证明自己知道自己声称的那个account的Password。一般地，它的内容是一个被Client的Master key加密过的Timestamp。</li>
<li>Client name &amp; realm: 简单地说就是Domain name\Client</li>
<li>Server Name：注意这里的Server Name并不是Client真正要访问的Server的名称，而我们也说了TGT是和Server无关的（Client只能使用Ticket，而不是 TGT去访问Server）。这里的Server Name实际上是KDC的Ticket Granting Service的Server Name。</li>
</ul>
<p>AS（Authentication Service）通过它接收到的KRB_AS_REQ验证发送方的是否是在Client name &amp; realm中声称的那个人，也就是说要验证发送放是否知道Client的Password。所以AS只需从Account Database中提取Client对应的Master Key对Pre-authentication data进行解密，如果是一个合法的Timestamp，则可以证明发送放提供的是正确无误的密码。验证通过之后，AS将一份 Authentication Service Response（KRB_AS_REP）发送给Client。KRB_AS_REQ主要包含两个部分：本Client的Master Key加密过的Session Key（SKDC-Client：Logon Session Key）和被自己（KDC）加密的TGT。而TGT大体又包含以下的内容：</p>
<ul>
<li>Session Key: SKDC-Client：Logon Session Key</li>
<li>Client name &amp; realm: 简单地说就是Domain name\Client</li>
<li>End time: TGT到期的时间。</li>
</ul>
<p>Client通过自己的Master Key对第一部分解密获得Session Key（SKDC-Client：Logon Session Key）之后，携带着TGT便可以进入下一步：TGS（Ticket Granting Service）Exchange。</p>
<h4 id="5-2-TGS（Ticket-Granting-Service）Exchange"><a href="#5-2-TGS（Ticket-Granting-Service）Exchange" class="headerlink" title="5.2  TGS（Ticket Granting Service）Exchange"></a>5.2  TGS（Ticket Granting Service）Exchange</h4><p>TGS（Ticket Granting Service）Exchange通过Client向KDC中的TGS（Ticket Granting Service）发送Ticket Granting Service Request（KRB_TGS_REQ）开始。KRB_TGS_REQ大体包含以下的内容：</p>
<ul>
<li>TGT：Client通过AS Exchange获得的Ticket Granting Ticket，TGT被KDC的Master Key进行加密。</li>
<li>Authenticator：用以证明当初TGT的拥有者是否就是自己，所以它必须以TGT的办法方和自己的Session Key（SKDC-Client：Logon Session Key）来进行加密。</li>
<li>Client name &amp; realm: 简单地说就是Domain name\Client。</li>
<li>Server name &amp; realm: 简单地说就是Domain name\Server，这回是Client试图访问的那个Server。</li>
</ul>
<p>TGS收到KRB_TGS_REQ在发给Client真正的Ticket之前，先得整个 Client提供的那个TGT是否是AS颁发给它的。于是它不得不通过Client提供的Authenticator来证明。但是 Authentication是通过Logon Session Key（SKDC-Client）进行加密的，而自己并没有保存这个Session Key。所以TGS先得通过自己的Master Key对Client提供的TGT进行解密，从而获得这个Logon Session Key（SKDC-Client），再通过这个Logon Session Key（SKDC-Client）解密Authenticator进行验证。验证通过向对方发送Ticket Granting Service Response（KRB_TGS_REP）。这个KRB_TGS_REP有两部分组成：使用Logon Session Key（SKDC-Client）加密过用于Client和Server的Session Key（SServer-Client）和使用Server的Master Key进行加密的Ticket。该Ticket大体包含以下一些内容：</p>
<ul>
<li>Session Key：SServer-Client。</li>
<li>Client name &amp; realm: 简单地说就是Domain name\Client。</li>
<li>End time: Ticket的到期时间。</li>
</ul>
<p>Client收到KRB_TGS_REP，使用Logon Session Key（SKDC-Client）解密第一部分后获得Session Key（SServer-Client）。有了Session Key和Ticket，Client就可以之间和Server进行交互，而无须在通过KDC作中间人了。所以我们说Kerberos是一种高效的认证方 式，它可以直接通过Client和Server双方来完成，不像Windows NT 4下的NTLM认证方式，每次认证都要通过一个双方信任的第3方来完成。</p>
<p>我们现在来看看 Client如果使用Ticket和Server怎样进行交互的，这个阶段通过我们的第3个Sub-protocol来完成：CS（Client/Server ）Exchange。</p>
<h4 id="5-3-CS（Client-Server-）Exchange"><a href="#5-3-CS（Client-Server-）Exchange" class="headerlink" title="5.3 CS（Client/Server ）Exchange"></a>5.3 CS（Client/Server ）Exchange</h4><p>这个已经在本文的第二节中已经介绍过，对于重复发内容就不再累赘了。Client通过TGS Exchange获得Client和Server的Session Key（SServer-Client），随后创建用于证明自己就是Ticket的真正所有者的Authenticator，并使用Session Key（SServer-Client）进行加密。最后将这个被加密过的Authenticator和Ticket作为Application Service Request（KRB_AP_REQ）发送给Server。除了上述两项内容之外，KRB_AP_REQ还包含一个Flag用于表示Client是否需 要进行双向验证（Mutual Authentication）。</p>
<p>Server接收到KRB_AP_REQ之后，通过自己的Master Key解密Ticket，从而获得Session Key（SServer-Client）。通过Session Key（SServer-Client）解密Authenticator，进而验证对方的身份。验证成功，让Client访问需要访问的资源，否则直接拒 绝对方的请求。</p>
<p>对于需要进行双向验证，Server从Authenticator提取Timestamp，使用Session Key（SServer-Client）进行加密，并将其发送给Client用于Client验证Server的身份。</p>
<h3 id="6-User2User-Sub-Protocol：有效地保障Server的安全"><a href="#6-User2User-Sub-Protocol：有效地保障Server的安全" class="headerlink" title="6. User2User Sub-Protocol：有效地保障Server的安全"></a>6. User2User Sub-Protocol：有效地保障Server的安全</h3><p>通过3个Sub-protocol的介绍，我们可以全面地掌握整个Kerberos的认证过 程。实际上，在Windows 2000时代，基于Kerberos的Windows Authentication就是按照这样的工作流程来进行的。但是我在上面一节结束的时候也说了，基于3个Sub-protocol的Kerberos 作为一种Network Authentication是具有它自己的局限和安全隐患的。我在整篇文章一直在强调这样的一个原则：以某个Entity的Long-term Key加密的数据不应该在网络中传递。原因很简单，所有的加密算法都不能保证100%的安全，对加密的数据进行解密只是一个时间的过程，最大限度地提供安 全保障的做法就是：使用一个Short-term key（Session Key）代替Long-term Key对数据进行加密，使得恶意用户对其解密获得加密的Key时，该Key早已失效。但是对于3个Sub-Protocol的C/S Exchange，Client携带的Ticket却是被Server Master Key进行加密的，这显现不符合我们提出的原则，降低Server的安全系数。</p>
<p>所以我们必须寻求一种解决方案来解决上面的问题。这个解决方案很明显：就是采用一个 Short-term的Session Key，而不是Server Master Key对Ticket进行加密。这就是我们今天要介绍的Kerberos的第4个Sub-protocol：User2User Protocol。我们知道，既然是Session Key，仅必然涉及到两方，而在Kerberos整个认证过程涉及到3方：Client、Server和KDC，所以用于加密Ticket的只可能是 Server和KDC之间的Session Key（SKDC-Server）。</p>
<p>我们知道Client通过在AS Exchange阶段获得的TGT从KDC那么获得访问Server的Ticket。原来的Ticket是通过Server的Master Key进行加密的，而这个Master Key可以通过Account Database获得。但是现在KDC需要使用Server和KDC之间的SKDC-Server进行加密，而KDC是不会维护这个Session Key，所以这个Session Key只能靠申请Ticket的Client提供。所以在AS Exchange和TGS Exchange之间，Client还得对Server进行请求已获得Server和KDC之间的Session Key（SKDC-Server）。而对于Server来说，它可以像Client一样通过AS Exchange获得他和KDC之间的Session Key（SKDC-Server）和一个封装了这个Session Key并被KDC的Master Key进行加密的TGT，一旦获得这个TGT，Server会缓存它，以待Client对它的请求。我们现在来详细地讨论这一过程。</p>
<p><img src="http://ono3vb8rf.bkt.clouddn.com/Fmaqh-qBfq-rXFuXcSUNxplf9Ibu.png" alt="kerberos认证过程-6"></p>
<p>上图基本上翻译了基于User2User的认证过程，这个过程由4个步骤组成。我们发现较之我在上面一节介绍的基于传统3个Sub-protocol的认证过程，这次对了第2部。我们从头到尾简单地过一遍：</p>
<ol>
<li>AS Exchange：Client通过此过程获得了属于自己的TGT，有了此TGT，Client可凭此向KDC申请用于访问某个Server的Ticket。</li>
<li>这一步的主要任务是获得封装了Server和KDC的Session Key（SKDC-Server）的属于Server的TGT。如果该TGT存在于Server的缓存中，则Server会直接将其返回给Client。否则通过AS Exchange从KDC获取。</li>
<li>TGS Exchange：Client通过向KDC提供自己的TGT，Server的TGT以及Authenticator向KDC申请用于访问Server的 Ticket。KDC使用先用自己的Master Key解密Client的TGT获得SKDC-Client，通过SKDC-Client解密Authenticator验证发送者是否是TGT的真正拥 有者，验证通过再用自己的Master Key解密Server的TGT获得KDC和Server 的Session Key（SKDC-Server），并用该Session Key加密Ticket返回给Client。</li>
<li>C/S Exchange：Client携带者通过KDC和Server 的Session Key（SKDC-Server）进行加密的Ticket和通过Client和Server的Session Key（SServer-Client）的Authenticator访问Server，Server通过SKDC-Server解密Ticket获得 SServer-Client，通过SServer-Client解密Authenticator实现对Client的验证。<br>这就是整个过程。</li>
</ol>
<h3 id="7-Kerberos的优点"><a href="#7-Kerberos的优点" class="headerlink" title="7. Kerberos的优点"></a>7. Kerberos的优点</h3><p>分析整个Kerberos的认证过程之后，我们来总结一下Kerberos都有哪些优点：</p>
<h4 id="7-1-较高的Performance"><a href="#7-1-较高的Performance" class="headerlink" title="7.1 较高的Performance"></a>7.1 较高的Performance</h4><p>虽然我们一再地说Kerberos是一个涉及到3方的认证过程：Client、 Server、KDC。但是一旦Client获得用过访问某个Server的Ticket，该Server就能根据这个Ticket实现对Client的 验证，而无须KDC的再次参与。和传统的基于Windows NT 4.0的每个完全依赖Trusted Third Party的NTLM比较，具有较大的性能提升。</p>
<h4 id="7-2-实现了双向验证（Mutual-Authentication）"><a href="#7-2-实现了双向验证（Mutual-Authentication）" class="headerlink" title="7.2 实现了双向验证（Mutual Authentication）"></a>7.2 实现了双向验证（Mutual Authentication）</h4><p>传统的NTLM认证基于这样一个前提：Client访问的远程的Service是可信的、无 需对于进行验证，所以NTLM不曾提供双向验证的功能。这显然有点理想主义，为此Kerberos弥补了这个不足：Client在访问Server的资源 之前，可以要求对Server的身份执行认证。</p>
<h4 id="7-3-对Delegation的支持"><a href="#7-3-对Delegation的支持" class="headerlink" title="7.3 对Delegation的支持"></a>7.3 对Delegation的支持</h4><p>Impersonation和Delegation是一个分布式环境中两个重要的功能。 Impersonation允许Server在本地使用Logon 的Account执行某些操作，Delegation需用Server将logon的Account带入到另过一个Context执行相应的操作。 NTLM仅对Impersonation提供支持，而Kerberos通过一种双向的、可传递的（Mutual 、Transitive）信任模式实现了对Delegation的支持。</p>
<h4 id="7-4-互操作性（Interoperability）"><a href="#7-4-互操作性（Interoperability）" class="headerlink" title="7.4 互操作性（Interoperability）"></a>7.4 互操作性（Interoperability）</h4><p>Kerberos最初由MIT首创，现在已经成为一行被广泛接受的标准。所以对于不同的平台可以进行广泛的互操作。</p>
<h3 id="8-install-and-config"><a href="#8-install-and-config" class="headerlink" title="8. install and config"></a>8. install and config</h3><h4 id="8-1-install-kerberos"><a href="#8-1-install-kerberos" class="headerlink" title="8.1 install kerberos"></a>8.1 install kerberos</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install krb5-server krb5-libs krb5-server-ldap</span><br></pre></td></tr></table></figure>

<p>准备 <code>kerberos.schema</code> ，以便openldap 能够作为Kerberos KDC的后端数据库</p>
<p><code>kerberos.schema</code> 这个文件要在安装了 <code>krb5-server-ldap</code> 包之后才会出现。<br>具体位置在下面目录中。 x 代表版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/kopenldap/</span><br><span class="line">cp `find / -name kerberos.schema` /etc/openldap/schema/</span><br><span class="line">echo &quot;include /etc/openldap/schema/kerberos.schema&quot; &gt; ~/kopenldap/schema_convert.conf</span><br><span class="line">mkdir ~/kopenldap/ldif_result</span><br><span class="line">slapcat -f ~/kopenldap/schema_convert.conf -F ~/kopenldap/ldif_result/ -s &quot;cn=kerberos,cn=schema,cn=config&quot;</span><br><span class="line">cp  ~/kopenldap/ldif_result/cn\=config/cn\=schema/cn\=\&#123;0\&#125;kerberos.ldif /etc/openldap/schema/kerberos.ldif</span><br><span class="line">sed -i &#x27;/dn:/s/\(&#123;.*\)/cn=kerberos,cn=schema,cn=config/g&#x27; /etc/openldap/schema/kerberos.ldif</span><br><span class="line">sed -i &#x27;/cn:/s/\(&#123;.*\)/kerberos/g&#x27; /etc/openldap/schema/kerberos.ldif</span><br><span class="line">sed -i &#x27;/^structuralObjectClass/,$d&#x27; /etc/openldap/schema/kerberos.ldif</span><br><span class="line"></span><br><span class="line">ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/kerberos.ldif</span><br></pre></td></tr></table></figure>

<h4 id="8-2-kerberos-acl"><a href="#8-2-kerberos-acl" class="headerlink" title="8.2 kerberos acl"></a>8.2 kerberos acl</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF &gt;/root/kopenldap/access_kerberos.ldif</span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to dn.base=&quot;&quot; </span><br><span class="line"> by * read</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to dn.base=&quot;cn=Subschema&quot; </span><br><span class="line"> by * read</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to attrs=userPassword,userPKCS12 </span><br><span class="line"> by self write </span><br><span class="line"> by * auth</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to attrs=shadowLastChange </span><br><span class="line"> by self write </span><br><span class="line"> by * read</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to dn.subtree=&quot;cn=KEVIN.COM,cn=krbContainer,dc=kevin,dc=com&quot; </span><br><span class="line"> by dn.exact=&quot;cn=adm-srv,dc=kevin,dc=com&quot; write </span><br><span class="line"> by dn.exact=&quot;cn=kdc-srv,dc=kevin,dc=com&quot; write </span><br><span class="line"> by * none</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to dn.subtree=&quot;ou=people,dc=kevin,dc=com&quot; </span><br><span class="line"> by dn.exact=&quot;cn=adm-srv,dc=kevin,dc=com&quot; write </span><br><span class="line"> by dn.exact=&quot;cn=kdc-srv,dc=kevin,dc=com&quot; write </span><br><span class="line"> by * read</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to * </span><br><span class="line"> by * read</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ldapmodify -Y EXTERNAL  -H ldapi:/// -f /root/kopenldap/access_kerberos.ldif</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF&gt;/root/kopenldap/add_dbindex.ldif</span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcDbIndex</span><br><span class="line">olcDbIndex: krbPrincipalName eq,pres,sub</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcDbIndex</span><br><span class="line">olcDbIndex: krbPwdPolicyReference eq</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ldapmodify -Y EXTERNAL  -H ldapi:/// -f /root/kopenldap/add_dbindex.ldif</span><br></pre></td></tr></table></figure>

<h4 id="8-3-import-kerberos-users"><a href="#8-3-import-kerberos-users" class="headerlink" title="8.3 import kerberos users"></a>8.3 import kerberos users</h4><p>这里的 <code>userPassword: adm</code> 我使用的是明文。当然也可以使用 ldap 工具生成密文密码，如哈希的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF &gt;/root/kopenldap/krb5_users.ldif</span><br><span class="line">dn: cn=adm-srv,dc=kevin,dc=com</span><br><span class="line">cn: adm-srv</span><br><span class="line">objectClass: simpleSecurityObject</span><br><span class="line">objectClass: organizationalRole</span><br><span class="line">description: Default bind DN for the Kerberos Administration server</span><br><span class="line">userPassword: adm</span><br><span class="line"></span><br><span class="line">dn: cn=kdc-srv,dc=kevin,dc=com</span><br><span class="line">cn: kdc-srv</span><br><span class="line">objectClass: simpleSecurityObject</span><br><span class="line">objectClass: organizationalRole</span><br><span class="line">description: Default bind DN for the Kerberos KDC server</span><br><span class="line">userPassword: kdc</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ldapadd -x -w 000001 -D &quot;cn=ldapadmin,dc=kevin,dc=com&quot; -f /root/kopenldap/krb5_users.ldif</span><br></pre></td></tr></table></figure>

<p>使用 <code>slappasswd</code> 生成密文密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kdc ~]# slappasswd -s adm000000</span><br><span class="line">&#123;SSHA&#125;mAlCWsXBNyRzA+Ah/yFGjAX7A10bZKV2</span><br><span class="line">[root@kdc ~]# slappasswd -s kdc000000</span><br><span class="line">&#123;SSHA&#125;N+zBdLzinTQ652GaMehC0xzuQTQiIT1/</span><br></pre></td></tr></table></figure>

<p>修改 kerberos 管理密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF&gt;/root/kopenldap/changes.ldif</span><br><span class="line">dn: cn=adm-srv,dc=kevin,dc=com</span><br><span class="line">changetype: modify</span><br><span class="line">replace: userPassword</span><br><span class="line">userPassword: &#123;SSHA&#125;mAlCWsXBNyRzA+Ah/yFGjAX7A10bZKV2</span><br><span class="line"></span><br><span class="line">dn: cn=kdc-srv,dc=kevin,dc=com</span><br><span class="line">changetype: modify</span><br><span class="line">replace: userPassword</span><br><span class="line">userPassword: &#123;SSHA&#125;N+zBdLzinTQ652GaMehC0xzuQTQiIT1/</span><br><span class="line">EOF</span><br><span class="line">ldapadd -x -w 000001 -D &quot;cn=ldapadmin,dc=kevin,dc=com&quot; -f /root/kopenldap/changes.ldif</span><br></pre></td></tr></table></figure>

<h4 id="8-4-config-kdc"><a href="#8-4-config-kdc" class="headerlink" title="8.4 config kdc"></a>8.4 config kdc</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF &gt;/var/kerberos/krb5kdc/kdc.conf</span><br><span class="line">[logging]</span><br><span class="line">    default = FILE:/var/log/kerberos/krb5libs.log</span><br><span class="line">    kdc = FILE:/var/log/kerberos/krb5kdc.log</span><br><span class="line">    admin_server = FILE:/var/log/kerberos/kadmin.log</span><br><span class="line">    </span><br><span class="line">[libdefaults]</span><br><span class="line">    dns_lookup_realm = false</span><br><span class="line">    ticket_lifetime = 24h</span><br><span class="line">    renew_lifetime = 7d</span><br><span class="line">    forwardable = true</span><br><span class="line">    rdns = false</span><br><span class="line">    default_realm = KEVIN.COM</span><br><span class="line">    default_ccache_name = KEYRING:persistent:%&#123;uid&#125;</span><br><span class="line">    </span><br><span class="line">[kdcdefaults]</span><br><span class="line">     kdc_ports = 88</span><br><span class="line">     kdc_tcp_ports = 88</span><br><span class="line">     </span><br><span class="line">[realms]</span><br><span class="line">    KEVIN.COM = &#123;</span><br><span class="line">        kdc = ambari21.kevin.com</span><br><span class="line">        admin_server = ambari21.kevin.com</span><br><span class="line">        database_module = openldap_ldapconf</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">[domain_realm]</span><br><span class="line">    .kevin.com = KEVIN.COM</span><br><span class="line">    kevin.com = KEVIN.COM</span><br><span class="line">    </span><br><span class="line">[dbmodules]</span><br><span class="line">    openldap_ldapconf = &#123;</span><br><span class="line">        db_library = kldap</span><br><span class="line">        ldap_kerberos_container_dn = cn=krbContainer,dc=kevin,dc=com</span><br><span class="line">        ldap_kdc_dn = cn=kdc-srv,dc=kevin,dc=com</span><br><span class="line">        ldap_kadmind_dn = cn=adm-srv,dc=kevin,dc=com</span><br><span class="line">        ldap_service_password_file = /var/kerberos/krb5kdc/service.keyfile</span><br><span class="line">        ldap_servers = ldapi:///</span><br><span class="line">        ldap_conns_per_server = 5</span><br><span class="line">   &#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h4 id="8-5-Generate-password-file"><a href="#8-5-Generate-password-file" class="headerlink" title="8.5 Generate password file"></a>8.5 Generate password file</h4><p>生成 Kerberos 访问 openldap 的密码文件</p>
<p>这里需要输入上面导入的 kerberos 用户密码，然后会在指定目录生成密码文件，Kerberos 通过 kdc 配置文件来读取并使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kdb5_ldap_util stashsrvpw -f /var/kerberos/krb5kdc/service.keyfile &quot;cn=adm-srv,dc=kevin,dc=com&quot; -w 000001</span><br><span class="line">kdb5_ldap_util stashsrvpw -f /var/kerberos/krb5kdc/service.keyfile &quot;cn=kdc-srv,dc=kevin,dc=com&quot; -w 000001 </span><br></pre></td></tr></table></figure>

<h4 id="8-6-init-kdc-db"><a href="#8-6-init-kdc-db" class="headerlink" title="8.6 init kdc db"></a>8.6 init kdc db</h4><p>创建kerberos数据库。这里会数据初始的 kdc 数据库密码。然后会根据 kdc 的配置，在 openldap 中创建 <code>cn=krbContainer,dc=kdc,dc=kevin,dc=com</code></p>
<p>里面就存放的 kerberos 的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kdb5_ldap_util -D cn=ldapadmin,dc=kevin,dc=com -w 000001 -H ldapi:///  create  -r KEVIN.COM</span><br></pre></td></tr></table></figure>

<h4 id="8-7-add-kerberos-user"><a href="#8-7-add-kerberos-user" class="headerlink" title="8.7 add kerberos user"></a>8.7 add kerberos user</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@kdc ~]# kadmin.local</span><br><span class="line">kadmin.local:  addprinc root/admin</span><br><span class="line">kadmin.local:  addprinc user1</span><br><span class="line">kadmin.local:  ktadd -k /var/kerberos/krb5kdc/kadm5.keytab kadmin/admin</span><br><span class="line">kadmin.local:  ktadd -k /var/kerberos/krb5kdc/kadm5.keytab kadmin/changepw</span><br><span class="line">kadmin.local:  exit</span><br></pre></td></tr></table></figure>

<h4 id="8-8-satrt-KDC"><a href="#8-8-satrt-KDC" class="headerlink" title="8.8 satrt KDC"></a>8.8 satrt KDC</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start krb5kdc.service</span><br><span class="line">systemctl enable krb5kdc.service</span><br></pre></td></tr></table></figure>

<p>到这里通过 Apache Directory Studio 查看 Openldap 可以发现  kerberos 数据已经在里面了</p>
<h4 id="8-9-config-kerberos"><a href="#8-9-config-kerberos" class="headerlink" title="8.9 config kerberos"></a>8.9 config kerberos</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF &gt;/etc/krb5.conf</span><br><span class="line">includedir /etc/krb5.conf.d/</span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">    default = FILE:/var/log/kerberos/krb5libs.log</span><br><span class="line">    kdc = FILE:/var/log/kerberos/krb5kdc.log</span><br><span class="line">    admin_server = FILE:/var/log/kerberos/kadmind.log</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">    KEVIN.COM = &#123;</span><br><span class="line">        kdc = kdc.kevin.com</span><br><span class="line">        admin_server = kdc.kevin.com</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">[domain_realm]</span><br><span class="line">    .kevin.com = KEVIN.COM</span><br><span class="line">    kevin.com = KEVIN.COM</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h4 id="8-10-start-Kerberos"><a href="#8-10-start-Kerberos" class="headerlink" title="8.10 start Kerberos"></a>8.10 start Kerberos</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start kadmin.service</span><br><span class="line">systemctl enable kadmin.service</span><br></pre></td></tr></table></figure>

<h4 id="8-11-setup-Kerberos-client"><a href="#8-11-setup-Kerberos-client" class="headerlink" title="8.11 setup Kerberos client"></a>8.11 setup Kerberos client</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install krb5-workstation</span><br><span class="line">cat &lt;&lt;- EOF &gt;/etc/krb5.conf</span><br><span class="line">includedir /etc/krb5.conf.d/</span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">    default = FILE:/var/log/kerberos/krb5libs.log</span><br><span class="line">    kdc = FILE:/var/log/kerberos/krb5kdc.log</span><br><span class="line">    admin_server = FILE:/var/log/kerberos/kadmind.log</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">    KEVIN.COM = &#123;</span><br><span class="line">        kdc = kdc.kevin.com</span><br><span class="line">        admin_server = kdc.kevin.com</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">[domain_realm]</span><br><span class="line">    .kevin.com = KEVIN.COM</span><br><span class="line">    kevin.com = KEVIN.COM</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">kinit -kt user1.keytab user1@TENDATA.COM</span><br></pre></td></tr></table></figure>

<h2 id="Openldap-enable-SASL"><a href="#Openldap-enable-SASL" class="headerlink" title="Openldap enable SASL"></a>Openldap enable SASL</h2><p>暂未配置</p>
<h2 id="Ambari-enable-Kerberos"><a href="#Ambari-enable-Kerberos" class="headerlink" title="Ambari enable Kerberos"></a>Ambari enable Kerberos</h2><p>具体细节参见 <a href="https://docs.hortonworks.com/HDPDocuments/Ambari-2.5.1.0/bk_ambari-security/content/ch_amb_sec_guide.html">Apache Ambari Security</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>ambari</tag>
        <tag>openldap</tag>
        <tag>kerberos</tag>
      </tags>
  </entry>
  <entry>
    <title>连接带有 Kerberos 认证的 Hadoop Hbase Hive Spark</title>
    <url>/2017/11/21/programming/%E8%BF%9E%E6%8E%A5%E5%B8%A6%E6%9C%89%20Kerberos%20%E8%AE%A4%E8%AF%81%E7%9A%84%20Hadoop%20%20HBase%20Spark/</url>
    <content><![CDATA[<p>本文操作环境为使用 Windows 远程连接集群环境，通过代码带入 Kerberos 认证信息操作集群。</p>
<p>项目为 Maven Project，添加依赖仅限于测试连接，如做额外开发可能会缺少依赖。请自行添加</p>
<span id="more"></span>

<h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><ul>
<li>CentOS：7</li>
<li>Ambari：2.5.1.0</li>
<li>HDP：2.6.2.0-205</li>
<li>客户机：Windows 10</li>
</ul>
<h2 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h2><ul>
<li>Kerberos 配置文件。该文件一般位于 Kerberos 服务器的 <code>/etc/krb5.conf</code> 位置。将其下载到本地。</li>
<li>Hadoop 的配置文件。</li>
</ul>
<h2 id="Java-连接-Hadoop"><a href="#Java-连接-Hadoop" class="headerlink" title="Java 连接 Hadoop"></a>Java 连接 Hadoop</h2><p><a href="https://www.2cto.com/kf/201204/126021.html">Hadoop Authentication</a></p>
<p>上面这篇博客讲解了 java 连接带有 Kerberos 的 HDFS 流程。可以看一下。</p>
<p>新建一个 Maven 项目</p>
<p><img src="http://qiniu.iclouds.work/FgvE_RlTJ6YsxhMw7m9lbDSKLPvd.png" alt="maven_project"></p>
<p>添加 HDFS 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HDFS dependences --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将 <code>krb5.conf</code> <code>tendata.keytab</code>  放到项目根目录</p>
<p><img src="http://qiniu.iclouds.work/Fvr3toNl75tVQV6siXCnKq1bdQ_g.png"></p>
<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.LocatedFileStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.RemoteIterator;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HadoopAuth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, <span class="string">&quot;krb5.conf&quot;</span>);</span><br><span class="line">        conf.set(<span class="string">&quot;HadoopAuth.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>);</span><br><span class="line">        conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>, <span class="string">&quot;hdfs://192.168.10.1&quot;</span>);</span><br><span class="line">        UserGroupInformation.setConfiguration(conf);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserGroupInformation.loginUserFromKeytab(<span class="string">&quot;tendata@TENDATA.CN&quot;</span>, <span class="string">&quot;tendata.keytab&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">        <span class="comment">// 传入当前认证用户有操作权限的路径</span></span><br><span class="line">        Path path = <span class="keyword">new</span> Path(<span class="string">&quot;/user/tendata/testdir&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (! fs.exists(path))&#123;</span><br><span class="line">            <span class="keyword">boolean</span> mkdirs = fs.mkdirs(path);</span><br><span class="line">            System.out.println(<span class="string">&quot;mkdir &quot;</span> + mkdirs );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> delete = fs.delete(path, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;delete &quot;</span> + delete);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java-连接-HBase"><a href="#Java-连接-HBase" class="headerlink" title="Java 连接 HBase"></a>Java 连接 HBase</h2><p>添加 HBase 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HBase dependence --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.phoenix/phoenix-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.0-HBase-1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.ClusterStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.ServerName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Admin;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HBaseAuth</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String zNode = <span class="string">&quot;m1.node.hadoop,m2.node.hadoop,m3.node.hadoop&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> String zPort = <span class="string">&quot;2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// krb5.conf 文件位置随意。当不在项目中的时候需要引用绝对路径</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, <span class="string">&quot;krb5.conf&quot;</span>);     <span class="comment">// 配置系统使用 krb5.conf</span></span><br><span class="line"></span><br><span class="line">        conf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>);     <span class="comment">// 指定 HDFS 安全认证方式为 Kerberos。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的对 hdfs-site.xml  的配置都可以在集群配置文件中找得到的</span></span><br><span class="line">        conf.set(<span class="string">&quot;hbase.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>);      <span class="comment">// 指定 HBase 安全认证方式为 Kerberos。</span></span><br><span class="line">        conf.set(<span class="string">&quot;hbase.master.kerberos.principal&quot;</span>, <span class="string">&quot;hbase/_HOST@TENDATA.CN&quot;</span>);</span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, zPort);     <span class="comment">// Zookeeper 端口</span></span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, zNode);      <span class="comment">// Zookeeper 节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在查看 Zookeeper 根目录信息会有两个 hbase 开头的目录</span></span><br><span class="line"><span class="comment">        /hbase-secure   在配置安全集群下，HBase 会使用这个</span></span><br><span class="line"><span class="comment">        /hbase-unsecure 在没有配置安全集群下，使用此目录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        conf.set(<span class="string">&quot;zookeeper.znode.parent&quot;</span>, <span class="string">&quot;/hbase-secure&quot;</span>);    <span class="comment">// 指定 HBase 在 Zookeeper 目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过hadoop security下中的 UserGroupInformation类来实现使用keytab文件登录</span></span><br><span class="line"></span><br><span class="line">        UserGroupInformation.setConfiguration(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置登录的kerberos principal和对应的 keytab 文件，其中 keytab 文件需要kdc管理员生成给到开发人员</span></span><br><span class="line">        <span class="comment">// 文件如果没法放在项目目录中，则需要引用路径</span></span><br><span class="line">        UserGroupInformation.loginUserFromKeytab(<span class="string">&quot;tendata@TENDATA.CN&quot;</span>, <span class="string">&quot;tendata.keytab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与HBase数据库的连接对象</span></span><br><span class="line">        Connection connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">        <span class="comment">// 数据库元数据操作对象</span></span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------获取集群信息-----------------&quot;</span>);</span><br><span class="line">        ClusterStatus clusterStatus = admin.getClusterStatus();</span><br><span class="line">        String id = clusterStatus.getClusterId();</span><br><span class="line">        String hbaseVersion = clusterStatus.getHBaseVersion();</span><br><span class="line">        ServerName master = clusterStatus.getMaster();</span><br><span class="line">        System.out.println(<span class="string">&quot;id:\t&quot;</span> + id +<span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;version:\t&quot;</span> + hbaseVersion + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;master:\t&quot;</span> + master</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java-连接-Hive"><a href="#Java-连接-Hive" class="headerlink" title="Java 连接 Hive"></a>Java 连接 Hive</h2><p>添加 Hive 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Hive dependence --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-common --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveAuth</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverName = <span class="string">&quot;org.apache.hive.jdbc.HiveDriver&quot;</span>;   <span class="comment">// Hive JDBC 驱动</span></span><br><span class="line">    <span class="comment">// url ，注意后面带有 principal</span></span><br><span class="line">    <span class="comment">// 这里使用 hive2 连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">&quot;jdbc:hive2://m1.node.hadoop:10000/default;principal=hive/m1.node.hadoop@TENDATA.CN;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">&quot;hive&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// krb5.conf 文件位置随意。当不在项目中的时候需要引用绝对路径</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, <span class="string">&quot;krb5.conf&quot;</span>);     <span class="comment">// 配置系统使用 krb5.conf</span></span><br><span class="line"></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        conf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>); <span class="comment">// 指定 hadoop 安全认证方式为 Kerberos。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过hadoop security下中的 UserGroupInformation类来实现使用keytab文件登录</span></span><br><span class="line">        UserGroupInformation.setConfiguration(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置登录的 kerberos principal和对应的 keytab 文件，其中 keytab 文件需要kdc管理员生成给到开发人员</span></span><br><span class="line">        <span class="comment">// 文件如果没法放在项目目录中，则需要引用路径</span></span><br><span class="line">        UserGroupInformation.loginUserFromKeytab(<span class="string">&quot;tendata@TENDATA.CN&quot;</span>, <span class="string">&quot;tendata.keytab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class.forName(driverName);</span><br><span class="line">        Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ResultSet res = stmt.executeQuery(<span class="string">&quot;show databases&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java-连接-Spark"><a href="#Java-连接-Spark" class="headerlink" title="Java 连接 Spark"></a>Java 连接 Spark</h2><p>使用 Java 连接 Spark 应该是少引用了某个参数，导致指定的安全认证参数传不进去。一直认定是 SIMPLE。</p>
<p>索性直接引入 hadoop 的配置文件。</p>
<p>在 Resource 目录下放入 <code>core-site.xml</code> <code>yarn-site.xml</code> 两个文件。</p>
<p><img src="http://qiniu.iclouds.work/FqF9JVuTAUIj3RWpkc0lP59QtHIa.png"></p>
<p>添加 Spark 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spark dependence --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparkAuth</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 这里要给系统加载 krb5 的配置，否则系统会使用默认 remal</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, <span class="string">&quot;krb5.conf&quot;</span>);</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">// 下面的对 hdfs-site.xml  的配置都可以在集群配置文件中找得到的</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>);     <span class="comment">// 指定 hadoop 安全认证方式为 Kerberos。</span></span><br><span class="line">        configuration.set(<span class="string">&quot;dfs.namenode.kerberos.principal.pattern&quot;</span>, <span class="string">&quot;nn/*@TENDATA.CN&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;fs.defaultFS&quot;</span>, <span class="string">&quot;hdfs://192.168.10.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过hadoop security下中的 UserGroupInformation类来实现使用keytab文件登录</span></span><br><span class="line">        UserGroupInformation.setConfiguration(configuration);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置登录的kerberos principal和对应的 keytab 文件，其中 keytab 文件需要kdc管理员生成给到开发人员</span></span><br><span class="line">            <span class="comment">// 文件如果没法放在项目目录中，则需要引用路径</span></span><br><span class="line">            UserGroupInformation.loginUserFromKeytab(<span class="string">&quot;tendata@TENDATA.CN&quot;</span>, <span class="string">&quot;tendata.keytab&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">&quot;Test_Java_E_Kevin&quot;</span>).setMaster(<span class="string">&quot;local&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line"></span><br><span class="line">        JavaRDD&lt;String&gt; stringJavaRDD = sc.textFile(<span class="string">&quot;hdfs://m1.node.hadoop:8020/user/tendata/tmp/tmp-kevin/example/data/example_data_id_name.txt&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; collect = stringJavaRDD.collect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String i : collect) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Scala-连接-Spark"><a href="#Scala-连接-Spark" class="headerlink" title="Scala 连接 Spark"></a>Scala 连接 Spark</h2><p>针对于 Scala Spark 的环境请自行配置，具体连接代码如下。</p>
<p>需要在 Resource 目录下引用前面提到的两个配置文件</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.<span class="type">UserGroupInformation</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SQLContext</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkContext</span>, <span class="type">SparkConf</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Put</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="type">System</span>.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, <span class="string">&quot;krb5.conf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">Configuration</span>()</span><br><span class="line">    conf.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>)</span><br><span class="line">    conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>, <span class="string">&quot;hdfs://192.168.10.1&quot;</span>)</span><br><span class="line">    conf.set(<span class="string">&quot;dfs.namenode.kerberos.principal.pattern&quot;</span>, <span class="string">&quot;nn/*@TENDATA.CN&quot;</span>)</span><br><span class="line">    <span class="type">UserGroupInformation</span>.setConfiguration(conf)</span><br><span class="line">    <span class="type">UserGroupInformation</span>.loginUserFromKeytab(<span class="string">&quot;tendata@TENDATA.CN&quot;</span>, <span class="string">&quot;tendata.keytab&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;Test_SparkReadHDFS_Kevin&quot;</span>).setMaster(<span class="string">&quot;local&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="keyword">val</span> scRDD = sc.textFile(<span class="string">&quot;hdfs://m1.node.hadoop:8020/user/tendata/tmp/tmp-kevin/example/data/example_data_id_name.txt&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    scRDD.collect().foreach(x =&gt; println(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h2><h5 id="1-Can’t-get-Kerberos-realm"><a href="#1-Can’t-get-Kerberos-realm" class="headerlink" title="1.  Can’t get Kerberos realm"></a>1.  Can’t get Kerberos realm</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Can&#x27;t get Kerberos realm</span><br><span class="line">    at org.apache.hadoop.security.HadoopKerberosName.setConfiguration(HadoopKerberosName.java:65)</span><br><span class="line">    at org.apache.hadoop.security.UserGroupInformation.initialize(UserGroupInformation.java:249)</span><br><span class="line">    at org.apache.hadoop.security.UserGroupInformation.setConfiguration(UserGroupInformation.java:285)</span><br><span class="line">    at HdfsConnKerberos.HDFSClient.main(HDFSClient.java:43)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">    at org.apache.hadoop.security.authentication.util.KerberosUtil.getDefaultRealm(KerberosUtil.java:84)</span><br><span class="line">    at org.apache.hadoop.security.HadoopKerberosName.setConfiguration(HadoopKerberosName.java:63)</span><br><span class="line">    ... 8 more</span><br><span class="line">Caused by: KrbException: Cannot locate default realm</span><br><span class="line">    at sun.security.krb5.Config.getDefaultRealm(Config.java:1006)</span><br><span class="line">    ... 14 more</span><br><span class="line">Caused by: KrbException: Generic error (description in e-text) (60) - Unable to locate Kerberos realm</span><br><span class="line">    at sun.security.krb5.Config.getRealmFromDNS(Config.java:1102)</span><br><span class="line">    at sun.security.krb5.Config.getDefaultRealm(Config.java:987)</span><br><span class="line">    ... 14 more</span><br></pre></td></tr></table></figure>

<p>主要几点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: KrbException: Cannot locate default realm</span><br><span class="line"></span><br><span class="line">Caused by: KrbException: Generic error (description in e-text) (60) - Unable to locate Kerberos realm</span><br></pre></td></tr></table></figure>

<p>主要原因在代码中没有添加 <code>krb5.conf</code> 这个配置，所以检查这个配置文件的是否存在和文件内容的正确性</p>
<h5 id="2-org-apache-hadoop-hbase-exceptions-ConnectionClosingException-Call-to-m1-node-hadoop-192-168-10-1-16000-failed"><a href="#2-org-apache-hadoop-hbase-exceptions-ConnectionClosingException-Call-to-m1-node-hadoop-192-168-10-1-16000-failed" class="headerlink" title="2. org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Call to m1.node.hadoop/192.168.10.1:16000 failed"></a>2. org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Call to m1.node.hadoop/192.168.10.1:16000 failed</h5><p>读取 HBase 信息，连接到 HBase 没反应，重复出现下面的信息。</p>
<p>Call exception, tries=10, retries=31, started=48283 ms ago, cancelled=false, msg=com.google.protobuf.ServiceException: org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Call to m1.node.hadoop/192.168.10.1:16000 failed on local exception: org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Connection to m1.node.hadoop/192.168.10.1:16000 is closing. Call id=10, waitTime=1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017-10-13 15:26:02,021 INFO  [main] zookeeper.ZooKeeper (ZooKeeper.java:&lt;init&gt;(438)) - Initiating client connection, connectString=m1.node.hadoop:2181,m2.node.hadoop:2181,m3.node.hadoop:2181 sessionTimeout=180000 watcher=org.apache.hadoop.hbase.zookeeper.PendingWatcher@65b3f4a4</span><br><span class="line">2017-10-13 15:26:02,077 INFO  [main-SendThread(m3.node.hadoop:2181)] zookeeper.ClientCnxn (ClientCnxn.java:logStartConnect(1019)) - Opening socket connection to server m3.node.hadoop/192.168.10.3:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">2017-10-13 15:26:02,079 INFO  [main-SendThread(m3.node.hadoop:2181)] zookeeper.ClientCnxn (ClientCnxn.java:primeConnection(864)) - Socket connection established, initiating session, client: /192.168.2.199:59415, server: m3.node.hadoop/192.168.10.3:2181</span><br><span class="line">2017-10-13 15:26:02,104 INFO  [main-SendThread(m3.node.hadoop:2181)] zookeeper.ClientCnxn (ClientCnxn.java:onConnected(1279)) - Session establishment complete on server m3.node.hadoop/192.168.10.3:2181, sessionid = 0x35efece455700dd, negotiated timeout = 40000</span><br><span class="line">2017-10-13 15:26:05,349 WARN  [main]  (NetworkAddressUtils.java:getLocalIpAddress(389)) - Your hostname, DESKTOP-5KM5T43 resolves to a loopback/non-reachable address: fe80:0:0:0:3433:e0f1:9aa7:18da%net4, but we couldn&#x27;t find any external IP address!</span><br><span class="line">2017-10-13 15:26:06,524 WARN  [main] shortcircuit.DomainSocketFactory (DomainSocketFactory.java:&lt;init&gt;(117)) - The short-circuit local reads feature cannot be used because UNIX Domain sockets are not available on Windows.</span><br><span class="line">2017-10-13 15:26:54,855 INFO  [main] client.RpcRetryingCaller (RpcRetryingCaller.java:callWithRetries(146)) - Call exception, tries=10, retries=31, started=48283 ms ago, cancelled=false, msg=com.google.protobuf.ServiceException: org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Call to m1.node.hadoop/192.168.10.1:16000 failed on local exception: org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Connection to m1.node.hadoop/192.168.10.1:16000 is closing. Call id=10, waitTime=1 </span><br><span class="line">2017-10-13 15:27:15,012 INFO  [main] client.RpcRetryingCaller (RpcRetryingCaller.java:callWithRetries(146)) - Call exception, tries=11, retries=31, started=68440 ms ago, cancelled=false, msg=com.google.protobuf.ServiceException: org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Call to m1.node.hadoop/192.168.10.1:16000 failed on local exception: org.apache.hadoop.hbase.exceptions.ConnectionClosingException: Connection to m1.node.hadoop/192.168.10.1:16000 is closing. Call id=11, waitTime=1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种情况是在创建 Configuration 的格式不对造成。</p>
<p>下面两种获取 Configuration 对象是不同的。</p>
<p>如果使用第一种 conf 操作 HBase，则会出现上述错误。</p>
<p>而正确的创建方式应该是第二种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">Configuration conf = HBaseConfiguration.create();</span><br></pre></td></tr></table></figure>

<h5 id="3-org-apache-hadoop-hbase-client-RpcRetryingCaller-Call-exception-tries-11-retries-35-started-48413-ms-ago-cancelled-false-msg"><a href="#3-org-apache-hadoop-hbase-client-RpcRetryingCaller-Call-exception-tries-11-retries-35-started-48413-ms-ago-cancelled-false-msg" class="headerlink" title="3.  [org.apache.hadoop.hbase.client.RpcRetryingCaller] - Call exception, tries=11, retries=35, started=48413 ms ago, cancelled=false, msg="></a>3.  [org.apache.hadoop.hbase.client.RpcRetryingCaller] - Call exception, tries=11, retries=35, started=48413 ms ago, cancelled=false, msg=</h5><p>连接 HBase 没有反应，重复出现 Call exception</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017-11-21 17:45:11,982 INFO [org.apache.zookeeper.ZooKeeper] - Initiating client connection, connectString=m1.node.hadoop:2181,m2.node.hadoop:2181,m3.node.hadoop:2181 sessionTimeout=90000 watcher=hconnection-0x66d189790x0, quorum=m1.node.hadoop:2181,m2.node.hadoop:2181,m3.node.hadoop:2181, baseZNode=/hbase-secure</span><br><span class="line">2017-11-21 17:45:12,049 INFO [org.apache.zookeeper.ClientCnxn] - Opening socket connection to server m2.node.hadoop/192.168.10.2:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">2017-11-21 17:45:12,050 INFO [org.apache.zookeeper.ClientCnxn] - Socket connection established to m2.node.hadoop/192.168.10.2:2181, initiating session</span><br><span class="line">2017-11-21 17:45:12,065 INFO [org.apache.zookeeper.ClientCnxn] - Session establishment complete on server m2.node.hadoop/192.168.10.2:2181, sessionid = 0x25fdc95c59d001d, negotiated timeout = 40000</span><br><span class="line">2017-11-21 17:45:15,386 WARN [] - Your hostname, DESKTOP-5KM5T43 resolves to a loopback/non-reachable address: fe80:0:0:0:3c56:c61d:8b18:745%net4, but we couldn&#x27;t find any external IP address!</span><br><span class="line">---------------获取集群信息-----------------</span><br><span class="line">2017-11-21 17:45:54,986 INFO [org.apache.hadoop.hbase.client.RpcRetryingCaller] - Call exception, tries=10, retries=35, started=38401 ms ago, cancelled=false, msg=</span><br><span class="line">2017-11-21 17:46:04,998 INFO [org.apache.hadoop.hbase.client.RpcRetryingCaller] - Call exception, tries=11, retries=35, started=48413 ms ago, cancelled=false, msg=</span><br></pre></td></tr></table></figure>

<p>这是没有指定 HBase 安全认证导致的。</p>
<p>增加如下配置即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conf.set(<span class="string">&quot;hbase.security.authentication&quot;</span>, <span class="string">&quot;kerberos&quot;</span>);      <span class="comment">// 指定 HBase 安全认证方式为 Kerberos。</span></span><br></pre></td></tr></table></figure>

<h5 id="4-java-io-IOException-java-lang-reflect-InvocationTargetException"><a href="#4-java-io-IOException-java-lang-reflect-InvocationTargetException" class="headerlink" title="4. java.io.IOException: java.lang.reflect.InvocationTargetException"></a>4. java.io.IOException: java.lang.reflect.InvocationTargetException</h5><p>连接 HBase 出现 <code>org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory</code> 类找不到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.IOException: java.lang.reflect.InvocationTargetException</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory.java:<span class="number">240</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory.java:<span class="number">218</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory.java:<span class="number">119</span>)</span><br><span class="line">    at HBaseAuth.main(HBaseAuth.java:<span class="number">33</span>)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">422</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory.java:<span class="number">238</span>)</span><br><span class="line">    ... <span class="number">8</span> more</span><br><span class="line">Caused by: java.lang.UnsupportedOperationException: Unable to find org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory</span><br><span class="line">    at org.apache.hadoop.hbase.util.ReflectionUtils.instantiateWithCustomCtor(ReflectionUtils.java:<span class="number">36</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.ipc.RpcControllerFactory.instantiate(RpcControllerFactory.java:<span class="number">58</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionManager$HConnectionImplementation.createAsyncProcess(ConnectionManager.java:<span class="number">2256</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionManager$HConnectionImplementation.&lt;init&gt;(ConnectionManager.java:<span class="number">691</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.client.ConnectionManager$HConnectionImplementation.&lt;init&gt;(ConnectionManager.java:<span class="number">631</span>)</span><br><span class="line">    ... <span class="number">13</span> more</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">331</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">    at java.lang.Class.forName0(Native Method)</span><br><span class="line">    at java.lang.Class.forName(Class.java:<span class="number">264</span>)</span><br><span class="line">    at org.apache.hadoop.hbase.util.ReflectionUtils.instantiateWithCustomCtor(ReflectionUtils.java:<span class="number">32</span>)</span><br><span class="line">    ... <span class="number">17</span> more</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/itboys/p/6862366.html">https://www.cnblogs.com/itboys/p/6862366.html</a></p>
<ol>
<li><p>检查应用开发工程的配置文件hbase-site.xml中是否包含配置项hbase.rpc.controllerfactory.class。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;name&gt;hbase.rpc.controllerfactory.class&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory&lt;/value&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果当前的应用开发工程配置项中包含该配置项，则应用开发程序还需要引入Jar包“phoenix-core-4.4.0-HBase-1.0.jar”。此Jar包可以从HBase客户端安装目录下的“HBase/hbase/lib”获取。</p>
</li>
<li><p>如果不想引入该Jar包，请将应用开发工程的配置文件“hbase-site.xml”中的配置“hbase.rpc.controllerfactory.class”删除掉。</p>
</li>
</ol>
<h5 id="5-SIMPLE-authentication-is-not-enabled-Available-TOKEN-KERBEROS"><a href="#5-SIMPLE-authentication-is-not-enabled-Available-TOKEN-KERBEROS" class="headerlink" title="5. SIMPLE authentication is not enabled.  Available:[TOKEN, KERBEROS]"></a>5. SIMPLE authentication is not enabled.  Available:[TOKEN, KERBEROS]</h5><p>这个问题我只在使用 Spark 的情况下出现过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.apache.hadoop.security.AccessControlException: SIMPLE authentication is not enabled.  Available:[TOKEN, KERBEROS]</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)</span><br><span class="line">    at org.apache.hadoop.ipc.RemoteException.instantiateException(RemoteException.java:106)</span><br><span class="line">    at org.apache.hadoop.ipc.RemoteException.unwrapRemoteException(RemoteException.java:73)</span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient.getFileInfo(DFSClient.java:2110)</span><br><span class="line">    at org.apache.hadoop.hdfs.DistributedFileSystem$22.doCall(DistributedFileSystem.java:1305)</span><br><span class="line">    at org.apache.hadoop.hdfs.DistributedFileSystem$22.doCall(DistributedFileSystem.java:1301)</span><br><span class="line">    at org.apache.hadoop.fs.FileSystemLinkResolver.resolve(FileSystemLinkResolver.java:81)</span><br><span class="line">    at org.apache.hadoop.hdfs.DistributedFileSystem.getFileStatus(DistributedFileSystem.java:1317)</span><br><span class="line">    at org.apache.hadoop.fs.Globber.getFileStatus(Globber.java:57)</span><br><span class="line">    at org.apache.hadoop.fs.Globber.glob(Globber.java:252)</span><br><span class="line">    at org.apache.hadoop.fs.FileSystem.globStatus(FileSystem.java:1674)</span><br><span class="line">    at org.apache.hadoop.mapred.FileInputFormat.singleThreadedListStatus(FileInputFormat.java:259)</span><br><span class="line">    at org.apache.hadoop.mapred.FileInputFormat.listStatus(FileInputFormat.java:229)</span><br><span class="line">    at org.apache.hadoop.mapred.FileInputFormat.getSplits(FileInputFormat.java:315)</span><br><span class="line">    at org.apache.spark.rdd.HadoopRDD.getPartitions(HadoopRDD.scala:200)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:248)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:246)</span><br><span class="line">    at scala.Option.getOrElse(Option.scala:121)</span><br><span class="line">    at org.apache.spark.rdd.RDD.partitions(RDD.scala:246)</span><br><span class="line">    at org.apache.spark.rdd.MapPartitionsRDD.getPartitions(MapPartitionsRDD.scala:35)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:248)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:246)</span><br><span class="line">    at scala.Option.getOrElse(Option.scala:121)</span><br><span class="line">    at org.apache.spark.rdd.RDD.partitions(RDD.scala:246)</span><br><span class="line">    at org.apache.spark.SparkContext.runJob(SparkContext.scala:1911)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$foreach$1.apply(RDD.scala:875)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$foreach$1.apply(RDD.scala:873)</span><br><span class="line">    at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)</span><br><span class="line">    at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)</span><br><span class="line">    at org.apache.spark.rdd.RDD.withScope(RDD.scala:358)</span><br><span class="line">    at org.apache.spark.rdd.RDD.foreach(RDD.scala:873)</span><br><span class="line">    at HDFS.SparkHDFS$.main(SparkHDFS.scala:43)</span><br><span class="line">    at HDFS.SparkHDFS.main(SparkHDFS.scala)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br><span class="line">Caused by: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.AccessControlException): SIMPLE authentication is not enabled.  Available:[TOKEN, KERBEROS]</span><br><span class="line">    at org.apache.hadoop.ipc.Client.call(Client.java:1475)</span><br><span class="line">    at org.apache.hadoop.ipc.Client.call(Client.java:1412)</span><br><span class="line">    at org.apache.hadoop.ipc.ProtobufRpcEngine$Invoker.invoke(ProtobufRpcEngine.java:229)</span><br><span class="line">    at com.sun.proxy.$Proxy20.getFileInfo(Unknown Source)</span><br><span class="line">    at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolTranslatorPB.getFileInfo(ClientNamenodeProtocolTranslatorPB.java:771)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:191)</span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:102)</span><br><span class="line">    at com.sun.proxy.$Proxy21.getFileInfo(Unknown Source)</span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient.getFileInfo(DFSClient.java:2108)</span><br><span class="line">    ... 34 more</span><br></pre></td></tr></table></figure>

<p>直接在 Resource 目录下加入 <code>core-site.xml</code> 配置文件即可。</p>
<p>当人加入了上述配置文件后，重新运行又会出现下面的错误</p>
<h5 id="6-Can’t-get-Master-Kerberos-principal-for-use-as-renewer"><a href="#6-Can’t-get-Master-Kerberos-principal-for-use-as-renewer" class="headerlink" title="6.  Can’t get Master Kerberos principal for use as renewer"></a>6.  Can’t get Master Kerberos principal for use as renewer</h5><p>记不得这个错误有没有在其他地方出现过了。反正现在在使用 Spark 的时候出现了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.IOException: Can&#x27;t get Master Kerberos principal for use as renewer</span><br><span class="line">    at org.apache.hadoop.mapreduce.security.TokenCache.obtainTokensForNamenodesInternal(TokenCache.java:116)</span><br><span class="line">    at org.apache.hadoop.mapreduce.security.TokenCache.obtainTokensForNamenodesInternal(TokenCache.java:100)</span><br><span class="line">    at org.apache.hadoop.mapreduce.security.TokenCache.obtainTokensForNamenodes(TokenCache.java:80)</span><br><span class="line">    at org.apache.hadoop.mapred.FileInputFormat.listStatus(FileInputFormat.java:205)</span><br><span class="line">    at org.apache.hadoop.mapred.FileInputFormat.getSplits(FileInputFormat.java:313)</span><br><span class="line">    at org.apache.spark.rdd.HadoopRDD.getPartitions(HadoopRDD.scala:202)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:239)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:237)</span><br><span class="line">    at scala.Option.getOrElse(Option.scala:121)</span><br><span class="line">    at org.apache.spark.rdd.RDD.partitions(RDD.scala:237)</span><br><span class="line">    at org.apache.spark.rdd.MapPartitionsRDD.getPartitions(MapPartitionsRDD.scala:35)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:239)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:237)</span><br><span class="line">    at scala.Option.getOrElse(Option.scala:121)</span><br><span class="line">    at org.apache.spark.rdd.RDD.partitions(RDD.scala:237)</span><br><span class="line">    at org.apache.spark.SparkContext.runJob(SparkContext.scala:1929)</span><br><span class="line">    at org.apache.spark.rdd.RDD$$anonfun$collect$1.apply(RDD.scala:927)</span><br><span class="line">    at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:150)</span><br><span class="line">    at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:111)</span><br><span class="line">    at org.apache.spark.rdd.RDD.withScope(RDD.scala:316)</span><br><span class="line">    at org.apache.spark.rdd.RDD.collect(RDD.scala:926)</span><br><span class="line">    at org.apache.spark.api.java.JavaRDDLike$class.collect(JavaRDDLike.scala:339)</span><br><span class="line">    at org.apache.spark.api.java.AbstractJavaRDDLike.collect(JavaRDDLike.scala:46)</span><br><span class="line">    at SparkAuth.main(SparkAuth.java:43)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>在 Resource 目录下引入 <code>yarn-site.xml</code> 配置文件</p>
<p><strong>针对前两个错误，主要在 Spark 中出现。本人猜测，可能是因为在 Windows 端运行 local 模式程序的时候，本地作为 Driver，当 Executor 端 真正去访问 HDFS 中的资源的时候， Executor 并没有拿到认证身份。所以，在加入配置文件后， Executor 端会通过配置去相应位置使用 keytab 获取 kgt ，然后正常访问集群中的资源。</strong></p>
<blockquote>
<p>Update 2020-04-17 16:22:00</p>
</blockquote>
<p>在开发端远程提交 mapreduce 任务的时候同样出现了这个问题。在此确认是由于 yarn 的认证问题。</p>
<p>解决方案：</p>
<p>增加 <code>yarn</code> 相关 principal。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configuration.set(<span class="string">&quot;yarn.nodemanager.principal&quot;</span>, <span class="string">&quot;nm/_HOST@TENDATA.CN&quot;</span>);</span><br><span class="line">configuration.set(<span class="string">&quot;yarn.resourcemanager.principal&quot;</span>, <span class="string">&quot;rm/_HOST@TENDATA.CN&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Secure-IO-is-not-possible-without-native-code-extensions"><a href="#Secure-IO-is-not-possible-without-native-code-extensions" class="headerlink" title="Secure IO is not possible without native code extensions."></a>Secure IO is not possible without native code extensions.</h5><p>运行 mapreduce 任务，出现如下问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Exception: org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in localfetcher#1</span><br><span class="line">    at org.apache.hadoop.mapred.LocalJobRunner$Job.runTasks(LocalJobRunner.java:492)</span><br><span class="line">    at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:559)</span><br><span class="line">Caused by: org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in localfetcher#1</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.Shuffle.run(Shuffle.java:134)</span><br><span class="line">    at org.apache.hadoop.mapred.ReduceTask.run(ReduceTask.java:377)</span><br><span class="line">    at org.apache.hadoop.mapred.LocalJobRunner$Job$ReduceTaskRunnable.run(LocalJobRunner.java:347)</span><br><span class="line">    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.lang.ExceptionInInitializerError</span><br><span class="line">    at org.apache.hadoop.mapred.SpillRecord.&lt;init&gt;(SpillRecord.java:71)</span><br><span class="line">    at org.apache.hadoop.mapred.SpillRecord.&lt;init&gt;(SpillRecord.java:62)</span><br><span class="line">    at org.apache.hadoop.mapred.SpillRecord.&lt;init&gt;(SpillRecord.java:57)</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.LocalFetcher.copyMapOutput(LocalFetcher.java:125)</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.LocalFetcher.doCopy(LocalFetcher.java:103)</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.LocalFetcher.run(LocalFetcher.java:86)</span><br><span class="line">Caused by: java.lang.RuntimeException: Secure IO is not possible without native code extensions.</span><br><span class="line">    at org.apache.hadoop.io.SecureIOUtils.&lt;clinit&gt;(SecureIOUtils.java:71)</span><br><span class="line">    ... 6 more</span><br><span class="line">2020-04-17 20:16</span><br></pre></td></tr></table></figure>

<p>这个问题是由于没有使用 <code>Tative library</code> 导致的，在程序运行第一行一般会有个警告 <code>Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</code><br>这是没有加载动态库。一般情况下 Hadoop 的二进制报已经包含了，只是没有在系统中加载。</p>
<p>动态库在 <code>$HADOOP_HOME/lib/native</code> 里面，没有的要去找一下，或者自己编译。</p>
<p>有了动态库还需要在系统中配置，推荐是配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HADOOP_COMMON_LIB_NATIVE_DIR</span><br></pre></td></tr></table></figure>

<p>环境变量生效后就可以看到警告消除，而且程序也不会出现上面提到的问题啦。</p>
<h5 id="Exceeded-MAX-FAILED-UNIQUE-FETCHES-bailing-out"><a href="#Exceeded-MAX-FAILED-UNIQUE-FETCHES-bailing-out" class="headerlink" title="Exceeded MAX_FAILED_UNIQUE_FETCHES; bailing-out"></a>Exceeded MAX_FAILED_UNIQUE_FETCHES; bailing-out</h5><p>这个问题是在使用了 Kerberos 认证的时候出现的，如果没有使用认证也出现了请参考 <a href="https://stackoverflow.com/questions/24066128/hadoop-error-in-shuffle-in-fetcher-exceeded-max-failed-unique-fetches">Hadoop error in shuffle in fetcher: Exceeded MAX_FAILED_UNIQUE_FETCHES</a> 解决。</p>
<p>出现这个问题是在集群客户端使用 <code>yarn jar demo.jar</code> 在集群中运行 mapreduce 任务的时候报错了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in fetcher#30</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.Shuffle.run(Shuffle.java:134)</span><br><span class="line">    at org.apache.hadoop.mapred.ReduceTask.run(ReduceTask.java:377)</span><br><span class="line">    at org.apache.hadoop.mapred.YarnChild$2.run(YarnChild.java:174)</span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">    at javax.security.auth.Subject.doAs(Subject.java:422)</span><br><span class="line">    at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1730)</span><br><span class="line">    at org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:168)</span><br><span class="line">Caused by: java.io.IOException: Exceeded MAX_FAILED_UNIQUE_FETCHES; bailing-out.</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.ShuffleSchedulerImpl.checkReducerHealth(ShuffleSchedulerImpl.java:396)</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.ShuffleSchedulerImpl.copyFailed(ShuffleSchedulerImpl.java:311)</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyFromHost(Fetcher.java:361)</span><br><span class="line">    at org.apache.hadoop.mapreduce.task.reduce.Fetcher.run(Fetcher.java:198)</span><br></pre></td></tr></table></figure>

<p>当时想到运行 mapreduce 任务需要增加相关认证信息，但是没有加完整。完整认证代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Auth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String keytab;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Auth</span><span class="params">(String keytab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keytab = keytab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authorization</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.security.krb5.conf&quot;</span>, <span class="string">&quot;/etc/krb5.conf&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;hadoop.security.authentication&quot;</span>, <span class="string">&quot;Kerberos&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;fs.defaultFS&quot;</span>, <span class="string">&quot;hdfs://m1.node.hadoop&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;dfs.namenode.kerberos.principal.pattern&quot;</span>, <span class="string">&quot;nn/*@TENDATA.CN&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;yarn.nodemanager.principal&quot;</span>, <span class="string">&quot;nm/_HOST@TENDATA.CN&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;yarn.resourcemanager.principal&quot;</span>, <span class="string">&quot;rm/_HOST@TENDATA.CN&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;yarn.nodemanager.webapp.spnego-principal&quot;</span>, <span class="string">&quot;HTTP/_HOST@TENDATA.CN&quot;</span>);     <span class="comment">// 集群运行的时候一定要加，在执行 shuffle 的时候会在集群间交换数据</span></span><br><span class="line">        configuration.set(<span class="string">&quot;yarn.resourcemanager.webapp.spnego-principal&quot;</span>, <span class="string">&quot;HTTP/_HOST@TENDATA.CN&quot;</span>); <span class="comment">// 这也也要加上</span></span><br><span class="line">        UserGroupInformation.setConfiguration(configuration);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserGroupInformation.setConfiguration(configuration);</span><br><span class="line">            UserGroupInformation.loginUserFromKeytab(<span class="string">&quot;whg@TENDATA.CN&quot;</span>, <span class="keyword">this</span>.keytab);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如上，在运行 mapreduce 任务的时候除了增加 <code>yarn.nodemanager.principal</code> 和 <code>yarn.resourcemanager.principal</code> 的配置还要增加 <code>yarn.nodemanager.webapp.spnego-principal</code><br> 和 <code>yarn.resourcemanager.webapp.spnego-principal</code> 的配置，否则集群间交换数据会报上面的问题。在开发环境即 local 模式运行的时候可以不用后面两个。</p>
<h5 id="7-终极解决问题"><a href="#7-终极解决问题" class="headerlink" title="7. 终极解决问题"></a>7. 终极解决问题</h5><p>在 Resource 目录引入所使用的服务的所有配置。比如 hadoop 的四个配置文件。</p>
<p>然后使用代码直接加载配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configuration.addResource(<span class="string">&quot;core-site.xml&quot;</span>);</span><br><span class="line">configuration.addResource(<span class="string">&quot;hdfs-site.xml&quot;</span>);</span><br><span class="line">configuration.addResource(<span class="string">&quot;mapred-site.xml&quot;</span>);</span><br><span class="line">configuration.addResource(<span class="string">&quot;yarn-site.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>kerberos</tag>
        <tag>hadoop</tag>
        <tag>hbase</tag>
        <tag>hive</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Python PEP8 编码规范</title>
    <url>/2019/01/01/programming/python/Python%20PEP8%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>原文链接：<a href="http://legacy.python.org/dev/peps/pep-0008/">http://legacy.python.org/dev/peps/pep-0008/</a></p>
<p>参考翻译：<a href="https://blog.csdn.net/ratsniper/article/details/78954852">https://blog.csdn.net/ratsniper/article/details/78954852</a></p>
<p>本文最后更新时间：2018-11-22</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">Item</th>
<th>Deatil</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PEP</td>
<td>8</td>
</tr>
<tr>
<td align="center">Title</td>
<td>Style Guide for Python Code</td>
</tr>
<tr>
<td align="center">Version</td>
<td>c451868df657</td>
</tr>
<tr>
<td align="center">Last-Modified</td>
<td>2016-06-08 10:43:53 -0400 (Wed, 08 Jun 2016)</td>
</tr>
<tr>
<td align="center">Author</td>
<td>Guido van Rossum &lt;guido at python.org&gt;, Barry Warsaw &lt;barry at python.org&gt;, Nick Coghlan &lt;ncoghlan at gmail.com&gt;</td>
</tr>
<tr>
<td align="center">Status</td>
<td>Active</td>
</tr>
<tr>
<td align="center">Type</td>
<td>Process</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td>text/x-rst</td>
</tr>
<tr>
<td align="center">Created</td>
<td>05-Jul-2001</td>
</tr>
<tr>
<td align="center">Post-History</td>
<td>05-Jul-2001, 01-Aug-2013</td>
</tr>
</tbody></table>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文提供的Python代码编码规范基于Python主要发行版本的标准库。Python的C语言实现的C代码规范请查看相应的PEP指南[^1]。</p>
<p>这篇文档以及<a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a>（文档字符串的规范）改编自Guido原始的《Python Style Guide》一文，同时添加了一些来自Barry的风格指南[^2]。</p>
<p>这篇规范指南随着时间的推移而逐渐演变，随着语言本身的变化，过去的约定也被淘汰了。</p>
<p>许多项目有自己的编码规范，在出现规范冲突时，项目自身的规范优先。</p>
<h2 id="尽信书-则不如无书"><a href="#尽信书-则不如无书" class="headerlink" title="尽信书,则不如无书"></a>尽信书,则不如无书</h2><p>Guido的一条重要的见解是代码阅读比写更加频繁。这里提供的指导原则主要用于提升代码的可读性，使得在大量的Python代码中保持一致。就像PEP 20提到的，“Readability counts”。</p>
<p>这是一份关于一致性的风格指南。这份风格指南的风格一致性是非常重要的。更重要的是项目的风格一致性。在一个模块或函数的风格一致性是最重要的。</p>
<p>然而，应该知道什么时候应该不一致，有时候编码规范的建议并不适用。当存在模棱两可的情况时，使用自己的判断。看看其他的示例再决定哪一种是最好的，不要羞于发问。</p>
<p>特别是不要为了遵守PEP约定而破坏兼容性！</p>
<p>几个很好的理由去忽略特定的规则：</p>
<ol>
<li>当遵循这份指南之后代码的可读性变差，甚至是遵循PEP规范的人也觉得可读性差。</li>
<li>与周围的代码保持一致（也可能出于历史原因），尽管这也是清理他人混乱（真正的Xtreme Programming风格）的一个机会。</li>
<li>有问题的代码出现在发现编码规范之前，而且也没有充足的理由去修改他们。</li>
<li>当代码需要兼容不支持编码规范建议的老版本Python。</li>
</ol>
<h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐[^3]。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。</p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与左括号对齐</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用更多的缩进来与其他行区分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="params"><span class="function">        var_four</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(var_one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂行缩进应该再换一行</span></span><br><span class="line">foo = long_function_name(</span><br><span class="line">    var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有使用垂直对齐时，禁止把参数放在第一行</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当缩进没有与其他行区分时，要增加缩进</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="params"><span class="function">    var_four</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(var_one)</span><br></pre></td></tr></table></figure>

<p>四空格的规则对于续行是可选的。</p>
<p>可选：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂行缩进不一定要用4个空格</span></span><br><span class="line">foo = long_function_name(</span><br><span class="line">  var_one, var_two,</span><br><span class="line">  var_three, var_four)</span><br></pre></td></tr></table></figure>

<p>当 if 语句的条件部分长到需要换行写的时候，注意可以在两个字符关键字的连接处（比如 if ），增加一个空格，再增加一个左括号来创造一个4空格缩进的多行条件。这会与if语句内同样使用4空格缩进的代码产生视觉冲突。PEP没有明确指明要如何区分 if 的条件代码和内嵌代码。可使用的选项包括但不限于下面几种情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有额外的缩进</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个注释，在能提供语法高亮的编辑器中可以有一些区分</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    <span class="comment"># Since both conditions are true, we can frobnicate.</span></span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在条件判断的语句添加额外的缩进</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing</span><br><span class="line">        <span class="keyword">and</span> that_is_another_thing):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>

<p>（可以参考下面关于是否在二进制运算符之前或之后截断的讨论） </p>
<p>在多行结构中的大括号/中括号/小括号的右括号可以与内容对齐单独起一行作为最后一行的第一个字符，就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    ]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>或者也可以与多行结构的第一行第一个字符对齐，就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="制表符还是空格？"><a href="#制表符还是空格？" class="headerlink" title="制表符还是空格？"></a>制表符还是空格？</h3><p>空格是首选的缩进方式。<br>制表符只能用于与同样使用制表符缩进的代码保持一致。<br>Python3不允许同时使用空格和制表符的缩进。<br>混合使用制表符和空格缩进的Python2代码应该统一转成空格。<br>当在命令行加入-t选项执行Python2时，它会发出关于非法混用制表符与空格的警告。当使用–tt时，这些警告会变成错误。强烈建议使用这样的参数。</p>
<h3 id="行的最大长度"><a href="#行的最大长度" class="headerlink" title="行的最大长度"></a>行的最大长度</h3><p>所有行限制的最大字符数为79。<br>没有结构化限制的大块文本（文档字符或者注释），每行的最大字符数限制在72。<br>限制编辑器窗口宽度可以使多个文件并行打开，并且在使用代码检查工具(在相邻列中显示这两个版本)时工作得很好。<br>大多数工具中的默认封装破坏了代码的可视化结构，使代码更难以理解。避免使用编辑器中默认配置的80窗口宽度，即使工具在帮你折行时在最后一列放了一个标记符。某些基于Web的工具可能根本不提供动态折行。<br>一些团队更喜欢较长的行宽。如果代码主要由一个团队维护，那这个问题就能达成一致，可以把行长度从80增加到100个字符（更有效的做法是将行最大长度增加到99个字符），前提是注释和文档字符串依然已72字符折行。<br>Python标准库比较保守，需要将行宽限制在79个字符（文档/注释限制在72）。<br>较长的代码行选择Python在小括号，中括号以及大括号中的隐式续行方式。通过小括号内表达式的换行方式将长串折成多行。这种方式应该优先使用，而不是使用反斜杠续行。<br>反斜杠有时依然很有用。比如，比较长的，多个with状态语句，不能使用隐式续行，所以反斜杠是可以接受的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/some/file/you/want/to/read&#x27;</span>) <span class="keyword">as</span> file_1, \</span><br><span class="line">     <span class="built_in">open</span>(<span class="string">&#x27;/path/to/some/file/being/written&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_2:</span><br><span class="line">    file_2.write(file_1.read())</span><br></pre></td></tr></table></figure>

<p>（请参阅前面关于多行<a href="">if-语句</a>的讨论，以获得关于这种多行with-语句缩进的进一步想法。）<br>另一种类似情况是使用assert语句。<br>确保在续行进行适当的缩进。</p>
<h3 id="在二元运算符之前应该换行吗？"><a href="#在二元运算符之前应该换行吗？" class="headerlink" title="在二元运算符之前应该换行吗？"></a>在二元运算符之前应该换行吗？</h3><p>几十年来，推荐的风格是在二元运算符之后中断。但是这回影响可读性，原因有二：操作符一般分布在屏幕上不同的列中，而且每个运算符被移到了操作数的上一行。下面例子这个情况就需要额外注意，哪些变量是相加的，哪些变量是相减的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不推荐: 操作符离操作数太远</span></span><br><span class="line">income = (gross_wages +</span><br><span class="line">          taxable_interest +</span><br><span class="line">          (dividends - qualified_dividends) -</span><br><span class="line">          ira_deduction -</span><br><span class="line">          student_loan_interest)</span><br></pre></td></tr></table></figure>

<p>为了解决这种可读性的问题，数学家和他们的出版商遵循了相反的约定。Donald Knuth在他的Computers and Typesetting系列中解释了传统规则：“尽管段落中的公式总是在二元运算符和关系之后中断，显示出来的公式总是要在二元运算符之前中断”[^4]。<br>遵循数学的传统能产出更多可读性高的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐：运算符和操作数很容易进行匹配</span></span><br><span class="line">income = (gross_wages</span><br><span class="line">          + taxable_interest</span><br><span class="line">          + (dividends - qualified_dividends)</span><br><span class="line">          - ira_deduction</span><br><span class="line">          - student_loan_interest)</span><br></pre></td></tr></table></figure>

<p>在Python代码中，允许在二元运算符之前或之后中断，只要本地的约定是一致的。对于新代码，建议使用Knuth的样式。</p>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>顶层函数和类的定义，前后用两个空行隔开。<br>类里的方法定义用一个空行隔开。<br>相关的功能组可以用额外的空行（谨慎使用）隔开。一堆相关的单行代码之间的空白行可以省略（例如，一组虚拟实现 dummy implementations）。<br>在函数中使用空行来区分逻辑段（谨慎使用）。<br>Python接受control-L（即 <code>^L</code>）换页符作为空格；许多工具把这些字符当作页面分隔符，所以你可以在文件中使用它们来分隔相关段落。请注意，一些编辑器和基于Web的代码阅读器可能无法识别control-L为换页，将在其位置显示另一个字形。</p>
<h3 id="源文件编码"><a href="#源文件编码" class="headerlink" title="源文件编码"></a>源文件编码</h3><p>Python核心发布版本中的代码总是以UTF-8格式编码（或者在Python2中用ASCII编码）。<br>使用ASCII（在Python2中）或UTF-8（在Python3中）编码的文件不应具有编码声明。<br>在标准库中，非默认的编码应该只用于测试，或者当一个注释或者文档字符串需要提及一个包含内ASCII字符编码的作者名字的时候；否则，使用<code>\x</code>,<code>\u</code>,<code>\U</code> , 或者 <code>\N</code> 进行转义来包含非ASCII字符。<br>对于Python 3和更高版本，标准库规定了以下策略（参见 <a href="http://legacy.python.org/dev/peps/pep-3131/">PEP 3131</a>）：Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下使用英语单词（在许多情况下，缩写和技术术语是非英语的）。此外，字符串文字和注释也必须是ASCII。唯一的例外是（a）测试非ASCII特征的测试用例，以及（b）作者的名称。作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。<br>鼓励具有全球受众的开放源码项目采取类似的政策。</p>
<h3 id="Imports-导入"><a href="#Imports-导入" class="headerlink" title="Imports 导入"></a>Imports 导入</h3><ul>
<li><p>导入通常在分开的行，例如：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐: </span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐:  </span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br></pre></td></tr></table></figure>

<p>  但是可以这样：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br></pre></td></tr></table></figure></li>
<li><p>导入总是位于文件的顶部，在模块注释和文档字符串之后，在模块的全局变量与常量之前。<br>导入应该按照以下顺序分组：</p>
<ol>
<li>标准库导入</li>
<li>相关第三方库导入</li>
<li>本地应用/库特定导入 </li>
</ol>
<p>你应该在每一组导入之间加入空行。</p>
</li>
<li><p>推荐使用绝对路径导入，如果导入系统没有正确的配置（比如包里的一个目录在sys.path里的路径后），使用绝对路径会更加可读并且性能更好（至少能提供更好的错误信息）:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mypkg.sibling</span><br><span class="line"><span class="keyword">from</span> mypkg <span class="keyword">import</span> sibling</span><br><span class="line"><span class="keyword">from</span> mypkg.sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure>

<p>  然而，显示的指定相对导入路径是使用绝对路径的一个可接受的替代方案，特别是在处理使用绝对路径导入不必要冗长的复杂包布局时：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> sibling</span><br><span class="line"><span class="keyword">from</span> .sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure>

<p>  标准库要避免使用复杂的包引入结构，而总是使用绝对路径。<br>  不应该使用隐式相对路径导入，并且在Python 3中删除了它。</p>
</li>
<li><p>当从一个包含类的模块中导入类时，常常这么写：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myclass <span class="keyword">import</span> MyClass</span><br><span class="line"><span class="keyword">from</span> foo.bar.yourclass <span class="keyword">import</span> YourClass</span><br></pre></td></tr></table></figure>

<p>  如果上述的写法导致名字的冲突，那么这么写：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myclass</span><br><span class="line"><span class="keyword">import</span> foo.bar.yourclass</span><br></pre></td></tr></table></figure>

<p>  然后使用 <code>myclass.MyClass</code> 和 <code>foo.bar.yourclass.YourClass</code> 。</p>
</li>
<li><p>避免通配符的导入 <code>from import *</code> ，因为这样做会不知道命名空间中存在哪些名字，会使得读取接口和许多自动化工具之间产生混淆。对于通配符的导入，有一个防御性的做法，即将内部接口重新发布为公共API的一部分（例如，用可选加速器模块的定义覆盖纯Python实现的接口，以及重写那些事先不知道的定义）。<br>  当以这种方式重新发布名称时，以下关于公共和内部接口的准则仍然适用。</p>
</li>
</ul>
<h3 id="Module-level-dunder-names-模块级的“呆”名"><a href="#Module-level-dunder-names-模块级的“呆”名" class="headerlink" title="Module level dunder names 模块级的“呆”名"></a>Module level dunder names 模块级的“呆”名</h3><p>像 <code>__all__</code> , <code>__author__</code> , <code>__version__</code> 等这样的模块级“呆名“（也就是名字里有两个前缀下划线和两个后缀下划线），应该放在文档字符串的后面，以及除from <code>__future__</code> 之外的 import 表达式前面。Python要求将来在模块中的导入，必须出现在除文档字符串之外的其他代码之前。<br>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;This is the example module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This module does stuff.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> barry_as_FLUFL</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Cardinal Biggles&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>

<h2 id="字符串引号"><a href="#字符串引号" class="headerlink" title="字符串引号"></a>字符串引号</h2><p>在Python中，单引号和双引号字符串是相同的。PEP不会为这个给出建议。选择一条规则并坚持使用下去。当一个字符串中包含单引号或者双引号字符的时候，使用和最外层不同的符号来避免使用反斜杠，从而提高可读性。<br>对于三引号字符串，总是使用双引号字符来与 <a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a> 中的文档字符串约定保持一致。</p>
<h2 id="表达式和语句中的空格"><a href="#表达式和语句中的空格" class="headerlink" title="表达式和语句中的空格"></a>表达式和语句中的空格</h2><h3 id="不能忍受的事情"><a href="#不能忍受的事情" class="headerlink" title="不能忍受的事情"></a>不能忍受的事情</h3><p>在下列情况下，避免使用无关的空格：</p>
<ul>
<li><p>紧跟在小括号，中括号或者大括号后。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line">spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125; )</span><br></pre></td></tr></table></figure></li>
<li><p>紧贴在逗号、分号或者冒号之前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">4</span>: <span class="built_in">print</span> x, y; x, y = y, x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">4</span> : <span class="built_in">print</span> x , y ; x , y = y , x</span><br></pre></td></tr></table></figure></li>
<li><p>然而，冒号在切片中就像二元运算符，在两边应该有相同数量的空格（把它当做优先级最低的操作符）。在扩展的切片操作中，所有的冒号必须有相同的间距。例外情况：当一个切片参数被省略时，空格就被省略了。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ham[<span class="number">1</span>:<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>], ham[:<span class="number">9</span>:<span class="number">3</span>], ham[<span class="number">1</span>::<span class="number">3</span>], ham[<span class="number">1</span>:<span class="number">9</span>:]</span><br><span class="line">ham[lower:upper], ham[lower:upper:], ham[lower::step]</span><br><span class="line">ham[lower+offset : upper+offset]</span><br><span class="line">ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]</span><br><span class="line">ham[lower + offset : upper + offset]</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ham[lower + offset:upper + offset]</span><br><span class="line">ham[<span class="number">1</span>: <span class="number">9</span>], ham[<span class="number">1</span> :<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span> :<span class="number">3</span>]</span><br><span class="line">ham[lower : : upper]</span><br><span class="line">ham[ : upper]</span><br></pre></td></tr></table></figure></li>
<li><p>紧贴在函数参数的左括号之前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">spam(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line">spam (<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>紧贴索引或者切片的左括号之前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">dct[<span class="string">&#x27;key&#x27;</span>] = lst[index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line">dct [<span class="string">&#x27;key&#x27;</span>] = lst [index]</span><br></pre></td></tr></table></figure></li>
<li><p>为了和另一个赋值语句对齐，在赋值运算符附件加多个空格。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">long_variable = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x             = 1</span><br><span class="line">y             = 2</span><br><span class="line">long_variable = 3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h3><ul>
<li><p>避免在尾部添加空格。因为尾部的空格通常都看不见，会产生混乱：比如，一个反斜杠后面跟一个空格的换行符，不算续行标记。有些编辑器不会保留尾空格，并且很多项目（像CPython）在pre-commit的挂钩调用中会过滤掉尾空格。</p>
</li>
<li><p>总是在二元运算符两边加一个空格：赋值（=），增量赋值（+=，-=），比较（==,&lt;,&gt;,!=,&lt;&gt;,&lt;=,&gt;=,in,not,in,is,is not），布尔（and, or, not）。</p>
</li>
<li><p>如果使用具有不同优先级的运算符，请考虑在具有最低优先级的运算符周围添加空格。有时需要通过自己来判断；但是，不要使用一个以上的空格，并且在二元运算符的两边使用相同数量的空格。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span></span><br><span class="line">submitted += <span class="number">1</span></span><br><span class="line">x = x*<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">hypot2 = x*x + y*y</span><br><span class="line">c = (a+b) * (a-b)</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=i+<span class="number">1</span></span><br><span class="line">submitted +=<span class="number">1</span></span><br><span class="line">x = x * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">hypot2 = x * x + y * y</span><br><span class="line">c = (a + b) * (a - b)</span><br></pre></td></tr></table></figure></li>
<li><p>在制定关键字参数或者默认参数值的时候，不要在=附近加上空格。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span>(<span class="params">real, imag=<span class="number">0.0</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> magic(r=real, i=imag)</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span>(<span class="params">real, imag = <span class="number">0.0</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure></li>
<li><p>功能型注释应该使用冒号的一般性规则，并且在使用-&gt;的时候要在两边加空格。（参考下面的功能注释得到能够多信息）</p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr</span>):</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>() -&gt; AnyStr:</span> ...</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>:AnyStr</span>):</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>()-&gt;PosInt:</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>当给有类型备注的参数赋值的时候，在=两边添加空格（仅针对那种有类型备注和默认值的参数）。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params">sep: AnyStr = <span class="literal">None</span></span>):</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr, sep: AnyStr = <span class="literal">None</span>, limit=<span class="number">1000</span></span>):</span> ...</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr=<span class="literal">None</span></span>):</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr, limit = <span class="number">1000</span></span>):</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>复合语句(同一行中的多个语句)通常是不允许的。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>:</span><br><span class="line">    do_blah_thing()</span><br><span class="line">do_one()</span><br><span class="line">do_two()</span><br><span class="line">do_three()</span><br></pre></td></tr></table></figure>

<p>最好别这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line">do_one(); do_two(); do_three()</span><br></pre></td></tr></table></figure></li>
<li><p>虽然有时候将小的代码块和 if/for/while 放在同一行没什么问题，多行语句块的情况不要这样用，同样也要避免代码行太长！ </p>
<p>最好别这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst: total += x</span><br><span class="line"><span class="keyword">while</span> t &lt; <span class="number">10</span>: t = delay()</span><br></pre></td></tr></table></figure>

<p>绝对别这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">else</span>: do_non_blah_thing()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: something()</span><br><span class="line"><span class="keyword">finally</span>: cleanup()</span><br><span class="line"></span><br><span class="line">do_one(); do_two(); do_three(long, argument,</span><br><span class="line">                             <span class="built_in">list</span>, like, this)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: one(); two(); three()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更新对应的注释！<br>注释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！)。<br>如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。<br>在句尾结束的时候应该使用两个空格。<br>当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格。<br>在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。</p>
<h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h3><p>块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。<br>块注释内部的段落通过只有一个#的空行分隔。</p>
<h3 id="行内注释"><a href="#行内注释" class="headerlink" title="行内注释"></a>行内注释</h3><p>有节制地使用行内注释。<br>行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。<br>事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。比如说下面这样就不需要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x + <span class="number">1</span>                 <span class="comment"># Increment x</span></span><br></pre></td></tr></table></figure>

<p>但有时，这样做很有用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x + <span class="number">1</span>                 <span class="comment"># Compensate for border</span></span><br></pre></td></tr></table></figure>

<h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>编写好的文档说明（也叫“docstrings”）的约定在<a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a>中永恒不变。</p>
<ul>
<li><p>要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。</p>
</li>
<li><p><a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a> 描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Return a foobang</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optional plotz says to frobnicate the bizbaz first.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于单行的文档说明，尾部的三引号应该和文档在同一行。</p>
</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>Python库的命名规范很乱，从来没能做到完全一致。但是目前有一些推荐的命名标准。新的模块和包（包括第三方框架）应该用这套标准，但当一个已有库采用了不同的风格，推荐保持内部一致性。</p>
<h3 id="最重要的原则"><a href="#最重要的原则" class="headerlink" title="最重要的原则"></a>最重要的原则</h3><p>那些暴露给用户的API接口的命名，应该遵循反映使用场景而不是实现的原则。</p>
<h3 id="描述：命名风格"><a href="#描述：命名风格" class="headerlink" title="描述：命名风格"></a>描述：命名风格</h3><p>有许多不同的命名风格。这里能够帮助大家识别正在使用什么样的命名风格，而不考虑他们为什么使用。<br>以下是常见的命名方式：</p>
<ul>
<li><p>b（单个小写字母）</p>
</li>
<li><p>B（单个大写字母）</p>
</li>
<li><p>lowercase 小写字母</p>
</li>
<li><p>lower_case_with_underscores 使用下划线分隔的小写字母</p>
</li>
<li><p>UPPERCASE 大写字母</p>
</li>
<li><p>UPPER_CASE_WITH_UNDERSCORES 使用下划线分隔的大写字母</p>
</li>
<li><p>CapitalizedWords（或者叫 CapWords，或者叫CamelCase 驼峰命名法 —— 这么命名是因为字母看上去有起伏的外观<a href="http://www.wikipedia.com/wiki/CamelCase">^5</a>）。有时候也被称为StudlyCaps。 </p>
<p>注意：当在首字母大写的风格中用到缩写时，所有缩写的字母用大写，因此，HTTPServerError 比 HttpServerError 好。</p>
</li>
<li><p>mixedCase（不同于首字母大写，第一个单词的首字母小写）</p>
</li>
<li><p>Capitalized_Words_With_Underscores（巨丑无比！）</p>
</li>
</ul>
<p>也有用唯一的短前缀把相关命名组织在一起的方法。这在Python中不常用，但还是提一下。比如，os.stat()函数中包含类似以st_mode，st_size，st_mtime这种传统命名方式命名的变量。（这么做是为了与 POSIX 系统的调用一致，以帮助程序员熟悉它。）<br>X11库的所有公共函数都加了前缀X。在Python里面没必要这么做，因为属性和方法在调用的时候都会用类名做前缀，函数名用模块名做前缀。<br>另外，下面这种用前缀或结尾下划线的特殊格式是被认可的（通常和一些约定相结合）：</p>
<ul>
<li>_single_leading_underscore：（单下划线开头）弱“内部使用”指示器。比如 from M import * 是不会导入以下划线开始的对象的。</li>
<li>single_trailing_underscore_：（单下划线结尾）这是避免和Python内部关键词冲突的一种约定，比如：Tkinter.Toplevel(master, class_=’ClassName’)</li>
<li><code>__double_leading_underscore</code> ：（双下划线开头）当这样命名一个类的属性时，调用它的时候名字会做矫正（在类FooBar中，<code>__boo</code> 变成了<code>_FooBar__boo</code>；见下文）。</li>
<li><code>__double_leading_and_trailing_underscore__</code> ：（双下划线开头，双下划线结尾）“magic”对象或者存在于用户控制的命名空间内的属性，例如： <code>__init__ </code>, <code>__import__</code> 或者 <code>__file__</code> 。除了作为文档之外，永远不要命这样的名。</li>
</ul>
<h3 id="约定俗成：命名约定"><a href="#约定俗成：命名约定" class="headerlink" title="约定俗成：命名约定"></a>约定俗成：命名约定</h3><h4 id="应避免的名字"><a href="#应避免的名字" class="headerlink" title="应避免的名字"></a>应避免的名字</h4><p>永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。<br>在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。</p>
<h4 id="包名和模块名"><a href="#包名和模块名" class="headerlink" title="包名和模块名"></a>包名和模块名</h4><p>模块应该用简短全小写的名字，如果为了提升可读性，下划线也是可以用的。Python包名也应该使用简短全小写的名字，但不建议用下划线。<br>当使用C或者C++编写了一个依赖于提供高级（更面向对象）接口的Python模块的扩展模块，这个C/C++模块需要一个下划线前缀（例如：_socket）</p>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>类名一般使用首字母大写的约定。<br>在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。<br>注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。</p>
<h4 id="异常名"><a href="#异常名" class="headerlink" title="异常名"></a>异常名</h4><p>因为异常一般都是类，所有类的命名方法在这里也适用。然而，你需要在异常名后面加上“Error”后缀（如果异常确实是一个错误）。</p>
<h4 id="全局变量名"><a href="#全局变量名" class="headerlink" title="全局变量名"></a>全局变量名</h4><p>（我们希望这一类变量只在模块内部使用。）约定和函数命名规则一样。<br>通过 from M import * 导入的模块应该使用<strong>all</strong>机制去防止内部的接口对外暴露，或者使用在全局变量前加下划线的方式（表明这些全局变量是模块内非公有）。</p>
<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名应该小写，如果想提高可读性可以用下划线分隔。<br>大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性。</p>
<h4 id="函数和方法参数"><a href="#函数和方法参数" class="headerlink" title="函数和方法参数"></a>函数和方法参数</h4><p>始终要将 self 作为实例方法的的第一个参数。<br>始终要将 cls 作为类静态方法的第一个参数。<br>如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）</p>
<h4 id="方法名和实例变量"><a href="#方法名和实例变量" class="headerlink" title="方法名和实例变量"></a>方法名和实例变量</h4><p>遵循这样的函数命名规则：使用下划线分隔小写单词以提高可读性。<br>在非共有方法和实例变量前使用单下划线。<br>通过双下划线前缀触发Python的命名转换规则来避免和子类的命名冲突。<br>Python通过类名对这些命名进行转换：如果类 Foo 有一个叫 <code>__a</code> 的成员变量， 它无法通过 <code>Foo.__a</code> 访问。（执着的用户可以通过 <code>Foo._Foo__a</code> 访问。）一般来说，前缀双下划线用来避免类中的属性命名与子类冲突的情况。<br>注意：关于<code>__names</code>的用法存在争论（见下文）。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量通常定义在模块级，通过下划线分隔的全大写字母命名。例如： MAX_OVERFLOW 和 TOTAL。</p>
<h4 id="继承的设计"><a href="#继承的设计" class="headerlink" title="继承的设计"></a>继承的设计</h4><p>始终要考虑到一个类的方法和实例变量（统称：属性）应该是共有还是非共有。如果存在疑问，那就选非共有；因为将一个非共有变量转为共有比反过来更容易。<br>公共属性是那些与类无关的客户使用的属性，并承诺避免向后不兼容的更改。非共有属性是那些不打算让第三方使用的属性；你不需要承诺非共有属性不会被修改或被删除。<br>我们不使用“私有（private）”这个说法，是因为在Python中目前还没有真正的私有属性（为了避免大量不必要的常规工作）。<br>另一种属性作为子类API的一部分（在其他语言中通常被称为“protected”）。有些类是专为继承设计的，用来扩展或者修改类的一部分行为。当设计这样的类时，要谨慎决定哪些属性时公开的，哪些是作为子类的API，哪些只能在基类中使用。<br>贯彻这样的思想，以下是一些让代码Pythonic的准则：</p>
<ul>
<li>公共属性不应该有前缀下划线。</li>
<li>如果公共属性名和关键字冲突，在属性名之后增加一个下划线。这比缩写和随意拼写好很多。（然而，尽管有这样的规则，在作为参数或者变量时，‘cls’是表示‘类’最好的选择，特别是作为类方法的第一个参数。）<br>注意1：参考之前的类方法参数命名建议</li>
<li>对于单一的共有属性数据，最好直接对外暴露它的变量名，而不是通过负责的 存取器（accessor）/突变（mutator） 方法。请记住，如果你发现一个简单的属性需要成长为一个功能行为，那么Python为这种将来会出现的扩展提供了一个简单的途径。在这种情况下，使用属性去隐藏属性数据访问背后的逻辑。<br>注意1：属性只在new-style类中起作用。<br>注意2：尽管功能方法对于类似缓存的负面影响比较小，但还是要尽量避免。<br>注意3：属性标记会让调用者认为开销（相当的）小，避免用属性做开销大的计算。</li>
<li>如果你的类打算用来继承的话，并且这个类里有不希望子类使用的属性，就要考虑使用双下划线前缀并且没有后缀下划线的命名方式。这会调用Python的命名转换算法，将类的名字加入到属性名里。这样做可以帮助避免在子类中不小心包含了相同的属性名而产生的冲突。<br>注意1：只有类名才会整合进属性名，如果子类的属性名和类名和父类都相同，那么你还是会有命名冲突的问题。<br>注意2：命名转换会在某些场景使用起来不太方便，例如调试，<code>__getattr__()</code>。然而命名转换的算法有很好的文档说明并且很好操作。<br>注意3：不是所有人都喜欢命名转换。尽量避免意外的名字冲突和潜在的高级调用。</li>
</ul>
<h3 id="公共和内部的接口"><a href="#公共和内部的接口" class="headerlink" title="公共和内部的接口"></a>公共和内部的接口</h3><p>任何向后兼容保证只适用于公共接口，因此，用户清晰地区分公共接口和内部接口非常重要。<br>文档化的接口被认为是公开的，除非文档明确声明它们是临时或内部接口，不受通常的向后兼容性保证。所有未记录的接口都应该是内部的。<br>为了更好地支持内省（introspection），模块应该使用<code>__all__</code>属性显式地在它们的公共API中声明名称。将<code>__all__</code>设置为空列表表示模块没有公共API。<br>即使通过<code>__all__</code>设置过，内部接口（包，模块，类，方法，属性或其他名字）依然需要单个下划线前缀。<br>如果一个命名空间（包，模块，类）被认为是内部的，那么包含它的接口也应该被认为是内部的。<br>导入的名称应该始终被视作是一个实现的细节。其他模块必须不能间接访问这样的名称，除非它是包含它的模块中有明确的文档说明的API，例如 os.path 或者是一个包里从子模块公开函数接口的 <code>__init__</code> 模块。</p>
<h2 id="编程建议"><a href="#编程建议" class="headerlink" title="编程建议"></a>编程建议</h2><ul>
<li><p>代码应该用不损害其他Python实现的方式去编写（PyPy，Jython，IronPython，Cython，Psyco 等）。<br>比如，不要依赖于在CPython中高效的内置字符连接语句 a += b 或者 a = a + b。这种优化甚至在CPython中都是脆弱的（它只适用于某些类型）并且没有出现在不使用引用计数的实现中。在性能要求比较高的库中，可以种 ”.join() 代替。这可以确保字符关联在不同的实现中都可以以线性时间发生。</p>
</li>
<li><p>和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符。<br>另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值。</p>
</li>
<li><p>使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> foo <span class="keyword">is</span> <span class="literal">None</span>:</span><br></pre></td></tr></table></figure></li>
<li><p>当使用富比较（rich comparisons，一种复杂的对象间比较的新机制，允许返回值不为-1,0,1）实现排序操作的时候，最好实现全部的六个操作符（ <code>__eq__</code> , <code>__ne__</code> , <code>__lt__</code>, <code>__gt__</code> , <code>__ge__</code> ）而不是依靠其他的代码去实现特定的比较。<br>为了最大程度减少这一过程的开销， functools.total_ordering() 修饰符提供了用于生成缺少的比较方法的工具。<br>PEP 207 指出Python实现了反射机制。因此，解析器会将 y &gt; x 转变为 x &lt; y，将 y &gt;= x 转变为 x &lt;= y，也会转换x == y 和 x != y的参数。sort() 和 min()方法确保使用&lt;操作符，max()使用&gt;操作符。然而，最好还是实现全部六个操作符，以免在其他地方出现冲突。</p>
</li>
<li><p>始终使用 def 表达式，而不是通过赋值语句将lambda表达式绑定到一个变量上。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span> <span class="keyword">return</span> <span class="number">2</span>*x</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">2</span>*x</span><br></pre></td></tr></table></figure>

<p>第一个形式意味着生成的函数对象的名称是“f”而不是泛型“&lt; lambda &gt;”。这在回溯和字符串显示的时候更有用。赋值语句的使用消除了lambda表达式优于显式def表达式的唯一优势（即lambda表达式可以内嵌到更大的表达式中）。</p>
</li>
<li><p>从Exception继承异常，而不是BaseException。直接继承BaseException的异常适用于几乎不用来捕捉的异常。<br>设计异常的等级，要基于扑捉异常代码的需要，而不是异常抛出的位置。以编程的方式去回答“出了什么问题？”，而不是只是确认“出现了问题”（内置异常结构的例子参考 <a href="http://legacy.python.org/dev/peps/pep-3151/">PEP 3151</a> ）<br>类的命名规范适用于这里，但是你需要添加一个“Error”的后缀到你的异常类，如果异常是一个Error的话。非本地流控制或者其他形式的信号的非错误异常不需要特殊的后缀。</p>
</li>
<li><p>适当地使用异常链接。在Python 3里，为了不丢失原始的根源，可以显式指定“raise X from Y”作为替代。<br>当故意替换一个内部异常时（Python 2 使用“raise X”， Python 3.3 之后 使用 “raise X from None”），确保相关的细节转移到新的异常中（比如把AttributeError转为KeyError的时候保留属性名，或者将原始异常信息的文本内容内嵌到新的异常中）。</p>
</li>
<li><p>在Python 2中抛出异常时，使用 rasie ValueError(‘message’) 而不是用老的形式 raise ValueError, ‘message’。<br>第二种形式在Python3 的语法中不合法<br>使用小括号，意味着当异常里的参数非常长，或者包含字符串格式化的时候，不需要使用换行符。</p>
</li>
<li><p>当捕获到异常时，如果可以的话写上具体的异常名，而不是只用一个except: 块。 </p>
<p>比如说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> platform_specific_module</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    platform_specific_module = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>如果只有一个except: 块将会捕获到SystemExit和KeyboardInterrupt异常，这样会很难通过Control-C中断程序，而且会掩盖掉其他问题。如果你想捕获所有指示程序出错的异常，使用 except Exception: （只有except等价于 except BaseException:）。<br>两种情况不应该只使用‘excpet’块：</p>
<pre><code>1. 如果异常处理的代码会打印或者记录log；至少让用户知道发生了一个错误。
2. 如果代码需要做清理工作，使用 raise..try…finally 能很好处理这种情况并且能让异常继续上浮。
</code></pre>
</li>
<li><p>当给捕捉的异常绑定一个名字时，在Python 2.6中推荐使用显式命名绑定语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    process_data()</span><br><span class="line">except Exception as exc:</span><br><span class="line">    raise DataProcessingFailedError(str(exc))</span><br></pre></td></tr></table></figure>

<p>为了避免和原来基于逗号分隔的语法出现歧义，Python3只支持这一种语法。</p>
</li>
<li><p>当捕捉操作系统的错误时，推荐使用Python 3.3 中errno内定数值指定的异常等级。</p>
</li>
<li><p>另外，对于所有的 try/except 语句块，在try语句中只填充必要的代码，这样能避免掩盖掉bug。 </p>
<p>  推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    value = collection[key]</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="keyword">return</span> key_not_found(key)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> handle_value(value)</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Too broad!</span></span><br><span class="line">    <span class="keyword">return</span> handle_value(collection[key])</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="comment"># Will also catch KeyError raised by handle_value()</span></span><br><span class="line">    <span class="keyword">return</span> key_not_found(key)</span><br></pre></td></tr></table></figure></li>
<li><p>当代码片段局部使用了某个资源的时候，使用with 表达式来确保这个资源使用完后被清理干净。用try/finally也可以。</p>
</li>
<li><p>无论何时获取和释放资源，都应该通过单独的函数或方法调用上下文管理器。举个例子： </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> conn.begin_transaction():</span><br><span class="line">    do_stuff_in_transaction(conn)</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> conn:</span><br><span class="line">    do_stuff_in_transaction(conn)</span><br></pre></td></tr></table></figure>

<p>第二个例子没有提供任何信息去指明<code>__enter__</code>和<code>__exit__</code>方法在事务之后做出了关闭连接之外的其他事情。这种情况下，明确指明非常重要。</p>
</li>
<li><p>返回的语句保持一致。函数中的返回语句都应该返回一个表达式，或者都不返回。如果一个返回语句需要返回一个表达式，那么在没有值可以返回的情况下，需要用 return None 显式指明，并且在函数的最后显式指定一条返回语句（如果能跑到那的话）。 </p>
<p>推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(x)</span><br></pre></td></tr></table></figure>

<p>不推荐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(x)</span><br></pre></td></tr></table></figure></li>
<li><p>使用字符串方法代替字符串模块。 </p>
<p>字符串方法总是更快，并且和unicode字符串分享相同的API。如果需要兼容Python2.0之前的版本可以不用考虑这个规则。</p>
</li>
<li><p>使用 ”.startswith() 和 ”.endswith() 代替通过字符串切割的方法去检查前缀和后缀。 </p>
<p>startswith()和endswith()更干净，出错几率更小。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line"><span class="keyword">if</span> foo.startswith(<span class="string">&#x27;bar&#x27;</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> foo[:<span class="number">3</span>] == <span class="string">&#x27;bar&#x27;</span>:</span><br></pre></td></tr></table></figure></li>
<li><p>对象类型的比较应该用isinstance()而不是直接比较type。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">int</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(obj) <span class="keyword">is</span> <span class="built_in">type</span>(<span class="number">1</span>):</span><br></pre></td></tr></table></figure>

<p>当检查一个对象是否为string类型时，记住，它也有可能是unicode string！在Python2中，str和unicode都有相同的基类：basestring，所以你可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if isinstance(obj, basestring):</span><br></pre></td></tr></table></figure>

<p>注意，在Python3中，unicode和basestring都不存在了（只有str）并且bytes类型的对象不再是string类型的一种（它是整数序列）</p>
</li>
<li><p>对于序列来说（strings，lists，tuples），可以使用空序列为false的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> seq:</span><br><span class="line"><span class="keyword">if</span> seq:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(seq):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(seq):</span><br></pre></td></tr></table></figure></li>
<li><p>书写字符串时不要依赖单词结尾的空格，这样的空格在视觉上难以区分，有些编辑器会自动去掉他们（比如 reindent.py （译注：re indent 重新缩进））</p>
</li>
<li><p>不要用 == 去和True或者False比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line"><span class="keyword">if</span> greeting:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line"><span class="keyword">if</span> greeting == <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 极不推荐</span></span><br><span class="line"><span class="keyword">if</span> greeting <span class="keyword">is</span> <span class="literal">True</span>:</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="功能注释"><a href="#功能注释" class="headerlink" title="功能注释"></a>功能注释</h3><p>随着<a href="http://legacy.python.org/dev/peps/pep-0484/">PEP 484</a>的引入，功能型注释的风格规范有些变化。</p>
<ul>
<li><p>为了向前兼容，在Python3代码中的功能注释应该使用 PEP 484的语法规则。（在前面的章节中对注释有格式化的建议。）</p>
</li>
<li><p>不再鼓励使用之前在PEP中推荐的实验性样式。</p>
</li>
<li><p>然而，在stdlib库之外，在PEP 484中的实验性规则是被鼓励的。比如用PEP 484的样式标记大型的第三方库或者应用程序，回顾添加这些注释是否简单，并观察是否增加了代码的可读性。</p>
</li>
<li><p>Python的标准库代码应该保守使用这种注释，但新的代码或者大型的重构可以使用这种注释。</p>
</li>
<li><p>如果代码希望对功能注释有不同的用途，建议在文件的顶部增加一个这种形式的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type: ignore</span></span><br></pre></td></tr></table></figure>

<p>这会告诉检查器忽略所有的注释。（在 <a href="http://legacy.python.org/dev/peps/pep-0484/">PEP 484</a>中可以找到从类型检查器禁用投诉的更细粒度的方法。）</p>
</li>
<li><p>像linters一样，类型检测器是可选的可独立的工具。默认情况下，Python解释器不应该因为类型检查而发出任何消息，也不应该基于注释改变它们的行为。</p>
</li>
<li><p>不想使用类型检测的用户可以忽略他们。然而，第三方库的用户可能希望在这些库上运行类型检测。为此， <a href="http://legacy.python.org/dev/peps/pep-0484/">PEP 484</a>建议使用存根文件类型：.pyi文件，这种文件类型相比于.py文件会被类型检测器读取。存根文件可以和库一起，或者通过typeshed repo[^6]独立发布（通过库作者的许可）</p>
</li>
<li><p>对于需要向后兼容的代码，可以以注释的形式添加功能型注释。参见<a href="http://legacy.python.org/dev/peps/pep-0484/">PEP 484</a>的相关部分[^7]。</p>
</li>
</ul>
<p>[^1]: PEP 7, Style Guide for C Code, van Rossum<br>[^2]: Barry’s GNU Mailman style guide <a href="http://barry.warsaw.us/software/STYLEGUIDE.txt">http://barry.warsaw.us/software/STYLEGUIDE.txt</a><br>[^3]: 挂行缩进是一种类型设置样式，其中除第一行之外，段落中的所有行都缩进。在Python中，这个术语是用来描述一种风格：在被括号括起来的语句中，左括号是这一行最后一个非空格字符，随后括号内的内容每一行进行缩进，直到遇到右括号。<br>[^4]: Donald Knuth’s The TeXBook, pages 195 and 196</p>
<p>[^6]: Typeshed repo <a href="https://github.com/python/typeshed">https://github.com/python/typeshed</a><br>[^7]: Suggested syntax for Python 2.7 and straddling code <a href="https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code">https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code</a></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Microsoft REST API 准则</title>
    <url>/2020/09/01/api-design/microsoft_api_guide/</url>
    <content><![CDATA[<h2 id="Microsoft-REST-API准则工作组"><a href="#Microsoft-REST-API准则工作组" class="headerlink" title="Microsoft REST API准则工作组"></a>Microsoft REST API准则工作组</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>戴夫·坎贝尔（CTO C + E）</td>
<td>里克·拉希德（CTO ASG）</td>
<td>John Shewchuk（TED总部技术研究员）</td>
</tr>
<tr>
<td>马克·鲁西诺维奇（CTO Azure）</td>
<td>Steve Lucco（DevDiv技术研究员）</td>
<td>Murali Krishnaprasad（Azure应用平台）</td>
</tr>
<tr>
<td>罗伯·霍华德（ASG）</td>
<td>彼得·托（OSG）</td>
<td>克里斯·穆林斯（ASG）</td>
</tr>
</tbody></table>
<p>文档编辑：John Gossman（C + E），Chris Mullins（ASG），Gareth Jones（ASG），Rob Dolin（C + E），Mark Stafford（C + E）</p>
<span id="more"></span>

<h1 id="Microsoft-REST-API准则"><a href="#Microsoft-REST-API准则" class="headerlink" title="Microsoft REST API准则"></a>Microsoft REST API准则</h1><h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h2><p>作为设计原则，Microsoft REST API准则鼓励应用程序开发人员通过RESTful HTTP接口访问资源。为了在遵循Microsoft REST API准则的平台上为开发人员提供尽可能流畅的体验，REST API应当遵循一致的设计准则，以使其使用起来简单直观。</p>
<p>本文档建立了Microsoft REST API应该遵循的准则，以便一致地开发RESTful接口。</p>
<h2 id="3-引言"><a href="#3-引言" class="headerlink" title="3. 引言"></a>3. 引言</h2><p>开发人员通过HTTP接口访问大多数Microsoft Cloud Platform资源。尽管每个服务通常都提供特定于语言的框架来包装其API，但其所有操作最终都归结为HTTP请求。Microsoft必须支持广泛的客户端和服务，并且不能依赖可用于每个开发环境的丰富框架。因此，这些准则的目标是确保具有基本HTTP支持的任何客户端都可以轻松，一致地使用Microsoft REST API。</p>
<p>为了为开发人员提供尽可能流畅的体验，使这些API遵循一致的设计准则非常重要，因此使它们使用起来简单直观。本文档建立了Microsoft REST API开发人员应遵循的准则，以一致地开发此类API。</p>
<p>总的来说，一致性的好处也会产生；一致性使团队可以利用通用代码，模式，文档和设计决策。</p>
<p>这些准则旨在实现以下目标：</p>
<ul>
<li>为Microsoft的所有API端点定义一致的做法和模式。</li>
<li>尽可能严格遵守业界公认的REST / HTTP最佳实践。*</li>
<li>使所有应用程序开发人员都可以通过REST界面轻松访问Microsoft Services。</li>
<li>允许服务开发人员利用其他服务的先前工作来实施，测试和记录一致定义的REST端点。</li>
<li>允许合作伙伴（例如，非Microsoft实体）将这些准则用于他们自己的REST端点设计。</li>
</ul>
<p><em>注意：准则旨在与符合REST体系结构样式的建筑服务保持一致，尽管它们并未解决或要求遵循REST约束的建筑服务。在整个文档中，术语“ REST”用于表示符合REST精神的服务，而不是本书所遵循的REST</em></p>
<h3 id="3-1-推荐阅读"><a href="#3-1-推荐阅读" class="headerlink" title="3.1 推荐阅读"></a>3.1 推荐阅读</h3><p>为了开发良好的基于HTTP的服务，建议理解REST体系结构风格的原理。如果您不熟悉RESTful设计，这里有一些不错的资源：</p>
<p><a href="http://en.wikipedia.org/wiki/Representational_state_transfer">Wikipedia上的REST</a> -REST背后的常见定义和核心思想概述。</p>
<p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">REST论文</a> -Roy Fielding论文中有关REST的一章，即“建筑风格和基于网络的软件体系结构的设计”</p>
<p><a href="https://tools.ietf.org/html/rfc7231">RFC 7231-</a>定义HTTP / 1.1语义的规范，并被视为权威资源。</p>
<p><a href="http://www.amazon.com/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829/">实践中</a>的REST-关于REST基础的书籍。</p>
<h2 id="4-解释准则"><a href="#4-解释准则" class="headerlink" title="4 解释准则"></a>4 解释准则</h2><h3 id="4-1-准则的适用"><a href="#4-1-准则的适用" class="headerlink" title="4.1 准则的适用"></a>4.1 准则的适用</h3><p>这些准则适用于Microsoft或任何合作伙伴服务公开公开的任何REST API。私有或内部API也应尝试遵循这些准则，因为内部服务最终倾向于公开公开。一致性不仅对外部客户而且对内部服务消费者都很有价值，并且这些准则提供了对任何服务都有用的最佳实践。</p>
<p>有正当理由免除这些准则。显然，实现或必须与某些外部定义的REST API互操作的REST服务必须与该API兼容，而不一定与这些准则兼容。一些服务可能还具有特殊的性能需求，这些需求需要不同的格式，例如二进制协议。</p>
<h3 id="4-2-现有服务和服务版本指导"><a href="#4-2-现有服务和服务版本指导" class="headerlink" title="4.2 现有服务和服务版本指导"></a>4.2 现有服务和服务版本指导</h3><p>我们不建议仅出于合规性考虑而对早于这些准则的服务进行重大更改。当兼容性遭到破坏时，该服务应尝试在下一版本中变得兼容。当服务添加新的API时，该API应该与相同版本的其他API一致。因此，如果针对该指南的1.0版编写了服务，则应将增量添加到该服务的新API也遵循1.0版。然后可以在服务的下一个主要版本中升级该服务以使其与指南的最新版本保持一致。</p>
<h3 id="4-3-需求语言"><a href="#4-3-需求语言" class="headerlink" title="4.3 需求语言"></a>4.3 需求语言</h3><p>本文档中的关键字“必须”，“不得”，“必须”，“应”，“应不”，“应”，“不应”，“推荐”，“可以”和“可选”按照<a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119中的</a>描述进行解释。</p>
<h3 id="4-4-许可证"><a href="#4-4-许可证" class="headerlink" title="4.4 许可证"></a>4.4 许可证</h3><p>该作品已根据知识共享署名4.0国际许可协议获得许可。要查看此许可证的副本，请访问<a href="http://creativecommons.org/licenses/by/4.0/%E6%88%96%E5%90%91%E7%BE%8E%E5%9B%BD%E7%BA%BD%E7%BA%A6%E5%B7%9E94042%EF%BC%8C%E5%B1%B1%E6%99%AF%E5%9F%8E%E7%9A%84PO">http://creativecommons.org/licenses/by/4.0/或向美国纽约州94042，山景城的PO</a> Box 1866邮政局（Creative Commons）发信。</p>
<h2 id="5-分类"><a href="#5-分类" class="headerlink" title="5 分类"></a>5 分类</h2><p>作为加入Microsoft REST API指南的一部分，服务必须符合以下定义的分类法。</p>
<h3 id="5-1-错误"><a href="#5-1-错误" class="headerlink" title="5.1 错误"></a>5.1 错误</h3><p>错误，或更具体地说是服务错误，定义为客户端将无效数据传递给服务，并且服务<em>正确</em>拒绝该数据。示例包括无效的凭据，不正确的参数，未知的版本ID或类似内容。这些通常是“ 4xx” HTTP错误代码，是客户端传递不正确或无效数据的结果。</p>
<p>错误<em>不会</em>影响总体API可用性。</p>
<h3 id="5-2-故障"><a href="#5-2-故障" class="headerlink" title="5.2 故障"></a>5.2 故障</h3><p>错误，或更具体地说是服务错误，定义为服务无法正确响应有效的客户端请求而返回。这些通常是“ 5xx” HTTP错误代码。</p>
<p>故障<em>确实</em>有助于总体API可用性。</p>
<p>由于速率限制或配额失败而失败的呼叫不得视为错误。由于服务快速失败请求而导致失败的调用（通常是出于自身保护的考虑）确实被视为错误。</p>
<h3 id="5-3-延迟"><a href="#5-3-延迟" class="headerlink" title="5.3 延迟"></a>5.3 延迟</h3><p>延迟定义为特定API调用完成所需的时间，并尽可能接近客户端。此指标以相同的方式适用于同步和异步API。对于长时间运行的呼叫，延迟是根据初始请求进行衡量的，并衡量该呼叫（而不是整个操作）需要花费多长时间。</p>
<h3 id="5-4完成时间"><a href="#5-4完成时间" class="headerlink" title="5.4完成时间"></a>5.4完成时间</h3><p>公开长时间操作的服务必须跟踪这些操作的“完成时间”指标。</p>
<h3 id="5-5-长时间运行的API错误"><a href="#5-5-长时间运行的API错误" class="headerlink" title="5.5 长时间运行的API错误"></a>5.5 长时间运行的API错误</h3><p>对于长时间运行的API，初始请求可以开始操作，并且检索结果的请求可以在技术上正常工作（每个返回200），但是基础操作失败。长期运行的故障必须作为故障汇总到总体可用性指标中。</p>
<h2 id="6-客户指导"><a href="#6-客户指导" class="headerlink" title="6 客户指导"></a>6 客户指导</h2><p>为了确保与REST服务对话的客户获得最佳体验，客户应遵循以下最佳实践：</p>
<h3 id="6-1忽略规则"><a href="#6-1忽略规则" class="headerlink" title="6.1忽略规则"></a>6.1忽略规则</h3><p>对于松散耦合的客户端，在调用之前尚不清楚数据的确切形状，如果服务器返回了客户端未期望的内容，则客户端必须安全地忽略它。</p>
<p>一些服务可以在不改变版本号的情况下在响应中添加字段。这样做的服务必须在其文档中明确指出，并且客户端必须忽略未知字段。</p>
<h3 id="6-2可变顺序规则"><a href="#6-2可变顺序规则" class="headerlink" title="6.2可变顺序规则"></a>6.2可变顺序规则</h3><p>客户端不得依赖于数据在JSON服务响应中出现的顺序。例如，客户端应该对JSON对象中字段的重新排序具有弹性。当服务支持时，客户端可以请求以特定顺序返回数据。例如，服务可以支持使用*$ orderBy* querystring参数来指定JSON数组中元素的顺序。服务还可以明确规定某些元素的顺序，作为服务合同的一部分。例如，服务可以始终返回JSON对象的“类型”信息作为对象中的第一个字段，以简化客户端上的响应解析。客户可以依靠服务明确标识的订购行为。</p>
<h3 id="6-3静默失败规则"><a href="#6-3静默失败规则" class="headerlink" title="6.3静默失败规则"></a>6.3静默失败规则</h3><p>请求可选服务器功能（例如可选标头）的客户端必须对服务器具有弹性，而忽略该特定功能。</p>
<h2 id="7-一致性基础"><a href="#7-一致性基础" class="headerlink" title="7 一致性基础"></a>7 一致性基础</h2><h3 id="7-1-URL结构"><a href="#7-1-URL结构" class="headerlink" title="7.1 URL结构"></a>7.1 URL结构</h3><p>人类应该能够轻松地阅读和构造URL。</p>
<p>在没有良好支持的客户端库的情况下，这有助于发现并简化在平台上的采用。</p>
<p>结构良好的URL的示例是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox</span><br></pre></td></tr></table></figure>
<p>不友好的URL是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/EWS/OData/Users(&#x27;jdoe@microsoft.com&#x27;)/Folders(&#x27;AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=&#x27;)</span><br></pre></td></tr></table></figure>

<p>经常出现的模式是使用URL作为值。服务可以使用URL作为值。例如，以下是可接受的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy</span><br></pre></td></tr></table></figure>

<h3 id="7-2-URL长度"><a href="#7-2-URL长度" class="headerlink" title="7.2 URL长度"></a>7.2 URL长度</h3><p>在RFC 7230的<a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">3.1.1</a>节中定义的HTTP 1.1消息格式在请求行上没有长度限制，该长度包括目标URL。从RFC：</p>
<blockquote>
<p>HTTP并未对请求行的长度设置预定义的限制。[…]接收到比任何希望解析的URI更长的请求目标的服务器，必须以414（URI太长）状态码作为响应。</p>
</blockquote>
<p>可以生成超过2083个字符的URL的服务必须为他们希望支持的客户提供便利。以下是一些确定目标客户支持的来源：</p>
<ul>
<li><a href="http://stackoverflow.com/a/417184">http://stackoverflow.com/a/417184</a></li>
<li><a href="https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/">https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/</a></li>
</ul>
<p>另请注意，某些技术堆栈具有严格的可调整的URL限制，因此在设计服务时请记住这一点。</p>
<h3 id="7-3规范标识符"><a href="#7-3规范标识符" class="headerlink" title="7.3规范标识符"></a>7.3规范标识符</h3><p>除了友好的URL，可以移动或重命名的资源也应该公开包含唯一稳定标识符的URL。与某些服务使用“ /我”快捷方式的情况一样，可能有必要与服务进行交互以从资源的友好名称中获取稳定的URL。</p>
<p>稳定标识符不需要是GUID。</p>
<p>包含规范标识符的URL的示例是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/v1.0/people/7011042402/inbox</span><br></pre></td></tr></table></figure>

<h3 id="7-4支持的方法"><a href="#7-4支持的方法" class="headerlink" title="7.4支持的方法"></a>7.4支持的方法</h3><p>操作必须尽可能使用正确的HTTP方法，并且必须尊重操作幂等性。HTTP方法通常称为HTTP动词。这些术语在此上下文中是同义词，但是HTTP规范使用术语“方法”。</p>
<p>以下是Microsoft REST服务应支持的方法的列表。并非所有资源都支持所有方法，但是使用以下方法的所有资源必须符合其用法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否幂等</th>
</tr>
</thead>
<tbody><tr>
<td><code>GET</code></td>
<td>返回对象的当前值</td>
<td>是</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td>替换对象或创建命名对象（如果适用）</td>
<td>是</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>删除物件</td>
<td>是</td>
</tr>
<tr>
<td><code>POST</code></td>
<td>根据提供的数据创建新对象，或提交命令</td>
<td>否</td>
</tr>
<tr>
<td><code>HEAD</code></td>
<td>返回对象的元数据以获取GET响应。支持GET方法的资源也可以支持HEAD方法</td>
<td>是</td>
</tr>
<tr>
<td><code>PATCH</code></td>
<td>对对象应用部分更新</td>
<td>否</td>
</tr>
<tr>
<td><code>OPTIONS</code></td>
<td>获取有关请求的信息；有关详情，请参见下文。</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="7-4-1-POST"><a href="#7-4-1-POST" class="headerlink" title="7.4.1 POST"></a>7.4.1 POST</h4><p>POST操作应支持Location响应标头，以通过Location标头指定未显式命名的任何已创建资源的位置。</p>
<p>例如，设想一个允许创建托管服务器的服务，该服务将由该服务命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://api.contoso.com/account1/servers</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">201 Created</span><br><span class="line">Location: http://api.contoso.com/account1/servers/server321</span><br></pre></td></tr></table></figure>

<p>其中 “server321”是服务分配的服务器名称。</p>
<p>服务还可以在响应中返回所创建项目的完整元数据。</p>
<h4 id="7-4-2-PATCH"><a href="#7-4-2-PATCH" class="headerlink" title="7.4.2 PATCH"></a>7.4.2 PATCH</h4><p>IETF已将PATCH标准化为用于增量更新现有对象的方法（请参阅<a href="http://tools.ietf.org/html/rfc5789">RFC 5789</a>）。符合Microsoft REST API准则的API应该支持PATCH。</p>
<h4 id="7-4-3通过PATCH创建资源（UPSERT语义）"><a href="#7-4-3通过PATCH创建资源（UPSERT语义）" class="headerlink" title="7.4.3通过PATCH创建资源（UPSERT语义）"></a>7.4.3通过PATCH创建资源（UPSERT语义）</h4><p>允许调用者在create上指定键值的服务应支持UPSERT语义，而那些必须支持使用PATCH创建资源的服务。由于PUT被定义为内容的完全替代，因此使用PUT修改数据对客户端来说很危险。不了解（并因此忽略）资源属性的客户端在尝试更新资源时不太可能在PUT上提供它们，因此可能会无意中删除这些属性。服务可以选择支持PUT更新现有资源，但如果这样做，则它们必须使用替换语义（即，在PUT之后，资源的属性必须与请求中提供的属性匹配，包括删除未提供的任何服务器属性）。</p>
<p>在UPSERT语义下，服务器将对不存在资源的PATCH调用作为“创建”处理，而对现有资源的PATCH调用则作为“更新”处理。为了确保更新请求不被视为创建请求，反之亦然，客户端可以在请求中指定前置HTTP头。如果服务包含If-Match标头，则服务不得将PATCH请求视为插入；如果服务包含包含值为“ *”的If-None-Match标头，则服务不得将PATCH请求视为更新。</p>
<p>如果服务不支持UPSERT，则对不存在的资源的PATCH调用务必导致HTTP“ 409冲突”错误。</p>
<h4 id="7-4-4-Options-和链接头"><a href="#7-4-4-Options-和链接头" class="headerlink" title="7.4.4 Options 和链接头"></a>7.4.4 Options 和链接头</h4><p>OPTIONS允许客户端至少通过返回表示该资源有效方法的Allow标头来检索有关资源的信息。</p>
<p>另外，服务应该包括一个链接头（参见<a href="http://tools.ietf.org/html/rfc5988">RFC 5988</a>），以指向相关资源的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link: &lt;&#123;help&#125;&gt;; rel=&quot;help&quot;</span><br></pre></td></tr></table></figure>

<p>其中{help}是文档资源的URL。</p>
<p>有关使用OPTIONS的示例，请参阅<a href="http://www.w3.org/TR/cors/#resource-preflight-requests">预检CORS跨域调用</a>。</p>
<h3 id="7-5标准请求头"><a href="#7-5标准请求头" class="headerlink" title="7.5标准请求头"></a>7.5标准请求头</h3><p>Microsoft REST API指南服务应使用下面的请求标头表。没有强制使用这些头，但是如果使用，则必须始终使用它们。</p>
<p>所有报头值必须遵循规范中规定的语法规则，其中定义了报头字段。<a href="https://tools.ietf.org/html/rfc7231">RFC7231</a>中定义了许多HTTP标头，但是可以在<a href="http://www.iana.org/assignments/message-headers/message-headers.xhtml">IANA标头注册表中</a>找到批准标头的完整列表。”</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Authorization</code></td>
<td>String</td>
<td>请求的授权标头</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>Date</td>
<td>基于客户端时钟的请求时间戳，采用<a href="https://tools.ietf.org/html/rfc5322#section-3.3">RFC 5322</a>日期和时间格式。服务器不应该对客户端时钟的准确性做任何假设。该报头可以包含在请求中，但提供时必须采用这种格式。提供此标头时，必须将格林威治标准时间（GMT）用作该标头的时区参考。例如：<code>Wed, 24 Aug 2016 18:41:30 GMT</code>。请注意，为此目的，GMT完全等于UTC（世界标准时间）。</td>
</tr>
<tr>
<td><code>Accept</code></td>
<td>内容类型</td>
<td>请求的响应内容类型，例如：应用程序/ xml文字/ xml应用程序/ json文字/ JavaScript（用于JSONP）根据HTTP准则，这只是一个提示，响应可能具有不同的内容类型，例如blob提取，其中成功的响应将只是blob流作为有效负载。对于遵循OData的服务，应遵循OData中指定的优先顺序。</td>
</tr>
<tr>
<td><code>Accept-Encoding</code></td>
<td>Gzip, deflate</td>
<td>如果适用，REST端点应该支持GZIP和DEFLATE编码。对于非常大的资源，服务可以忽略并返回未压缩的数据。</td>
</tr>
<tr>
<td><code>Accept-Language</code></td>
<td>“en”, “es”, etc.</td>
<td>指定响应的首选语言。不需要服务来支持此功能，但是如果服务支持本地化，则必须通过Accept-Language标头来实现。</td>
</tr>
<tr>
<td><code>Accept-Charset</code></td>
<td>字符集类型，例如“ UTF-8”</td>
<td>默认值为UTF-8，但是服务应该能够处理ISO-8859-1。</td>
</tr>
<tr>
<td><code>Content-Type</code></td>
<td>内容类型</td>
<td>请求主体的MIME类型（PUT / POST / PATCH）</td>
</tr>
<tr>
<td><code>Prefer</code></td>
<td>return=minimal，return=representation</td>
<td>如果指定了return = minimal首选项，则服务应响应成功的插入或更新而返回空主体。如果指定了return = representation，则服务应在响应中返回创建或更新的资源。如果服务具有客户端有时会从响应中受益的场景，但有时响应会对带宽造成太大的影响，则服务应支持此标头。</td>
</tr>
<tr>
<td><code>If-Match</code>, <code>If-None-Match</code> , <code>If-Range</code></td>
<td>String</td>
<td>支持使用乐观并发控制更新资源的服务必须支持If-Match标头。服务也可以使用其他与ETag相关的标头，只要它们遵循HTTP规范即可。</td>
</tr>
</tbody></table>
<h3 id="7-6标准响应头"><a href="#7-6标准响应头" class="headerlink" title="7.6标准响应头"></a>7.6标准响应头</h3><p>服务应返回以下响应标头，除非在“必需”列中注明。</p>
<table>
<thead>
<tr>
<th>响应Header</th>
<th>必要条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date</code></td>
<td>所有响应</td>
<td>根据服务器的时钟，以<a href="https://tools.ietf.org/html/rfc5322#section-3.3">RFC 5322</a>日期和时间格式处理响应的时间戳。该头必须包含在响应中。格林威治标准时间（GMT）必须用作此标头的时区参考。例如：<code>Wed, 24 Aug 2016 18:41:30 GMT</code>。请注意，为此目的，GMT完全等于UTC（世界标准时间）。</td>
</tr>
<tr>
<td><code>Content-Type</code></td>
<td>所有响应</td>
<td>内容类型</td>
</tr>
<tr>
<td><code>Content-Encoding</code></td>
<td>所有响应</td>
<td>GZIP或DEFLATE（视情况而定）</td>
</tr>
<tr>
<td><code>Preference-Applied</code></td>
<td>在请求中指定时</td>
<td>是否应用了“首选”请求标头中指示的首选项</td>
</tr>
<tr>
<td><code>ETag</code></td>
<td>当请求的资源具有实体标签时</td>
<td>ETag响应标头字段提供所请求变体的实体标签的当前值。与If-Match，If-None-Match和If-Range一起使用以实现乐观并发控制。</td>
</tr>
</tbody></table>
<h3 id="7-7自定义-Header"><a href="#7-7自定义-Header" class="headerlink" title="7.7自定义 Header"></a>7.7自定义 Header</h3><p>给定API的基本操作必须不需要自定义标头。</p>
<p>本文档中的一些准则规定了非标准HTTP标头的使用。另外，某些服务可能需要添加额外的功能，这些功能通过HTTP标头公开。以下准则有助于在使用自定义标头时保持一致性。</p>
<p>不是标准HTTP标头的标头必须具有以下两种格式之一：</p>
<ol>
<li>在IANA（<a href="http://www.ietf.org/rfc/rfc3864.txt">RFC 3864</a>）中注册为“临时”的标头的通用格式</li>
<li>标头的范围格式过于针对使用情况而无法注册</li>
</ol>
<p>下面介绍这两种格式。</p>
<h3 id="7-8指定标头作为查询参数"><a href="#7-8指定标头作为查询参数" class="headerlink" title="7.8指定标头作为查询参数"></a>7.8指定标头作为查询参数</h3><p>在某些情况下，例如AJAX客户端，某些标头会带来挑战，尤其是在进行跨域调用时，可能不支持添加标头。这样，除了标头之外，还可以将某些标头作为查询参数接受，其命名与标头相同：</p>
<p>并非所有标头都适合作为查询参数，包括大多数标准HTTP标头。</p>
<p>考虑何时接受标头作为参数的标准是：</p>
<ol>
<li>任何自定义标头也必须被接受为参数。</li>
<li>必需的标准标头可以作为参数接受。</li>
<li>具有安全敏感性的必需标头（例如，授权标头）可能不适合作为参数；服务所有者应根据具体情况进行评估。</li>
</ol>
<p>此规则的一个例外是Accept标头。通常的做法是使用具有简单名称的方案，而不是HTTP规范中针对Accept所描述的全部功能。</p>
<h3 id="7-9-PII参数"><a href="#7-9-PII参数" class="headerlink" title="7.9 PII参数"></a>7.9 PII参数</h3><p>与其组织的隐私权政策一致，客户端不应在URL中（路径或查询字符串的一部分）传输URL中的个人身份信息（PII）参数，因为此信息可能会通过客户端，网络和服务器日志以及其他机制被无意间公开。</p>
<p>因此，服务应该接受作为报头发送的PII参数。</p>
<p>但是，由于客户端或软件的限制，在许多情况下无法遵循上述建议。为了解决这些限制，服务还应该接受这些PII参数作为URL的一部分，并与本指南的其余部分保持一致。</p>
<p>接受PII参数的服务（无论是在URL中还是作为标头）均应遵守其组织的工程领导者指定的隐私权政策。这通常包括建议客户端选择标头进行传输，并且实现应遵循特殊的预防措施，以确保正确处理日志和其他服务数据收集。</p>
<h3 id="7-10响应格式"><a href="#7-10响应格式" class="headerlink" title="7.10响应格式"></a>7.10响应格式</h3><p>为了使组织拥有成功的平台，它们必须以开发人员习惯使用的格式提供数据，并以一致的方式允许开发人员使用通用代码处理响应。</p>
<p>基于Web的通信，尤其是在涉及移动或其他低带宽客户端时，由于多种原因，已朝JSON方向快速发展，包括其重量更轻的趋势以及与基于JavaScript的客户端的易用性。</p>
<p>JSON属性名称应为驼峰式。</p>
<p>服务应提供JSON作为默认编码。</p>
<h4 id="7-10-1客户指定的响应格式"><a href="#7-10-1客户指定的响应格式" class="headerlink" title="7.10.1客户指定的响应格式"></a>7.10.1客户指定的响应格式</h4><p>在HTTP中，客户端应使用Accept标头请求响应格式。这只是一个提示，服务器可以选择忽略它，即使这在行为良好的服务器中并不常见。客户端可以发送多个Accept标头，服务可以选择其中之一。</p>
<p>默认的响应格式（不提供Accept标头）应该是application / json，并且所有服务都必须支持application / json。</p>
<table>
<thead>
<tr>
<th>接受的请求头</th>
<th>响应类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>application/json</td>
<td>返回内容应该是 JSON</td>
<td>对于 <code>text/javascript</code> 可以是 JSONP 格式</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.contoso.com/v1.0/products/user</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

<h4 id="7-10-2错误条件响应"><a href="#7-10-2错误条件响应" class="headerlink" title="7.10.2错误条件响应"></a>7.10.2错误条件响应</h4><p>对于不成功的情况，开发人员应该能够编写一段代码，以在不同的Microsoft REST API准则服务之间一致地处理错误。这允许构建简单可靠的基础结构来将异常作为成功响应的独立流程来处理。以下内容基于OData v4 JSON规范。但是，它非常通用，不需要特定的OData构造。即使没有使用其他OData构造，API也应该使用这种格式。</p>
<p>错误响应必须是单个JSON对象。这个对象必须有一个名为“错误”的名称/值对。该值必须是JSON对象。</p>
<p>这个对象必须包含名称/值对，名称为“ code”和“ message”，并且可以包含名称/值对，名称为“ target”，“ details”和“ innererror”。</p>
<p>“代码”名称/值对的值是与语言无关的字符串。它的值是服务定义的错误代码，应易于阅读。与响应中指定的HTTP错误代码相比，此代码可作为错误的更具体指示。服务应该具有相对少量（大约20个）的“代码”可能值，并且所有客户端都必须能够处理所有这些值。大多数服务将需要更多数量的更特定的错误代码，这对于所有客户端而言都不是很有趣。如下所述，这些错误代码应在“内部错误”名称/值对中公开。为现有客户端可见的“代码”引入新值是一项重大更改，需要增加版本。服务可以通过将新的错误代码添加到“</p>
<p>“消息”名称/值对的值必须是人类可读的错误表示。它旨在帮助开发人员，不适合最终用户使用。希望向最终用户公开合适消息的服务必须通过<a href="http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html#_Instance_Annotations">注释</a>或自定义属性来实现。服务不应该为最终用户本地化“消息”，因为这样做可能会使值记录给可能正在记录该值的应用程序开发人员不可读，并使该值在Internet上的可搜索性降低。</p>
<p>“目标”名称/值对的值是特定错误的目标（例如，错误属性的名称）。</p>
<p>如上所述，“详细信息”名称/值对的值必须是JSON对象数组，该对象必须包含“代码”和“消息”的名称/值对，并且可以包含“目标”的名称/值对，如上所述。“详细信息”数组中的对象通常表示在请求期间发生的不同的，相关的错误。请参见下面的示例。</p>
<p>“内部错误”名称/值对的值必须是一个对象。该对象的内容是服务定义的。希望返回比根级代码更具体的错误的服务必须这样做，方法是包括“代码”的名称/值对和嵌套的“ innererror”。每个嵌套的“ innererror”对象都比其父对象表示更高级别的详细信息。在评估错误时，客户必须遍历所有嵌套的“内部错误”，并选择他们了解的最深层的错误。这种方案允许服务在层次结构中的任何位置引入新的错误代码，而不会破坏向后兼容性，只要仍然出现旧的错误代码即可。服务可以向不同的调用者返回不同级别的深度和细节。例如，在开发环境中，最深的“ 具有自定义服务器定义属性的错误类型应在服务的元数据文档中声明。请参见下面的示例。具有自定义服务器定义属性的错误类型应在服务的元数据文档中声明。请参见下面的示例。</p>
<p>错误响应可能在其任何JSON对象中包含<a href="http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html#_Instance_Annotations">注释</a>。</p>
<p>我们建议，对于可能重发的任何暂时性错误，服务应包括一个Retry-After HTTP标头，该标头指示客户端在再次尝试操作之前应等待的最小秒数。</p>
<h5 id="ErrorResponse-Object"><a href="#ErrorResponse-Object" class="headerlink" title="ErrorResponse : Object"></a>ErrorResponse : Object</h5><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>需要</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>error</code></td>
<td>Error</td>
<td>✔</td>
<td>错误对象。</td>
</tr>
</tbody></table>
<h5 id="Error-Object"><a href="#Error-Object" class="headerlink" title="Error : Object"></a>Error : Object</h5><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>需要</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>code</code></td>
<td>String (enumerated)</td>
<td>✔</td>
<td>服务器定义的一组错误代码之一。</td>
</tr>
<tr>
<td><code>message</code></td>
<td>String</td>
<td>✔</td>
<td>错误的人类可读表示。</td>
</tr>
<tr>
<td><code>target</code></td>
<td>String</td>
<td></td>
<td>错误的目标。</td>
</tr>
<tr>
<td><code>details</code></td>
<td>Error[]</td>
<td></td>
<td>有关导致此报告错误的特定错误的详细信息数组。</td>
</tr>
<tr>
<td><code>innererror</code></td>
<td>InnerError</td>
<td></td>
<td>一个对象，它包含比当前对象更多有关该错误的特定信息。</td>
</tr>
</tbody></table>
<h5 id="InnerError-Object"><a href="#InnerError-Object" class="headerlink" title="InnerError : Object"></a>InnerError : Object</h5><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>需要</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>code</code></td>
<td>String</td>
<td></td>
<td>比包含错误提供的错误代码更具体的错误代码。</td>
</tr>
<tr>
<td><code>innererror</code></td>
<td>InnerError</td>
<td></td>
<td>一个对象，它包含比当前对象更多有关该错误的特定信息。</td>
</tr>
</tbody></table>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>“内部错误”示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;BadArgument&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Previous passwords may not be reused&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;password&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;innererror&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;PasswordError&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;innererror&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;PasswordDoesNotMeetPolicy&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;minLength&quot;</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;maxLength&quot;</span>: <span class="string">&quot;64&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;characterTypes&quot;</span>: [<span class="string">&quot;lowerCase&quot;</span>,<span class="string">&quot;upperCase&quot;</span>,<span class="string">&quot;number&quot;</span>,<span class="string">&quot;symbol&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;minDistinctCharacterTypes&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;innererror&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;PasswordReuseNotAllowed&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，最基本的错误代码是“ BadArgument”，但是对于感兴趣的客户端，“ innererror”中有更具体的错误代码。该服务可能在以后的日期中添加了“ PasswordReuseNotAllowed”代码，以前仅返回了“ PasswordDoesNotMeetPolicy”。添加新的错误代码时，现有客户端不会中断，但是新客户端可以利用它。“ PasswordDoesNotMeetPolicy”错误还包括其他名称/值对，允许客户端确定服务器的配置，以编程方式验证用户的输入或在客户端自己的本地化消息传递中向用户显示服务器的约束。</p>
<p>“详细信息”示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;BadArgument&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Multiple errors in ContactInfo data&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ContactInfo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;NullValue&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;PhoneNumber&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Phone number must not be null&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;NullValue&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;LastName&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Last name must not be null&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;MalformedValue&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;Address&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Address is not valid&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，请求存在多个问题，每个错误均在“详细信息”中列出。</p>
<h3 id="7-11-HTTP状态码"><a href="#7-11-HTTP状态码" class="headerlink" title="7.11 HTTP状态码"></a>7.11 HTTP状态码</h3><p>应该使用标准的HTTP状态代码；有关更多信息，请参见HTTP状态代码定义。</p>
<h3 id="7-12客户端库可选"><a href="#7-12客户端库可选" class="headerlink" title="7.12客户端库可选"></a>7.12客户端库可选</h3><p>开发人员必须能够在多种平台和语言上进行开发，例如Windows，MacOS，Linux，C＃，Python，Node.js和Ruby。</p>
<p>应该能够从简单的HTTP工具（例如curl）访问服务，而无需花费很多精力。</p>
<p>服务开发人员门户应该提供“获取开发人员令牌”的等效功能，以促进实验和curl支持。</p>
<h2 id="8-CORS"><a href="#8-CORS" class="headerlink" title="8 CORS"></a>8 CORS</h2><p>符合Microsoft REST API准则的服务必须支持<a href="http://www.w3.org/TR/access-control/">CORS（跨源资源共享）</a>。服务应支持允许的CORS *来源，并通过有效的OAuth令牌强制执行授权。服务不应通过原始验证支持用户凭证。特殊情况可能会有例外。</p>
<h3 id="8-1客户指导"><a href="#8-1客户指导" class="headerlink" title="8.1客户指导"></a>8.1客户指导</h3><p>Web开发人员通常不需要做任何特殊的事情就可以利用CORS。所有握手步骤都作为它们进行的标准XMLHttpRequest调用的一部分而无形地发生。</p>
<p>.NET等许多其他平台都集成了对CORS的支持。</p>
<h4 id="8-1-1避免飞行前"><a href="#8-1-1避免飞行前" class="headerlink" title="8.1.1避免飞行前"></a>8.1.1避免飞行前</h4><p>由于CORS协议可以触发预检请求，这些预检请求会增加服务器的往返行程，因此对性能要求较高的应用可能会希望避免这种情况。CORS的精神是避免对旧的不具备CORS功能的浏览器能够进行的任何简单的跨域请求进行预检。所有其他请求都需要进行飞行前检查。</p>
<p>请求是“简单的”，如果其方法是GET，HEAD或POST，并且除了Accept，Accept-Language和Content-Language之外不包含任何请求标头，则避免预检。对于POST请求，还允许使用Content-Type标头，但前提是其值是“ application / x-www-form-urlencoded”，“ multipart / form-data”或“ text / plain”。对于任何其他标题或值，将发生预检请求。</p>
<h3 id="8-2服务指南"><a href="#8-2服务指南" class="headerlink" title="8.2服务指南"></a>8.2服务指南</h3><p>至少，服务必须：</p>
<ul>
<li>了解浏览器在跨域请求中发送的Origin请求标头，以及在检查访问的预检OPTIONS请求中发送的Access-Control-Request-Method请求标头。</li>
<li>如果请求中存在Origin头：<ul>
<li>如果请求使用OPTIONS方法并包含Access-Control-Request-Method标头，则它是预检请求，旨在在实际请求之前探测访问。否则，这是一个实际的请求。对于预检请求，除了执行以下添加标头的步骤之外，服务务必不要执行任何其他处理，并且必须返回200 OK。对于非预检请求，除了请求的常规处理之外，还会添加以下标头。</li>
<li>将Access-Control-Allow-Origin标头添加到响应中，该标头包含与Origin请求标头相同的值。请注意，这需要服务动态生成标头值。不需要cookie或任何其他形式的<a href="http://www.w3.org/TR/access-control/#user-credentials">用户凭证的资源</a>可以使用通配符星号（*）代替。请注意，通配符仅在此处可接受，不适用于以下所述的任何其他标头。</li>
<li>如果调用方需要访问不在<a href="http://www.w3.org/TR/access-control/#simple-header">简单响应标头</a>集中的<a href="http://www.w3.org/TR/access-control/#simple-header">响应标头</a>（缓存控制，内容语言，内容类型，过期，最后修改，实用），则添加访问控制暴露-标头标头，包含客户端应有权访问的其他响应标头名称的列表。</li>
<li>如果请求需要cookie，则添加一个Access-Control-Allow-Credentials标头设置为“ true”。</li>
<li>如果该请求是预检请求（请参阅第一个项目符号），则该服务必须：<ul>
<li>添加一个Access-Control-Allow-Headers响应标头，其中包含允许客户端使用的请求标头名称的列表。该列表仅需要包含不在<a href="http://www.w3.org/TR/access-control/#simple-header">简单请求标头</a>集中的<a href="http://www.w3.org/TR/access-control/#simple-header">标头</a>（Accept，Accept-Language，Content-Language）。如果服务接受的头没有任何限制，则该服务可以简单地返回与客户端发送的Access-Control-Request-Headers头相同的值。</li>
<li>添加一个Access-Control-Allow-Methods响应标头，其中包含允许调用方使用的HTTP方法的列表。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>添加一个Access-Control-Max-Age首选项响应标头，其中包含该首选项响应有效的秒数（因此可以在随后的实际请求之前避免使用）。请注意，虽然习惯使用较大的值，如2592000（30天），但许多浏览器会自行施加一个较低的限制（例如5分钟）。</p>
<p>由于浏览器的飞行前响应缓存非常差，因此飞行前响应带来的额外往返行程会影响性能。性能至关重要的交互式Web客户端使用的服务应避免导致预检请求的模式</p>
<ul>
<li>对于GET和HEAD调用，请避免要求不属于上述简单设置的请求标头。允许将它们作为查询参数提供。<ul>
<li>Authorization标头不是简单集的一部分，因此对于需要身份验证的资源，必须通过“ access_token”查询参数发送身份验证令牌。请注意，不建议在URL中传递身份验证令牌，因为它可能导致令牌记录在服务器日志中并暴露给有权访问这些日志的任何人。通过URL接受身份验证令牌的服务必须采取措施来减轻安全风险，例如使用短暂的身份验证令牌，禁止身份验证令牌被记录以及控制对服务器日志的访问。</li>
</ul>
</li>
<li>避免要求Cookie。如果设置了“ withCredentials”属性，则XmlHttpRequest仅在跨域请求上发送cookie。这也会导致预检请求。<ul>
<li>需要基于Cookie的身份验证的服务务必使用“动态Canary”来保护所有接受Cookie的API。</li>
</ul>
</li>
<li>对于POST调用，请在适用的情况下（“应用程序/ x-www-form-urlencoded”，“ multipart / form-data”，“ text / plain”）集中使用简单的Content-Type。任何其他Content-Type都会引发预检请求。<ul>
<li>服务不得以避免CORS飞行前请求的名义违反其他API建议。特别是，根据建议，由于内容类型，大多数POST请求实际上将需要进行预检请求。</li>
<li>如果消除预检是至关重要的，则服务可以支持替代的数据传输机制，但是必须也支持推荐的方法。</li>
</ul>
</li>
</ul>
<p>另外，在适当的服务时，可以支持JSONP模式，以进行简单的，仅限GET的跨域访问。在JSONP中，服务采用指示格式（*$ format = json<em>）的参数和指示回调（</em>$ callback = someFunc*）的参数，并返回文本/ javascript文档，该文档包含包装在具有指定名称的函数调用中的JSON响应。Wikipedia上有关JSONP的更多信息：<a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>。</p>
<h2 id="12-版本"><a href="#12-版本" class="headerlink" title="12 版本"></a>12 版本</h2><p><strong>所有符合Microsoft REST API准则的API都必须支持显式版本控制。</strong>客户端可以依靠服务保持稳定是至关重要的，服务可以添加功能并进行更改也至关重要。</p>
<h3 id="12-1版本格式"><a href="#12-1版本格式" class="headerlink" title="12.1版本格式"></a>12.1版本格式</h3><p>使用Major.Minor版本控制方案对服务进行版本控制。服务可以选择“仅主要”版本方案，在这种情况下暗含“ .0”，并且本节中的所有其他规则均适用。支持两种用于指定REST API请求版本的选项：</p>
<ul>
<li>嵌入在请求URL的路径中，位于服务根目录的末尾： <code>https://api.contoso.com/v1.0/products/users</code></li>
<li>作为URL的查询字符串参数： <code>https://api.contoso.com/products/users?api-version=1.0</code></li>
</ul>
<p>在这两个选项之间进行选择的指导如下：</p>
<ol>
<li>位于DNS端点后面的服务必须使用相同的版本控制机制。</li>
<li>在这种情况下，跨端点的一致用户体验至关重要。Microsoft REST API准则工作组建议在未与组织领导团队进行明确对话的情况下，不要创建新的顶级DNS终结点。</li>
<li>保证其REST API的URL路径稳定的服务，即使通过API的未来版本，也可以采用查询字符串参数机制。这意味着在API交付后，API中描述的关系的命名和结构就无法发展，即使是在具有重大更改的版本之间也是如此。</li>
<li>无法确保未来版本中URL路径稳定性的服务必须将版本嵌入URL路径中。</li>
</ol>
<h4 id="12-1-1组版本控制"><a href="#12-1-1组版本控制" class="headerlink" title="12.1.1组版本控制"></a>12.1.1组版本控制</h4><p>组版本控制是一项可选功能，可以使用查询字符串参数机制在服务上提供。组版本允许在通用版本名称下对API端点进行逻辑分组。这使开发人员可以查找单个版本号，并在多个端点之间使用它。组版本号是众所周知的，服务应该拒绝任何无法识别的值。</p>
<p>在内部，服务将采用组版本并将其映射到适当的Major.Minor版本。</p>
<p>组版本格式定义为YYYY-MM-DD，例如2012年12月7日为2012-12-07。此日期版本格式仅适用于组版本，不应用作替代Major.Minor版本。</p>
<h5 id="12-1-1-1组版本控制的示例"><a href="#12-1-1-1组版本控制的示例" class="headerlink" title="12.1.1.1组版本控制的示例"></a>12.1.1.1组版本控制的示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Group      | Major.Minor</span><br><span class="line">---------- | -----------</span><br><span class="line">2012-12-01 | 1.0</span><br><span class="line">           | 1.1</span><br><span class="line">           | 1.2</span><br><span class="line">2013-03-21 | 1.0</span><br><span class="line">           | 2.0</span><br><span class="line">           | 3.0</span><br><span class="line">           | 3.1</span><br><span class="line">           | 3.2</span><br><span class="line">           | 3.3</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>版本格式</th>
<th>例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>{groupVersion}</td>
<td>2013-03-21，2012-12-01</td>
<td>3.3、1.2</td>
</tr>
<tr>
<td>{majorVersion}</td>
<td>3</td>
<td>3.0</td>
</tr>
<tr>
<td>{majorVersion}。{minorVersion}</td>
<td>1.2</td>
<td>1.2</td>
</tr>
</tbody></table>
<p>客户端可以指定组版本或专业版本。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://api.contoso.com/acct1/c1/blob2?api-version=1.0</span><br><span class="line">PUT http://api.contoso.com/acct1/c1/b2?api-version=2011-12-07</span><br></pre></td></tr></table></figure>

<h3 id="12-2何时版本"><a href="#12-2何时版本" class="headerlink" title="12.2何时版本"></a>12.2何时版本</h3><p>服务必须响应任何重大的API更改而增加其版本号。请参阅以下部分，详细讨论什么是重大更改。如果需要，服务也可以增加其版本号以进行不间断的更改。</p>
<p>使用新的主要版本号表示将来将不再支持现有客户端。引入新的主要版本时，服务必须为现有客户提供清晰的升级路径，并制定与业务组策略一致的弃用计划。服务应将新的次要版本号用于所有其他更改。</p>
<p>版本化服务的在线文档务必指出每个先前API版本的当前支持状态，并提供最新版本的路径。</p>
<h3 id="12-3重大更改的定义"><a href="#12-3重大更改的定义" class="headerlink" title="12.3重大更改的定义"></a>12.3重大更改的定义</h3><p>对API合同的更改被视为重大更改。影响API向后兼容性的更改是一项重大更改。</p>
<p>团队可以根据他们的业务需求定义向后兼容性。例如，Azure将响应中的新JSON字段定义为不向后兼容。Office 365具有向后兼容性的较宽松定义，并允许将JSON字段添加到响应中。</p>
<p>重大更改的清晰示例：</p>
<ol>
<li>删除或重命名API或API参数</li>
<li>现有API的行为更改</li>
<li>错误代码和故障合同的变更</li>
<li>任何违反<a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment">最小惊讶原则的</a>东西</li>
</ol>
<p>服务必须明确定义其重大更改的定义，尤其是在向JSON响应中添加新字段以及使用默认字段添加新API参数方面。与其他服务一起位于DNS端点后面的服务在定义合同可扩展性时必须保持一致。</p>
<p><a href="http://docs.oasis-open.org/odata/odata/v4.0/errata02/os/complete/part1-protocol/odata-v4.0-errata02-os-part1-protocol-complete.html#_Toc406398209">OData V4规范本节中</a>描述的适用更改应被视为所有服务必须考虑的重大更改的最低要求的一部分。</p>
<h2 id="13-长期支持"><a href="#13-长期支持" class="headerlink" title="13 长期支持"></a>13 长期支持</h2><p>长时间运行的操作（有时称为异步操作）对不同的人意味着不同的意思。本节针对不同类型的长时间运行制定了指南，并介绍了这些类型的运行的线路协议和最佳实践。</p>
<ol>
<li>一个或多个客户端必须能够同时监视和操作同一资源。</li>
<li>系统状态应始终可发现和可测试。即使操作跟踪资源不再处于活动状态，客户端也应该能够确定系统状态。查询长时间运行状态的操作本身应该利用网络原理。即具有统一接口语义的定义良好的资源。客户端可以在某些资源上发出GET来确定长时间运行的状态</li>
<li>长期运行的操作应该为希望“解雇”的客户以及希望积极监控结果并根据结果采取行动的客户服务。</li>
<li>取消并不明确意味着回滚。在每个API定义的情况下，这可能意味着回滚，补偿，完成或部分完成等。取消操作之后，客户不应将服务恢复到允许继续服务的一致状态的责任。</li>
</ol>
<h3 id="13-1基于资源的长期运行（RELO）"><a href="#13-1基于资源的长期运行（RELO）" class="headerlink" title="13.1基于资源的长期运行（RELO）"></a>13.1基于资源的长期运行（RELO）</h3><p>基于资源的建模是将操作的状态编码在资源中，并且所使用的有线协议是标准同步协议。在此模型中，状态转移定义明确，目标状态定义类似。</p>
<p><em>对于长时间运行的操作，这是首选模型，应尽可能使用它。</em>避免了LRO Wire Protocol的复杂性和机制，对于我们的用户和工具链而言，事情变得更加简单。</p>
<p>一个示例可能是计算机重新引导，该操作本身同步完成，但是虚拟机资源上的GET操作将具有“状态：正在重新引导”，“状态：正在运行”，可以随时查询。</p>
<p>该模型可以集成推送通知。</p>
<p>虽然大多数操作可能是POST语义，但除POST语义服务外，MAY还可以通过路由支持PUT语义，以简化其API。例如，想要创建一个名为“ db1”的数据库的用户可以调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT https://api.contoso.com/v1.0/databases/db1</span><br></pre></td></tr></table></figure>

<p>在这种情况下，数据库段正在处理PUT操作。</p>
<p>服务也可以使用下面定义的混合。</p>
<h3 id="13-2分步长时间运行"><a href="#13-2分步长时间运行" class="headerlink" title="13.2分步长时间运行"></a>13.2分步长时间运行</h3><p>逐步操作是一种需要很长且通常是不可预测的时间来完成的操作，并且不提供在资源中建模的状态转换。本节概述了服务应使用的方法来公开这些长时间运行的操作。</p>
<p>服务可以公开逐步操作。</p>
<blockquote>
<p>逐步长时间运行的操作有时称为“异步”操作。这会造成混乱，因为它将平台的元素（“异步/等待”，“承诺”，“未来”）与API操作的元素混合在一起。本文档使用术语“逐步运行”或经常仅使用“逐步操作”以避免混淆“异步”一词。</p>
</blockquote>
<p>服务必须对逐步请求执行尽可能多的同步验证。服务必须以同步方式确定返回错误的优先级，目标是使用长时间运行的操作有线协议仅处理“有效”操作。</p>
<p>对于定义为逐步长期运行操作的API，服务必须经过逐步长期运行操作流程，即使该操作可以立即完成。换句话说，API必须采用并坚持LRO模式，并且不得根据情况更改模式。</p>
<h4 id="13-2-1-PUT"><a href="#13-2-1-PUT" class="headerlink" title="13.2.1 PUT"></a>13.2.1 PUT</h4><p>服务可以启用用于实体创建的PUT请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT https://api.contoso.com/v1.0/databases/db1</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<em>数据库</em>段正在处理PUT操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line">Operation-Location: https://api.contoso.com/v1.0/operations/123</span><br></pre></td></tr></table></figure>

<p>对于需要返回此处创建201的服务，请使用下面描述的混合流程。</p>
<p>202已接受不返回任何正文。201 Created案例应返回目标资源的主体。</p>
<h4 id="13-2-2-POST"><a href="#13-2-2-POST" class="headerlink" title="13.2.2 POST"></a>13.2.2 POST</h4><p>服务可以启用用于实体创建的POST请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://api.contoso.com/v1.0/databases/</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;fileName&quot;: &quot;someFile.db&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line">Operation-Location: https://api.contoso.com/v1.0/operations/123</span><br></pre></td></tr></table></figure>

<h4 id="13-2-3-POST，混合模型"><a href="#13-2-3-POST，混合模型" class="headerlink" title="13.2.3 POST，混合模型"></a>13.2.3 POST，混合模型</h4><p>服务可以对创建资源的集合的POST请求进行同步响应，即使在生成响应时并未完全创建资源。为了使用这种模式，响应必须包括不完整资源的表示和不完整资源的指示。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://api.contoso.com/v1.0/databases/ HTTP/1.1</span><br><span class="line">Host: api.contoso.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;fileName&quot;: &quot;someFile.db&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务响应说数据库已经创建，但是通过包含Operation-Location标头指示请求未完成。在这种情况下，响应有效负载中的状态属性还指示操作尚未完全完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Location: https://api.contoso.com/v1.0/databases/db1</span><br><span class="line">Operation-Location: https://api.contoso.com/v1.0/operations/123</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;databaseName&quot;: &quot;db1&quot;,</span><br><span class="line">  &quot;color&quot;: &quot;red&quot;,</span><br><span class="line">  &quot;Status&quot;: &quot;Provisioning&quot;,</span><br><span class="line">  [ … other fields for &quot;database&quot; …]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-2-4-操作资源"><a href="#13-2-4-操作资源" class="headerlink" title="13.2.4 操作资源"></a>13.2.4 操作资源</h4><p>服务可以在租户级别提供“ / operations”资源。</p>
<p>提供“ /operations”资源的服务必须提供GET语义。GET必须枚举遵循标准分页，排序和过滤语义的操作集。此操作的默认排序顺序必须为：</p>
<table>
<thead>
<tr>
<th>主要排序</th>
<th>次要排序</th>
</tr>
</thead>
<tbody><tr>
<td>未开始的操作</td>
<td>操作创建时间</td>
</tr>
<tr>
<td>运作中</td>
<td>操作创建时间</td>
</tr>
<tr>
<td>完成的操作</td>
<td></td>
</tr>
</tbody></table>
<p>请注意，“完成的操作”是目标状态（请参见下文），实际上可以是几个不同的状态中的任何一个，例如“成功”，“已取消”，“失败”等。</p>
<h4 id="13-2-5操作资源"><a href="#13-2-5操作资源" class="headerlink" title="13.2.5操作资源"></a>13.2.5操作资源</h4><p>操作是跟踪逐步运行的长期操作的用户可访问资源。操作必须支持GET语义。针对某个操作的GET操作务必返回：</p>
<ol>
<li>操作资源，其状态以及与特定API相关的任何扩展状态。</li>
<li>200 OK作为响应代码。</li>
</ol>
<p>服务可以通过在操作上暴露DELETE来支持取消操作。如果支持，则DELETE操作必须是幂等的。</p>
<blockquote>
<p>注意：从API设计的角度来看，取消并不明确意味着回滚。在按API定义的情况下，这可能意味着回滚，补偿或完成或部分完成等。在取消操作之后，客户不应将服务返回到允许继续提供服务的一致状态的责任。</p>
</blockquote>
<p>不支持取消操作的服务必须在发生DELETE时返回405 Method Not Allowed。</p>
<p>操作必须支持以下状态：</p>
<ol>
<li>没有开始</li>
<li>运行</li>
<li>成功。终端状态。</li>
<li>失败了 终端状态。</li>
</ol>
<p>服务可以添加其他状态，例如“已取消”或“部分完成”。支持取消的服务必须充分描述其取消，以便可以准确地确定系统状态并可以运行任何补偿操作。</p>
<p>支持其他状态的服务应考虑以下规范名称列表，并尽可能避免创建新名称：取消，取消，中止，中止，墓碑，删除，删除。</p>
<p>一个操作必须包含以下信息，并在GET响应中提供以下信息：</p>
<ol>
<li>创建操作的时间戳。</li>
<li>当前状态输入的时间戳。</li>
<li>操作状态（未启动/正在运行/已完成）。</li>
</ol>
<p>服务可以在操作中添加其他特定于API的字段。返回的操作状态JSON如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;createdDateTime&quot;: &quot;2015-06-19T12-01-03.45Z&quot;,</span><br><span class="line">  &quot;lastActionDateTime&quot;: &quot;2015-06-19T12-01-03.45Z&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;notstarted | running | succeeded | failed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13-2-5-1完成百分比"><a href="#13-2-5-1完成百分比" class="headerlink" title="13.2.5.1完成百分比"></a>13.2.5.1完成百分比</h5><p>有时，服务无法完全准确地知道操作何时完成。这使得使用Retry-After标头有问题。在这种情况下，服务可以在operationStatus JSON中包含完成百分比字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   “ createdDateTime ”：“ 2015-06-19T12-01-03.45Z ”，</span><br><span class="line">   “ percentComplete ”：“ 50 ”，</span><br><span class="line">   “ status ”：“ running ” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，服务器已向客户端指示长时间运行的操作已完成50％。</p>
<h5 id="13-2-5-2目标资源位置"><a href="#13-2-5-2目标资源位置" class="headerlink" title="13.2.5.2目标资源位置"></a>13.2.5.2目标资源位置</h5><p>对于产生或操纵资源的操作，服务必须在操作完成后的状态中包含目标资源位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;createdDateTime&quot;: &quot;2015-06-19T12-01-03.45Z&quot;,</span><br><span class="line">  &quot;lastActionDateTime&quot;: &quot;2015-06-19T12-06-03.0024Z&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;succeeded&quot;,</span><br><span class="line">  &quot;resourceLocation&quot;: &quot;https://api.contoso.com/v1.0/databases/db1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-2-6删除操作"><a href="#13-2-6删除操作" class="headerlink" title="13.2.6删除操作"></a>13.2.6删除操作</h4><p>服务可以选择支持逻辑删除操作。服务可以在服务定义的一段时间后选择删除逻辑删除。</p>
<h4 id="13-2-7典型流程，轮询"><a href="#13-2-7典型流程，轮询" class="headerlink" title="13.2.7典型流程，轮询"></a>13.2.7典型流程，轮询</h4><ul>
<li>客户端通过使用POST调用动作来调用逐步操作</li>
<li>服务器必须通过响应202接受的状态码来指示请求已开始。响应应包含位置标头，该标头包含一个URL，客户端应等待Retry-After标头中指定的秒数后，客户端应轮询结果。</li>
<li>客户端轮询该位置，直到从服务器收到200 OK响应。</li>
</ul>
]]></content>
      <tags>
        <tag>api-design</tag>
      </tags>
  </entry>
  <entry>
    <title>PayPal API 设计原则</title>
    <url>/2020/09/01/api-design/paypal_api_style_guide/</url>
    <content><![CDATA[<blockquote>
<p>本文是 <a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">API Design Guidelines</a><br>的翻译，仅供学习交流。如有翻译不当，请斧正。所有权归原作者，侵删。</p>
</blockquote>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>PayPal 平台是可重用服务的集合，这些服务封装了明确定义的业务功能。鼓励开发人员通过应用程序编程接口（API）访问这些功能，以实现一致的设计模式和原理。通过将多个互补功能组合为构建块，以提供出色的开发人员体验以及快速组成复杂业务流程的能力。</p>
<p>PayPal API 尽可能地遵循 <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">RESTful</a> 架构风格。为了达到此目标，我们开发了一组适用于 RESTful API 设计的规则、标准和约定。以用来帮助设计和维护数百个 API ，并经过几年的发展以满足各种用例的需求。</p>
<p>我们分享这些指导方针是为了帮助传播良好的 API 设计实践。我们已经从更广泛的社区中广泛地吸取了经验，并尽力回馈。该文档尽可能通用，以便于和您在项目中正在使用的原则合并。如果您有任何更新、建议或您想贡献的补充，请随时提交PR或创建一个ISSUE 。</p>
<span id="more"></span>

<h3 id="1-文档语义，格式和命名"><a href="#1-文档语义，格式和命名" class="headerlink" title="1. 文档语义，格式和命名"></a>1. 文档语义，格式和命名</h3><p>本文档中的关键字“必须(MUST)”，“不得(MUST NOT)”，“必需(REQUIRED)”，“应该(SHALL)”，“不应该(SHALL NOT)”，“应该(SHOULD)”，“不应该(SHOULD NOT)”，“推荐(RECOMMENDED)”，“可能(MAY)”和“可选(OPTIONAL)”按照<a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119中的</a>描述进行解释。</p>
<p>单词“ REST”和“ RESTful”必须按此处所示编写，代表所有大写字母的首字母缩写。“ JSON”，“ XML”和其他首字母缩写也是如此。</p>
<p>机器可读的文本（例如URL，HTTP动词和源代码）以固定宽度的字体表示。</p>
<p>包含可变块的URI是根据<a href="https://tools.ietf.org/html/rfc6570">URI模板RFC 6570</a>指定的。例如，包含名为 account_id 的变量的URL将显示为<a href="https://foo.com/accounts//%7Baccount_id/%7D/%E3%80%82">https://foo.com/accounts/\{account_id\}/。</a></p>
<p>HTTP标头以 camelCase + 连字符的语法编写，例如 Foo-Request-Id 。</p>
<h3 id="2-贡献者"><a href="#2-贡献者" class="headerlink" title="2. 贡献者"></a>2. 贡献者</h3><p><a href="https://www.linkedin.com/in/sanjaydalal">Sanjay Dalal</a>（前成员：PayPal API平台），<a href="https://es.linkedin.com/in/jasonhnaustin">Jason Harmon</a>（前成员：PayPal API平台），<a href="https://www.linkedin.com/in/erik-hogan-81431">Erik Hogan</a>（PayPal API平台），<a href="https://www.linkedin.com/in/jayadeba-jena-1a6a0020">Jayadeba Jena</a>（PayPal API平台），<a href="https://www.linkedin.com/in/nikhil-kolekar-28627a2/">Nikhil Kolekar</a>（PayPal API平台），<a href="https://www.linkedin.com/in/gaganmaheshwari">Gagan Maheshwari</a>（前者）成员：PayPal API平台），<a href="http://linkedin.com/in/mgmckenna">Michael McKenna</a>（PayPal全球化），<a href="https://www.linkedin.com/in/gbpetkov">George Petkov</a>（前成员：PayPal API平台）和Andrew Todd（PayPal Credit）。</p>
<h2>目录</h2>

<p>[TOC]</p>
<h2 id="二、指南解释"><a href="#二、指南解释" class="headerlink" title="二、指南解释"></a>二、指南解释</h2><h3 id="1-关键术语"><a href="#1-关键术语" class="headerlink" title="1. 关键术语"></a>1. 关键术语</h3><h4 id="1-1-资源"><a href="#1-1-资源" class="headerlink" title="1.1 资源"></a>1.1 资源</h4><p>REST中信息的关键抽象是一种资源。根据<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2">Fielding的论文5.2节</a>，可以命名的任何信息都可以是资源：文档或图像，临时服务（例如“洛杉矶今天的天气”），其他资源的集合，非虚拟对象（例如一个人），等等。资源是到一组实体的概念映射，而不是在任何特定时间点对应于该映射的实体。更准确地说，资源R是随时间变化的隶属函数 <code>MR(t)</code> ，用于将时间 <code>t</code> 映射到等效的一组实体或值。集合中的值可以是资源表示和/或资源标识符。</p>
<p>资源也可以映射到空集，从而允许在存在任何概念之前就对该概念进行引用。</p>
<h4 id="1-2-资源标识符"><a href="#1-2-资源标识符" class="headerlink" title="1.2 资源标识符"></a>1.2 资源标识符</h4><p>REST 使用资源标识符来标识组件之间交互中涉及的特定资源实例。命名机构（例如提供 API 的组织）分配了资源标识符以使其有可能引用资源，它负责维护映射随时间的语义有效性（确保成员资格函数不变）。—— <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2">菲尔丁的论文第5.2节</a></p>
<h4 id="1-3-表示"><a href="#1-3-表示" class="headerlink" title="1.3 表示"></a>1.3 表示</h4><p>REST 组件通过使用表示形式来捕获资源的当前状态或预期状态并在组件之间传输该表示形式，从而对资源执行操作。一个表示形式是一个字节序列，外加描述这些字节的表示形式元数据 —— <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2">Fielding论文第5.2节</a>。</p>
<h4 id="1-4-域"><a href="#1-4-域" class="headerlink" title="1.4 域"></a>1.4 域</h4><p>根据 Wikipedia 所说，<a href="https://en.wikipedia.org/wiki/Domain_model">领域模型</a>是一个抽象系统，描述了知识，影响或活动领域的选定方面。这些概念包括业务中涉及的数据，以及业务针对该数据使用的规则。例如，PayPal 域模型包括诸如支付，风险，合规性，身份，客户支持等域。</p>
<h4 id="1-5-功能"><a href="#1-5-功能" class="headerlink" title="1.5 功能"></a>1.5 功能</h4><p>能力代表组织业务逻辑的面向业务和面向客户的视图。功能可用于组织 API 组合，作为其系统的稳定，业务驱动的视图，可由客户和经验消耗。能力的示例包括：合规性，信用，身份，零售和风险等。</p>
<p>功能驱动界面，而域则更粗糙，并且更接近代码和组织的结构。从服务的角度来看，能力和领域被视为正交的问题。</p>
<h4 id="1-6-命名空间"><a href="#1-6-命名空间" class="headerlink" title="1.6 命名空间"></a>1.6 命名空间</h4><p>功能推动了 API 产品组合中的服务建模和名称空间问题。命名空间是业务能力模型的一部分。名称空间的示例包括：合规性，设备，转移，信用，限制等。</p>
<p>命名空间应反映逻辑上将一组业务功能分组的域。域定义应反映客户对平台功能组织方式的看法。请注意，这些可能不一定反映公司的层次结构，组织或（现有）代码结构。在某些情况下，从定义上可以反映目标，面向客户的平台组织模型的意义上说，领域定义是理想的。底层服务实现和组织结构可能需要迁移以反映这些边界。</p>
<h4 id="1-7-服务"><a href="#1-7-服务" class="headerlink" title="1.7 服务"></a>1.7 服务</h4><p>服务提供了用于访问和操纵<a href="#resource">资源</a>值集的通用 API  ，无论成员资格函数的定义方式或处理请求的软件类型如何。服务是可以执行许多功能的通用软件。因此，考虑存在的不同类型的服务具有启发性。</p>
<p>从逻辑上讲，我们可以将公开的服务和 API 分为两类：</p>
<ol>
<li>**功能 API **是实现通用，可重用业务功能的服务所公开的公共API。</li>
<li><strong>特定</strong>于**体验的 API **建立在功能API的基础上，并公开可能针对特定渠道的功能，或针对通用能力的特定于上下文的专业化而优化的功能。上下文信息可能与时间，位置，设备，通道，身份，用户，角色，特权级别等有关。</li>
</ol>
<h5 id="1-7-1-基于功能的服务和-API"><a href="#1-7-1-基于功能的服务和-API" class="headerlink" title="1.7.1 基于功能的服务和 API"></a>1.7.1 基于功能的服务和 API</h5><p>功能 API 是可重用业务功能的公共接口。<em>公开</em>暗示这些 API 仅限于供前端体验，外部使用者或来自不同域的内部使用者使用的接口。</p>
<h5 id="1-7-2-基于体验的服务和-API"><a href="#1-7-2-基于体验的服务和-API" class="headerlink" title="1.7.2 基于体验的服务和 API"></a>1.7.2 基于体验的服务和 API</h5><p>特定于体验的服务在核心功能上提供了最少的附加业务逻辑，并且主要提供了转换和轻型编排，以根据特定体验，渠道或设备的需求量身定制交互。它们的输入/输出功能仅限于服务呼叫。</p>
<h4 id="1-8-客户端，API-客户端，API-使用者"><a href="#1-8-客户端，API-客户端，API-使用者" class="headerlink" title="1.8 客户端，API 客户端，API 使用者"></a>1.8 客户端，API 客户端，API 使用者</h4><p>调用API请求并使用API响应的实体。</p>
<h2 id="三、服务设计原则"><a href="#三、服务设计原则" class="headerlink" title="三、服务设计原则"></a>三、服务设计原则</h2><p>本节阐述指导服务设计的原则，这些服务向内部和外部开发人员，邻接，合作伙伴和关联公司公开API。服务是指与特定功能有关的功能，以API形式公开。</p>
<p>以下是服务的核心设计原则。</p>
<h3 id="1-松耦合"><a href="#1-松耦合" class="headerlink" title="1. 松耦合"></a>1. 松耦合</h3><p><strong>服务和消费者必须彼此松散耦合。</strong></p>
<p>耦合是指两件事之间的联系或关系。耦合程度可与依赖程度相媲美。该原则提倡服务契约的设计，并始终强调减少（<em>放松</em>）服务契约，其实施和服务使用者之间的依赖性。</p>
<p>松散耦合的原理促进了服务逻辑和实现的独立设计和发展，同时仍然强调了与已经依赖该服务功能的消费者之间的基线互操作性。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务契约不应公开实施细节</li>
<li>服务契约可以发展而不会影响现有消费者</li>
<li>特定域中的服务可以独立于其他域发展</li>
</ul>
<h3 id="2-封装形式"><a href="#2-封装形式" class="headerlink" title="2. 封装形式"></a>2. 封装形式</h3><p><strong>域服务只能通过其他服务契约访问其不拥有的数据和功能。</strong></p>
<p>服务公开的功能包括其拥有和实现的功能和数据，以及不依赖于它的功能和数据。该原则主张，服务依赖和不拥有的任何功能或数据都只能通过服务契约来访问。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务具有明确的隔离边界-在功能和数据方面明确的所有权范围</li>
<li>服务无法公开其不直接拥有的数据</li>
</ul>
<h3 id="3-稳定性"><a href="#3-稳定性" class="headerlink" title="3. 稳定性"></a>3. 稳定性</h3><p><strong>服务契约必须稳定。</strong></p>
<p>服务的设计方式必须使其所暴露的契约对现有客户仍然有效。如果服务契约需要以与消费者不兼容的方式发展，则应清楚地传达这一点。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>现有的客户服务必须在记录的时间内得到支持</li>
<li>必须以不影响现有消费者的方式引入其他功能</li>
<li>必须明确规定弃用和迁移政策以设定消费者的期望</li>
</ul>
<h3 id="4-可重用"><a href="#4-可重用" class="headerlink" title="4. 可重用"></a>4. 可重用</h3><p><strong>服务必须开发为可在多个上下文中被多个使用者重用。</strong></p>
<p>API平台的主要目标是通过使用和组合服务来使应用程序能够快速，经济高效地开发。只有在为多个用例和多个使用者灵活地开发了服务契约的情况下才有可能。该原则主张服务的开发方式应使其能够被多个消费者和在多种环境中使用，其中某些环境可能会随着时间而发展。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务契约不仅应针对即时环境而设计，还应具有支持和/或可扩展性，以供多个消费者在不同环境中使用</li>
<li>服务契约可能需要随着时间的推移逐步发展以支持多种环境和消费者</li>
</ul>
<h3 id="5-基于契约"><a href="#5-基于契约" class="headerlink" title="5. 基于契约"></a>5. 基于契约</h3><p><strong>功能和数据只能通过标准化服务契约公开。</strong></p>
<p>服务通过服务契约公开其目的和功能。服务契约包括功能方面，非功能方面（例如可用性，响应时间）和业务方面（例如每次通话费用，条款和条件）。<em>标准化</em>意味着服务契约必须符合契约设计标准。</p>
<p>该原则主张所有功能和数据都只能通过标准化服务契约公开。因此，服务的消费者只能通过服务契约来理解和访问功能和数据。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>在服务契约之外无法理解或访问功能和数据</li>
<li>每条数据（例如在数据存储中管理的数据）仅由一项服务拥有</li>
</ul>
<h3 id="6-一致性"><a href="#6-一致性" class="headerlink" title="6. 一致性"></a>6. 一致性</h3><p><strong>服务必须遵循一组通用的规则，交互样式，词汇和共享类型。</strong></p>
<p>一组规则规定了服务的定义，以便以一致的方式公开服务。通过减少新服务使用者的学习曲线，该原理提高了 API 平台的易用性。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>为服务规定了一套标准</li>
<li>服务应使用通用和共享词典中的词汇</li>
<li>兼容的交互样式，服务粒度和共享类型是实现完全互操作性和简化服务组合的关键</li>
</ul>
<h3 id="7-使用方便"><a href="#7-使用方便" class="headerlink" title="7. 使用方便"></a>7. 使用方便</h3><p><strong>服务必须易于使用并在使用者（和应用程序）中组成。</strong></p>
<p>使用困难且耗时的服务会通过鼓励消费者找到访问相同功能的替代机制来降低微服务架构的优势。可组合性意味着可以轻松组合服务，因为服务合同和访问协议是一致的，并且不必对每个服务合同有不同的理解。 </p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务合同易于发现和理解</li>
<li>服务合同和协议在可能的所有方面都是一致的，例如，标识和认证机制，错误语义，通用类型用法，分页等。</li>
<li>服务具有明确的所有权，因此消费者提供者可以就 SLA ，要求和问题与服务所有者联系</li>
<li>消费者提供者可以轻松集成，测试和部署使用此服务的消费者</li>
<li>消费者提供商可以轻松监控服务的非功能性方面</li>
</ul>
<h3 id="8-可外部化"><a href="#8-可外部化" class="headerlink" title="8. 可外部化"></a>8. 可外部化</h3><p><strong>服务的设计必须使其提供的功能易于外部化。</strong></p>
<p>开发了一种服务以供可能来自另一个域或团队，另一个业务部门或另一个公司的消费者使用。在所有这些情况下，公开的功能都是相同的。更改的是访问机制或服务执行的策略，例如身份验证，授权和速率限制。由于公开的功能是相同的，因此应设计一次服务，然后通过适当的策略根据业务需求将其外部化。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务接口必须从域模型及其旨在支持的预期用例中得出</li>
<li>支持的服务合同和访问（绑定）协议必须满足消费者的需求</li>
<li>服务的外部化不得要求重新实现或更改服务合同</li>
</ul>
<h2 id="四、HTTP方法，标头和状态"><a href="#四、HTTP方法，标头和状态" class="headerlink" title="四、HTTP方法，标头和状态"></a>四、HTTP方法，标头和状态</h2><h3 id="1-数据资源和HTTP方法"><a href="#1-数据资源和HTTP方法" class="headerlink" title="1. 数据资源和HTTP方法"></a>1. 数据资源和HTTP方法</h3><h4 id="1-1-业务能力和资源建模"><a href="#1-1-业务能力和资源建模" class="headerlink" title="1.1 业务能力和资源建模"></a>1.1 业务能力和资源建模</h4><p>组织的各种业务<a href="#%E5%8A%9F%E8%83%BD">功能</a>通过API公开为一组<a href="#%E8%B5%84%E6%BA%90">资源</a>。功能不得在所有 API 之间重复；而是期望在各个用例之间按需重新使用资源（例如，用户帐户，信用卡等）。</p>
<h4 id="1-2-HTTP方法"><a href="#1-2-HTTP方法" class="headerlink" title="1.2 HTTP方法"></a>1.2 HTTP方法</h4><p>大多数服务很容易落入标准数据资源模型中，在该模型中，主要操作可以用首字母缩写 CRUD （创建，读取，更新和删除）表示。这些很好地映射到标准 HTTP 动词。</p>
<table>
<thead>
<tr>
<th>HTTP方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>GET</code></td>
<td>要<strong>获取</strong>的资源。</td>
</tr>
<tr>
<td><code>POST</code></td>
<td>要<strong>创建</strong>一个资源，或<em>执行</em>上的资源的复杂的操作。</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td>要<strong>更新</strong>的资源。</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>要<strong>删除</strong>的资源。</td>
</tr>
<tr>
<td><code>PATCH</code></td>
<td>对资源执行<strong>部分更新</strong>。</td>
</tr>
</tbody></table>
<p>调用的实际操作必须与上表中定义的HTTP方法语义相匹配。</p>
<ul>
<li>该 <strong><code>GET</code></strong> 方法一定不能有副作用。它不得更改基础资源的状态。</li>
<li><code>POST</code> ：方法应用于在集合中创建新资源。<ul>
<li><strong>示例：</strong>要在文件上添加信用卡， <code>POST https://api.foo.com/v1/vault/credit-cards</code> </li>
<li>幂等语义：如果这是同一调用（包括 <a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#http-custom-headers"><code>Foo-Request-Id</code></a> 标头）的后续执行，并且已经创建了资源，则请求应该是幂等的。</li>
</ul>
</li>
<li>该 <code>POST</code> 方法应该用于创建一个新的子资源并建立其与主资源的关系。<ul>
<li><strong>示例：</strong>要退还交易ID 12345的付款，请执行以下操作：<code>POST https://api.foo.com/v1/payments/payments/12345/refund</code> </li>
</ul>
</li>
<li>该 <strong><code>POST</code></strong> 方法可以与操作名称一起用于复杂的操作中。这也称为<a href="https://github.com/paypal/api-standards/blob/master/patterns.md#controller-resource"><em>控制器模式</em></a>，被认为是 RESTful 模型的例外。它更适用于以下情况：资源代表业务流程，而操作是作为其一部分执行的步骤或动作。欲了解更多信息，请参见<a href="http://techbus.safaribooksonline.com/book/web-development/web-services/9780596809140">REST Web服务食谱</a>中的 <a href="http://techbus.safaribooksonline.com/9780596809140/chapter-identifying-resources">2.6节</a>。</li>
<li>该 <strong><code>PUT</code></strong> 方法应该用于更新资源属性或建立从资源到现有子资源的关系；它使用对子资源的引用来更新主资源。</li>
</ul>
<h4 id="1-3-处理中"><a href="#1-3-处理中" class="headerlink" title="1.3 处理中"></a>1.3 处理中</h4><p>在所有这些准则中，都假定必须使用 <a href="http://json.org/">JavaScript Object Notation（JSON）</a> 发送请求主体和响应主体。JSON 是由无序键值对组成的对象的轻量级数据表示形式。 JSON 可以表示四种原始类型（字符串，数字，布尔值和null）和两种结构化类型（对象和数组）。处理 API 方法调用时，应遵循以下准则。</p>
<h4 id="1-4-数据模型"><a href="#1-4-数据模型" class="headerlink" title="1.4 数据模型"></a>1.4 数据模型</h4><p>用于表示的数据模型必须符合 <a href="https://tools.ietf.org/html/rfc7159">RFC 7159中</a> 所述的 JSON 数据交换格式。</p>
<h4 id="1-5-序列化"><a href="#1-5-序列化" class="headerlink" title="1.5 序列化"></a>1.5 序列化</h4><ul>
<li>资源端点必须支持 <code>application/json</code> 作为内容类型。</li>
<li>如果 <code>Accept</code> 报头被发送并且 <code>application/json</code> 不是可接受的响应，则 <code>406 Not Acceptable</code> 必须返回错误。</li>
</ul>
<h4 id="1-6-输入和输出严格度"><a href="#1-6-输入和输出严格度" class="headerlink" title="1.6 输入和输出严格度"></a>1.6 输入和输出严格度</h4><p>API 在产生的信息中必须严格，并且在使用时也应严格。</p>
<p>由于我们正在处理编程接口，因此我们需要尽可能地避免猜测发送给我们的内容的含义。鉴于集成对于开发人员来说通常是一次性的任务，并且我们提供了良好的文档，所以我们必须严格使用接收到的数据。必须权衡 <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel 定律</a>与许可分析的许多危险。</p>
<h3 id="2-HTTP头"><a href="#2-HTTP头" class="headerlink" title="2. HTTP头"></a>2. HTTP头</h3><p>HTTP 头的是为了以统一，标准化和隔离的方式提供有关消息的正文或发送者的元数据信息。HTTP标头名称不区分大小写。</p>
<ul>
<li>HTTP标头应仅用于处理跨领域关注点。</li>
<li>API实现不应引入或依赖标头。</li>
<li>标头不得包含API或特定于域的值。</li>
<li>如果可用，则必须使用HTTP标准标头，而不是创建自定义标头。</li>
</ul>
<h4 id="2-1-假设条件"><a href="#2-1-假设条件" class="headerlink" title="2.1 假设条件"></a>2.1 假设条件</h4><p><strong>服务使用者和服务提供者：</strong></p>
<ul>
<li>不应该期望特定的HTTP标头可用。调用链中的中间组件可能会丢弃HTTP标头。这就是业务逻辑不应基于HTTP标头的原因。</li>
<li>不应该假设标头的值尚未更改为HTTP消息传输的一部分。</li>
</ul>
<p><strong>基础结构组件</strong>（HTTP消息传递中涉及的Web服务框架，客户端调用库，企业服务总线（ESB），负载平衡器（LB）等）：</p>
<ul>
<li>可以基于特定报头的可用性和有效性返回错误，而不转发消息。例如，基于客户端身份和凭据的请求的身份验证或授权错误。</li>
<li>可以添加，删除或更改HTTP标头的值。</li>
</ul>
<h4 id="2-2-HTTP标准标头"><a href="#2-2-HTTP标准标头" class="headerlink" title="2.2 HTTP标准标头"></a>2.2 HTTP标准标头</h4><p>这些是从 <a href="http://tools.ietf.org/html/rfc7231#page-33">HTTP / 1.1 规范（RFC 7231）</a>定义或引用的标头。许多基础架构组件都很好地定义和理解了它们的目的，语法，值和语义。</p>
<table>
<thead>
<tr>
<th>HTTP标头名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Accept</code></td>
<td>该请求标头指定 API 客户端能够在响应中处理的媒体类型。发出 HTTP 请求的系统应发送此标头。处理该请求的系统不应假定该请求可用。在所有这些 API 指南中都假定 API 支持 <code>application/json</code> 。</td>
</tr>
<tr>
<td><code>Accept-Charset</code></td>
<td>该请求标头指定 API 客户端在响应中可以处理的字符集。该值 <code>Accept-Charset</code>应包括<code>utf-8</code>。</td>
</tr>
<tr>
<td><code>Content-Language</code></td>
<td>该请求/响应头用于指定内容的语言。默认语言环境为 <code>en-US</code> 。 API 客户端应使用 Content-Language 标头识别数据的语言。API 必须在响应中提供此标头。  例： <code>Content-Language：zh-CN</code></td>
</tr>
<tr>
<td><code>Content-Type</code></td>
<td>该请求/响应头指示请求或响应主体的媒体类型。 <br/><ul><li>API 客户端必须与请求包括：如果请求包含一个主体，例如它是一个 <code>POST</code> ， <code>PUT</code> 或 <code>PATCH</code> 请求。</li><li>如果包含响应主体（不与 <code>204</code> 响应一起使用），API开发人员必须在响应中包含它。</li><li>如果内容是基于文本的类型，例如<a href="http://json.org/">JSON</a>，则 <code>Content-Type</code> 必须包含一个字符集参数。字符集必须为 UTF-8 。</li><li>目前唯一支持的媒体类型是<code>application/json</code>。</li></ul><br /> 例：<br /><pre>（在HTTP请求中）Accept: application/json<br />                                         Accept-Charset: utf-8  <br />（在HTTP响应中）Content-Type: application/json; charset=utf-8</pre></td>
</tr>
<tr>
<td><code>Link</code></td>
<td>根据 <a href="https://tools.ietf.org/html/rfc5988">Web连接RFC 5988</a>，连接是由国际化资源标识符（IRI）标识的两个资源之间的类型化连接。 <code>Link</code> 实体头字段提供了在HTTP头中的序列化的一个或多个链接的装置。  应该在设计假设下构建 API ，即 API 或 API 客户端的业务逻辑都不应该依赖标头中提供的信息。标头只能用于携带跨领域的关注信息，例如安全性，可追溯性，监视等。  因此，<code>Link</code>响应代码<code>201</code>或禁止使用标头<code>3xx</code>。考虑在响应正文中使用<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#hypermedia">HATEOAS链接</a>。</td>
</tr>
<tr>
<td><code>Location</code></td>
<td>此响应标头字段用于将收件人重定向到Request-URI以外的其他位置，以完成请求或标识新资源。  应该在设计假设下构建API，即API或API客户端的业务逻辑都不应该依赖标头中提供的信息。标头只能用于携带跨领域的关注信息，例如安全性，可追溯性，监视等。  因此，<code>Location</code>响应代码<code>201</code>或禁止使用标头<code>3xx</code>。考虑在响应正文中使用<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#hypermedia">HATEOAS链接</a>。</td>
</tr>
<tr>
<td><code>Prefer</code></td>
<td><a href="https://tools.ietf.org/html/rfc7240"><code>Prefer</code></a>请求头字段表示客户端要求服务器的首选行为，但并比一定会生效。它是一个<code>end to end</code>字段，如果转发请求，则必须由代理转发，除非使用 <code>Connection</code> 头字段将 <code>Prefer</code> 明确标识为 <code>hop by hop</code> 。如果API文档中明确指出了对的支持，则以下标记值可以用于API <code>Prefer</code>。  <br /><code>respond-async</code>：API客户端希望API服务器异步处理其请求。<br /><pre>Prefer: respond-async</pre><br />服务器返回 <code>202 (Accepted)</code> 响应并异步处理请求。API 服务器可以随后使用 Webhook 通知客户端，或者客户端可以<code>GET</code>稍后调用以获取响应。有关更多详细信息，请参考<a href="https://github.com/paypal/api-standards/blob/master/patterns.md#asynchronous-operations">异步操作</a>。  <br /><code>read-consistent</code>：API 客户端希望API 服务器从持久性存储返回具有一致数据的响应。对于不为其客户端提供任何优化首选项的API，此行为将是默认行为，并且不需要客户端设置此令牌。<br /><pre>Prefer: read-consistent</pre><br /><code>read-eventual-consistent</code>：API客户端希望API服务器从缓存或可能最终最终一致的数据存储返回响应（如果适用）。如果错过了从这两种类型的任何一种源中查找数据的机会，则API服务器可能会从一致的持久性数据存储中返回响应。<br /><pre>Prefer: read-eventual-consistent</pre><br /><code>read-cache</code>：API客户端希望API服务器从缓存中返回响应（如果有）。如果缓存命中未命中，则服务器可以返回其他来源的响应，例如最终的一致数据存储或一致，持久的数据存储。<br /><pre>Prefer: read-cache</pre><br /><code>return=representation</code>：API客户端更喜欢API服务器在对成功请求的响应中包含代表资源当前状态的实体。此首选项旨在通过消除在<code>GET</code>创建（<code>POST</code>）修改操作（<code>PUT</code>或<code>PATCH</code>）之后需要后续请求来检索资源的当前表示的方式，来提供一种优化客户端与服务器之间通信的方法。<br /><pre>Prefer: return=representation</pre><br /><code>return=minimal</code>：API客户端指示服务器仅返回对成功请求的最小响应。确定什么构成适当的“最小”响应完全由服务器决定。<br /><pre>Prefer: return=minimal</pre></td>
</tr>
</tbody></table>
<h4 id="2-3-HTTP自定义标题"><a href="#2-3-HTTP自定义标题" class="headerlink" title="2.3 HTTP自定义标题"></a>2.3 HTTP自定义标题</h4><p>以下是这些准则中使用的一些自定义标头。这些不是HTTP规范的一部分。</p>
<table>
<thead>
<tr>
<th>HTTP标头名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Foo-Request-Id</code></td>
<td>API使用者可以选择发送带有唯一ID的此标头，以标识用于跟踪目的的请求标头。  这样的标头也可以在内部用于日志记录和跟踪目的。如果响应是同步的，则建议将此标头作为响应标头发送回去，或者作为适用的Webhook的请求标头发送回去。</td>
</tr>
</tbody></table>
<h4 id="2-4-HTTP标头传递"><a href="#2-4-HTTP标头传递" class="headerlink" title="2.4 HTTP标头传递"></a>2.4 HTTP标头传递</h4><p>当服务收到请求标头时，除了在分发给下游应用程序的请求/消息中的HTTP标准标头之外，它们还必须传递相关的自定义标头。</p>
<h3 id="3-HTTP状态码"><a href="#3-HTTP状态码" class="headerlink" title="3. HTTP状态码"></a>3. HTTP状态码</h3><p>RESTful 服务使用 HTTP 状态代码来指定 HTTP 方法执行的结果。 HTTP 协议使用整数和消息指定请求执行的结果。该数字称为<em>状态码</em>，该消息称为<em>原因短语</em>。原因短语是人类可读的消息，用于阐明响应的结果。 HTTP 协议将范围内的状态代码分类。</p>
<h4 id="3-1-状态码范围"><a href="#3-1-状态码范围" class="headerlink" title="3.1 状态码范围"></a>3.1 状态码范围</h4><p>响应API请求时，必须使用以下状态代码范围。</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>2xx</code></td>
<td>成功执行。方法执行有可能以多种方式成功执行。此状态代码指定成功的方式。</td>
</tr>
<tr>
<td><code>4xx</code></td>
<td>通常，这些问题包括请求，请求中的数据，无效的身份验证或授权等。在大多数情况下，客户端可以修改其请求并重新提交。</td>
</tr>
<tr>
<td><code>5xx</code></td>
<td>服务器错误：由于站点中断或软件缺陷，服务器无法执行该方法。5xx 范围状态代码不应用于验证或逻辑错误处理。</td>
</tr>
</tbody></table>
<h4 id="3-2-状态报告"><a href="#3-2-状态报告" class="headerlink" title="3.2 状态报告"></a>3.2 状态报告</h4><p>成功和失败不仅适用于整个操作，还适用于SOA框架部分或代码执行的业务逻辑部分。</p>
<p>以下是状态代码和原因短语的准则。</p>
<ul>
<li>必须使用<code>2xx</code>范围内的状态代码报告成功。</li>
<li><code>2xx</code>仅当完整的代码执行路径成功时，才必须返回范围内的HTTP状态代码。这包括任何容器/ SOA框架代码以及该方法的业务逻辑代码执行。</li>
<li>必须在<code>4xx</code>或<code>5xx</code>范围内报告失败。对于系统错误和应用程序错误都是如此。</li>
<li>如<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error.json"><code>error.json</code></a>架构所定义，主体中必须存在一致的JSON格式的错误响应。该模式用于限定错误的种类。请参阅<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#error-handling">错误处理</a>指南以获取更多详细信息。</li>
<li>返回状态代码在<code>4xx</code>或<code>5xx</code>范围内的服务器必须返回<code>error.json</code>响应主体。</li>
<li>返回状态码<code>2xx</code>范围内的服务器<code>error.json</code>不得将响应后的响应或任何类型的错误代码作为响应主体的一部分返回。</li>
<li>对于<code>4xx</code>代码范围内的客户端错误，原因短语应为客户端提供足够的信息，以便能够确定导致错误的原因以及如何解决该错误。</li>
<li>对于<code>5xx</code>代码范围内的服务器错误，原因短语和后面的错误响应<code>error.json</code>应限制信息量，以避免向客户公开内部服务实现的详细信息。对于外部API和内部API都是如此。服务开发人员应使用日志记录和跟踪实用程序来提供其他信息。</li>
</ul>
<h4 id="3-3-允许的状态代码列表"><a href="#3-3-允许的状态代码列表" class="headerlink" title="3.3 允许的状态代码列表"></a>3.3 允许的状态代码列表</h4><p>所有REST API务必仅使用以下状态代码。**<code>BOLD</code>**API开发人员应使用状态代码。其余的主要用于Web服务框架开发人员，报告与安全性，内容协商等有关的框架级错误。</p>
<ul>
<li>API绝不能返回此表中未定义的状态代码。</li>
<li>API只能返回此表中定义的某些状态代码。</li>
</ul>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>200 OK</code></strong></td>
<td>通用成功执行。</td>
</tr>
<tr>
<td><strong><code>201 Created</code></strong></td>
<td>用作对<code>POST</code>方法执行的响应，以指示成功创建资源。如果已经创建了资源（例如，通过先前执行同一方法），则服务器应返回状态代码<code>200 OK</code>。</td>
</tr>
<tr>
<td><strong><code>202 Accepted</code></strong></td>
<td>用于异步方法执行，以指定服务器已接受该请求并将在以后执行。有关更多详细信息，请参阅“ <a href="https://github.com/paypal/api-standards/blob/master/patterns.md#asynchronous-operations">异步操作”</a>。</td>
</tr>
<tr>
<td><strong><code>204 No Content</code></strong></td>
<td>服务器已成功执行该方法，但是没有要返回的实体主体。</td>
</tr>
<tr>
<td><strong><code>400 Bad Request</code></strong></td>
<td>服务器无法理解该请求。使用此状态代码来指定： 作为有效负载一部分的数据不能转换为基础数据类型。数据不是预期的数据格式。必填字段不可用。简单数据验证类型的错误。</td>
</tr>
<tr>
<td><code>401 Unauthorized</code></td>
<td>该请求需要身份验证，但未提供任何身份。请注意此与之间的区别<code>403 Forbidden</code>。</td>
</tr>
<tr>
<td><strong><code>403 Forbidden</code></strong></td>
<td>客户端无权访问资源，尽管它可能具有有效的凭据。如果业务级别授权失败，API可以使用此代码。例如，避孕药持有人没有足够的资金。</td>
</tr>
<tr>
<td><strong><code>404 Not Found</code></strong></td>
<td>服务器未找到与请求URI匹配的任何内容。这意味着URI不正确或资源不可用。例如，可能是该键处的数据库中没有数据。</td>
</tr>
<tr>
<td><code>405 Method Not Allowed</code></td>
<td>服务器尚未实现请求的HTTP方法。这通常是API框架的默认行为。</td>
</tr>
<tr>
<td><code>406 Not Acceptable</code></td>
<td>当服务器无法使用客户端请求的媒体类型返回响应的有效负载时，服务器必须返回此状态代码。例如，如果客户端发送了<code>Accept: application/xml</code>标头，而API只能生成<code>application/json</code>，则服务器必须返回<code>406</code>。</td>
</tr>
<tr>
<td><code>415 Unsupported Media Type</code></td>
<td>当请求的有效负载的媒体类型无法处理时，服务器必须返回此状态代码。例如，如果客户端发送<code>Content-Type: application/xml</code>标头，但API仅接受<code>application/json</code>，则服务器必须返回<code>415</code>。</td>
</tr>
<tr>
<td><strong><code>422 Unprocessable Entity</code></strong></td>
<td>请求的操作无法执行，可能需要与当前请求之外的API或进程进行交互。这与500响应不同，因为没有系统性的问题限制API执行请求。</td>
</tr>
<tr>
<td><code>429 Too Many Requests</code></td>
<td>如果用户，应用程序或令牌的速率限制已超过预定义的值，则服务器必须返回此状态代码。在其他HTTP状态代码<a href="https://tools.ietf.org/html/rfc6585">RFC 6585中</a>定义。</td>
</tr>
<tr>
<td><strong><code>500 Internal Server Error</code></strong></td>
<td>这可能是系统错误，也可能是应用程序错误，通常表明尽管客户端似乎提供了正确的请求，但服务器上出现了意外情况。一个<code>500</code>响应指示服务器端软件缺陷或站点停运。<code>500</code>不应用于客户端验证或逻辑错误处理。</td>
</tr>
<tr>
<td><code>503 Service Unavailable</code></td>
<td>由于临时维护，服务器无法处理服务请求。</td>
</tr>
</tbody></table>
<h4 id="3-4-HTTP方法到状态码的映射"><a href="#3-4-HTTP方法到状态码的映射" class="headerlink" title="3.4 HTTP方法到状态码的映射"></a>3.4 HTTP方法到状态码的映射</h4><p>对于每种HTTP方法，API开发人员应仅在此表中使用标记为“ X”的状态代码。如果API需要返回标有的任何状态代码**<code>X</code>**，则应在API设计审核过程和成熟度评估中对用例进行审核。这些状态码大多数用于支持非常罕见的用例。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>200成功</th>
<th>创建了201</th>
<th>202接受</th>
<th>204没有内容</th>
<th>400错误的要求</th>
<th>找不到404</th>
<th>422无法处理的实体</th>
<th>500内部服务器错误</th>
</tr>
</thead>
<tbody><tr>
<td><code>GET</code></td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td><strong><code>X</code></strong></td>
<td>X</td>
</tr>
<tr>
<td><code>POST</code></td>
<td>X</td>
<td>X</td>
<td><strong><code>X</code></strong></td>
<td></td>
<td>X</td>
<td><strong><code>X</code></strong></td>
<td><strong><code>X</code></strong></td>
<td>X</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td>X</td>
<td></td>
<td><strong><code>X</code></strong></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td><strong><code>X</code></strong></td>
<td>X</td>
</tr>
<tr>
<td><code>PATCH</code></td>
<td>X</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td><strong><code>X</code></strong></td>
<td>X</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>X</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td><strong><code>X</code></strong></td>
<td>X</td>
</tr>
</tbody></table>
<ul>
<li><p><code>GET</code>：该<code>GET</code>方法的目的是检索资源。成功后，将<code>200</code>期望状态码和包含资源内容的响应。如果资源集合为空（中的0个项目<code>/v1/namespace/resources</code>），<code>200</code>则状态为适当（资源将包含一个空<code>items</code>数组）。如果资源项目在基础数据中被“软删除”，<code>200</code>则不适合（<code>404</code>正确），除非打算公开“已删除”状态。</p>
</li>
<li><p><code>POST</code>：的主要目的<code>POST</code>是创建资源。如果资源不存在，而是在执行过程中创建的，则<code>201</code>应该返回状态码。</p>
<ul>
<li>期望在成功执行后，在响应主体中返回对创建的资源的引用（以链接或资源标识符的形式）。</li>
<li>幂等语义：如果这是同一调用（包括<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#http-custom-headers"><code>Foo-Request-Id</code></a>标头）的后续执行，并且已经创建了资源，<code>200</code>则应返回状态码SHOULD。有关API中的幂等性的更多详细信息，请参阅<a href="https://github.com/paypal/api-standards/blob/master/patterns.md#idempotency">idempotency</a>。</li>
<li>如果使用了子资源（“控制器”或数据资源），并且主要资源标识符不存在，<code>404</code>则是适当的响应。</li>
</ul>
</li>
<li><p><code>POST</code>也可以在利用<a href="https://github.com/paypal/api-standards/blob/master/patterns.md##controller-resource">控制器模式</a>时使用，<code>200</code>是适当的状态代码。</p>
</li>
<li><p><code>PUT</code>：此方法应该返回状态代码，<code>204</code>因为在大多数情况下，由于请求是要更新资源并且已成功更新，因此无需返回任何内容。来自请求的信息不应回显。</p>
<ul>
<li>在极少数情况下，可能需要在响应中提供服务器生成的值，以优化客户端流（如果客户端必须必须执行<code>GET</code>after <code>PUT</code>）。在这种情况下，应<code>200</code>设立一个响应机构。</li>
</ul>
</li>
<li><p><code>PATCH</code>：此方法应遵循与<code>PUT</code>，<code>204</code>status和没有响应主体相同的状态/响应语义。</p>
<ul>
<li><code>200</code>+应该不惜一切代价避免响应主体，因为<code>PATCH</code>它会执行部分更新，这意味着每个资源多次调用是正常的。这样，对整个资源进行响应会导致大量带宽使用，尤其是对于带宽敏感的移动客户端。</li>
</ul>
</li>
<li><p><code>DELETE</code>：此方法应该返回状态代码，<code>204</code>因为在大多数情况下无需返回任何内容，因为请求是删除资源并且已成功删除该资源。</p>
<ul>
<li>由于该<code>DELETE</code>方法也必须是幂等的，因此<code>204</code>即使资源已被删除，它仍应返回。通常，API使用者不关心资源是否作为此操作的一部分或之前的内容被删除了。这也是为什么<code>204</code>不<code>404</code>应该返回的原因。</li>
</ul>
</li>
</ul>
<h2 id="五、超媒体"><a href="#五、超媒体" class="headerlink" title="五、超媒体"></a>五、超媒体</h2><h3 id="1-HATEOAS"><a href="#1-HATEOAS" class="headerlink" title="1. HATEOAS"></a>1. HATEOAS</h3><p>超媒体是<a href="https://en.wikipedia.org/wiki/Hypertext">超文本</a>一词的扩展，是一种非线性的信息介质，根据<a href="https://en.wikipedia.org/wiki/Hypermedia">Wikipedia的规定</a>，它包括图形，音频，视频，纯文本和超链接。作为应用状态引擎的超媒体<code>HATEOAS</code>是Roy Fielding在<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">论文中</a>描述的REST应用体系结构的约束。</p>
<p>在RESTful API的上下文中，客户端可以完全通过服务动态提供的超媒体与服务交互。超媒体驱动的服务通过在响应中包括超媒体链接，向其客户端提供资源表示，以动态导航API。这不同于SOA的其他形式，在SOA中，服务器和客户端基于Web上某个位置定义的或基于带外交换的，基于WSDL的规范进行交互。</p>
<h3 id="2-符合Hypermedia的API"><a href="#2-符合Hypermedia的API" class="headerlink" title="2. 符合Hypermedia的API"></a>2. 符合Hypermedia的API</h3><p>符合超媒体的API公开了服务的有限状态机。在这里，要求如<code>DELETE</code>，<code>PATCH</code>，<code>POST</code>和<code>PUT</code>通常在启动状态的转变，而响应指示状态的变化。让我们以一个API为例，该API公开一组操作来管理用户帐户生命周期并实现HATEOAS接口约束。</p>
<p>客户端通过固定的URI开始与服务进行交互<code>/users</code>。此固定URI支持<code>GET</code>和<code>POST</code>操作。客户端决定执行一项<code>POST</code>操作以在系统中创建用户。</p>
<p><strong>请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://api.foo.com/v1/customer/users</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;given_name&quot;: &quot;James&quot;,</span><br><span class="line">    &quot;surname&quot; : &quot;Greenwood&quot;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>响应：</strong></p>
<p>API从输入中创建一个新用户，并在响应中将以下链接返回到客户端。</p>
<ul>
<li>检索用户完整表示的<code>self</code>链接（又称链接）（<code>GET</code>）。</li>
<li>更新用户的链接（<code>PUT</code>）。</li>
<li>部分更新用户的链接（<code>PATCH</code>）。</li>
<li>删除用户的链接（<code>DELETE</code>）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">HTTP/1.1 201 CREATED</span><br><span class="line">Content-Type: application/json</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&quot;links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;replace&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以将这些链接存储在其数据库中以供以后使用。</p>
<p>然后，在管理员决定删除其中一个用户之前，客户端可能希望显示一组用户及其详细信息。因此，客户端<code>GET</code>对相同的固定URI 执行a <code>/users</code>。</p>
<p><strong>请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.foo.com/v1/customer/users</span><br></pre></td></tr></table></figure>

<p>该API通过相应的<code>self</code>链接返回系统中的所有用户。</p>
<p><strong>响应：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;total_items&quot;: &quot;166&quot;,</span><br><span class="line">    &quot;total_pages&quot;: &quot;83&quot;,</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;given_name&quot;: &quot;James&quot;,</span><br><span class="line">        &quot;surname&quot;: &quot;Greenwood&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;links&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">                &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;given_name&quot;: &quot;David&quot;,</span><br><span class="line">        &quot;surname&quot;: &quot;Brown&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;links&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-MDFSKFGIFJ86DSF&quot;,</span><br><span class="line">                &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>客户端可以跟随<code>self</code>用户的链接并找出它可以在用户资源上执行的所有可能的操作。</p>
<p><strong>请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI</span><br></pre></td></tr></table></figure>

<p><strong>响应：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;given_name&quot;: &quot;James&quot;,</span><br><span class="line">        &quot;surname&quot;: &quot;Greenwood&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">        </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;replace&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了删除用户，客户端<code>delete</code>从其数据存储中检索链接关系类型的URI并对该URI执行删除操作。</p>
<p><strong>请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI</span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<ul>
<li>客户端可以导航到API的入口点，以便访问所有其他资源。</li>
<li>客户端无需构建组成URI的逻辑来执行不同的请求或通过查看可能与URI和状态更改相关的响应详细信息（在后面的部分中进行更详细的描述）来编码任何种类的业务规则。 。</li>
<li>客户端承认创建URI的过程属于服务器这一事实。</li>
<li>客户端将URI视为不透明标识符。</li>
<li>在表示中使用超媒体的API可以无缝扩展。随着新方法的引入，可以通过相关的HATEOAS链接扩展响应。这样，客户可以增量方式利用该功能。例如，如果API开始支持新<code>PATCH</code>操作，则客户端可以使用它进行部分更新。</li>
</ul>
<p>链接的存在本身不脱钩客户不必学会做一个过渡和所有相关链接语义请求所需的数据，特别是对<code>POST</code>/ <code>PUT</code>/ <code>PATCH</code>操作。API必须提供文档，以清楚地描述每个URI的所有链接，链接关系类型和请求响应格式。</p>
<p>后续部分提供有关链接结构以及不同关系类型的含义的更多详细信息。</p>
<h3 id="3-链接描述对象"><a href="#3-链接描述对象" class="headerlink" title="3. 链接描述对象"></a>3. 链接描述对象</h3><p>必须使用*[链接描述对象（LDO）] <a href="http://json-schema.org/latest/json-schema-hypermedia.html#anchor17">4</a><em>模式</em>描述链接*。LDO在links数组中描述了单个链接关系。以下是链接描述对象的属性的简要描述。</p>
<p><code>href</code>：</p>
<ul>
<li><code>href</code>必须提供属性的值。</li>
<li><code>href</code>属性的值必须是*[URI模板] <a href="https://tools.ietf.org/html/rfc6570">6，</a>*用于确定相关资源的目标URI。应根据<a href="https://tools.ietf.org/html/rfc6570">RFC 6570</a>将其解析为URI模板。</li>
<li>仅将绝对URI用作<code>href</code>属性值。客户端通常将表示形式的链接关系类型的绝对URI标记为书签，以便以后发出API请求。开发人员必须使用*<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#uri-component-names">URI组件命名约定</a>*来构造绝对URI。传入<code>Host</code>报头（例如api.foo.com）中的值必须用作<code>host</code>绝对URI 的字段。</li>
</ul>
<p><code>rel</code>：</p>
<ul>
<li><p><code>rel</code> 代表“链接关系类型”中定义的关系</p>
</li>
<li><p>该<code>rel</code>属性的值指示与目标资源的关系的名称。</p>
</li>
<li><p><code>rel</code>必须提供属性的值。</p>
</li>
<li><p><code>method</code>：</p>
<ul>
<li>该<code>method</code>属性标识必须用于向链接目标发出请求的HTTP动词。如果忽略该<code>method</code>属性，<code>GET</code>则默认值为。</li>
</ul>
</li>
<li><p><code>title</code>：</p>
<ul>
<li>该<code>title</code>属性提供了链接的标题，并且是一个有用的文档工具，可帮助最终客户理解。不需要此属性。</li>
</ul>
</li>
</ul>
<h5 id="不为LDO使用HTTP标头"><a href="#不为LDO使用HTTP标头" class="headerlink" title="不为LDO使用HTTP标头"></a>不为LDO使用HTTP标头</h5><p>请注意，这些API准则不建议使用HTTP <code>Location</code>标头来提供链接。另外，他们也不建议使用<a href="https://java.net/projects/jax-rs-spec/pages/Hypermedia">JAX-RS中</a><code>Link</code>描述的标头。HTTP标头的范围仅限于客户端和服务之间的点对点交互。由于响应可能会传递到客户端上可能不直接与服务交互的其他层和组件，因此存储在标头中的任何信息可能都不可用。因此，我们建议在HTTP响应主体中返回链接描述对象。</p>
<h3 id="4-链接数组"><a href="#4-链接数组" class="headerlink" title="4. 链接数组"></a>4. 链接数组</h3><p><code>links</code>模式的array属性用于将链接描述对象与*[JSON hyper-schema draft-04] <a href="http://json-schema.org/draft-04/hyper-schema#">3</a>*实例相关联。</p>
<ul>
<li>此属性必须是一个数组。</li>
<li>数组中的项目必须为链接描述对象类型。</li>
</ul>
<h5 id="指定链接数组"><a href="#指定链接数组" class="headerlink" title="指定链接数组"></a>指定链接数组</h5><p>这是一个如何描述架构中的链接的示例。</p>
<ul>
<li>必须在API资源模式定义的一部分中提供与下面的示例JSON模式中定义的链接数组相似的链接数组。请注意，links数组需要在<code>properties</code>对象的关键字内声明。这是代码生成器为所生成的对象中的links数组添加setter / getter方法所必需的。</li>
<li>必须使用URI模板在响应模式中声明API作为响应的一部分返回的所有可能的链接。URI模板的links数组必须在<code>properties</code>关键字之外声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">    &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/hyper-schema#&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;A sample resource representing a customer name.&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &#123;</span><br><span class="line">	    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Unique ID to identify a customer.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;first_name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Customer&#x27;s first name.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;last_name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Customer&#x27;s last name.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;links&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;array&quot;,</span><br><span class="line">            &quot;items&quot;: &#123;</span><br><span class="line">                &quot;$ref&quot;: &quot;http://json-schema.org/draft-04/hyper-schema#definitions/linkDescription&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;replace&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是符合上述架构的示例响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;last_name&quot;: &quot;Doe&quot;,</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/cusommer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-链接关系类型"><a href="#5-链接关系类型" class="headerlink" title="5. 链接关系类型"></a>5. 链接关系类型</h3><p> <code>Link Relation Type</code> 用作链接的标识符。API必须分配有意义的链接关系类型，该类型必须明确描述链接的语义。客户端使用相关的链接关系类型，以便从表示形式中识别要使用的链接。</p>
<p>当*[IANA的标准链接关系列表] <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">5</a>*中定义的链接关系类型的语义与您要定义的语义匹配时，则必须使用它。下表描述了一些常用的链接关系类型。它还列出了这些准则定义的一些其他链接关系类型。</p>
<table>
<thead>
<tr>
<th>链接关系类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>self</code></td>
<td>传达链接上下文的标识符。通常是指向资源本身的链接。</td>
</tr>
<tr>
<td><code>create</code></td>
<td>指可用于创建新资源的链接。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td>指编辑（或部分更新）链接标识的表示形式。使用它来表示<code>PATCH</code>操作链接。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>指删除链接标识的资源。使用它<code>Extended link relation type</code>来表示<code>DELETE</code>操作链接。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td>指完全更新（或替换）链接标识的表示形式。使用它<code>Extended link relation type</code>来表示<code>PUT</code>操作链接。</td>
</tr>
<tr>
<td><code>first</code></td>
<td>指结果列表的第一页。</td>
</tr>
<tr>
<td><code>last</code></td>
<td>指提供的结果列表的最后一页<code>total_required</code>指定为查询参数。</td>
</tr>
<tr>
<td><code>next</code></td>
<td>指结果列表的下一页。</td>
</tr>
<tr>
<td><code>prev</code></td>
<td>指结果列表的前一页。</td>
</tr>
<tr>
<td><code>collection</code></td>
<td>引用集合资源（例如/ v1 / users）。</td>
</tr>
<tr>
<td><code>latest-version</code></td>
<td>指向包含最新（例如当前）版本的资源。</td>
</tr>
<tr>
<td><code>search</code></td>
<td>指可用于搜索链接上下文和相关资源的资源。</td>
</tr>
<tr>
<td><code>up</code></td>
<td>指资源层次结构中的父资源。</td>
</tr>
</tbody></table>
<p>对于所有<a href="https://github.com/paypal/api-standards/blob/master/patterns.md#controller-resource"><code>controller</code></a>款式复杂的操作，控制器<code>action</code>名称必须使用中的链接关系类型（例如<code>activate</code>，<code>cancel</code>，<code>refund</code>）。</p>
<h3 id="6-用例"><a href="#6-用例" class="headerlink" title="6. 用例"></a>6. 用例</h3><p>请参阅<a href="https://github.com/paypal/api-standards/blob/master/patterns.md#hateoas-use-cases">HATEOAS用例</a>以查找可以在哪里使用HATEOAS。</p>
<h2 id="六、命名约定"><a href="#六、命名约定" class="headerlink" title="六、命名约定"></a>六、命名约定</h2><p>本节介绍了URI，查询参数，资源，字段和枚举的命名约定。在这里让我们强调一下，这些指南不是完全按照此处描述的那样遵循约定，而是更多地是在设计API时定义一些命名约定并以一致的方式遵守这些约定。例如，对于字段和文件名，我们跟随了<a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a>，但是，您可以使用其他形式，例如<a href="https://en.wikipedia.org/wiki/Camel_case">CamelCase</a>或您自己设计的其他形式。遵守已定义的约定很重要。</p>
<h3 id="1-URI组件名称"><a href="#1-URI组件名称" class="headerlink" title="1. URI组件名称"></a>1. URI组件名称</h3><p>URI遵循<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>规范。该规范简化了REST API服务的开发和使用。本节中的准则遵循RFC 3986约束来管理URI结构和语义。</p>
<h4 id="1-1-URI组件"><a href="#1-1-URI组件" class="headerlink" title="1.1 URI组件"></a>1.1 URI组件</h4><p>根据RFC 3986，通用URI语法由组件的层次结构序列组成，称为方案，权限，路径，查询和片段，如下面的示例所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  https://example.com:8042/over/there?name=ferret#nose</span><br><span class="line">  \___/   \_______________/\_________/\_________/\__/</span><br><span class="line">   |           |            |            |        |</span><br><span class="line">scheme     authority       path        query   fragment</span><br></pre></td></tr></table></figure>

<h4 id="1-2-URI命名约定"><a href="#1-2-URI命名约定" class="headerlink" title="1.2 URI命名约定"></a>1.2 URI命名约定</h4><p>以下是对API的URI特定命名约定准则的简要说明。本规范使用括号“()”进行分组，星号 “ * ” 指定零个或多个出现，括号“[]”表示可选字段。</p>
<ul>
<li>URI必须以字母开头，并且只能使用小写字母。</li>
<li>URI路径中的文字/表达式应使用连字符（-）分隔。</li>
<li>查询字符串中的文字/表达式应使用下划线（_）分隔。</li>
<li>URI路径和查询字符串必须将数据编码成<a href="https://en.wikipedia.org/wiki/Percent-encoding">UTF-8八位字节</a>。</li>
<li>URI中应该使用多个名词来标识数据资源的集合。<ul>
<li><code>/invoices</code></li>
<li><code>/statements</code></li>
</ul>
</li>
<li>资源集合中的单个资源可以直接存在于集合URI的下面。<ul>
<li><code>/invoices/&#123;invoice_id&#125;</code></li>
</ul>
</li>
<li>子资源集合可以直接存在于单个资源之下。这应该传达与另一个资源集合的关系（在此示例中为发票项目）。<ul>
<li><code>/invoices/&#123;invoice_id&#125;/items</code></li>
</ul>
</li>
<li>子资源的单个资源可以存在，但应避免使用顶级资源。<ul>
<li><code>/invoices/&#123;invoice_id&#125;/items/&#123;item_id&#125;</code></li>
<li>更好： <code>/invoice-items/&#123;invoice_item_id&#125;</code></li>
</ul>
</li>
<li>资源标识符应遵循后续部分中描述的<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#resource-identifiers">建议</a>。</li>
</ul>
<p><strong>例子</strong></p>
<ul>
<li><code>https://api.foo.com/v1/vault/credit-cards</code></li>
<li><code>https://api.foo.com/v1/vault/credit-cards/CARD-7LT50814996943336KESEVWA</code></li>
<li><code>https://api.foo.com/v1/payments/billing-agreements/I-V8SSE9WLJGY6/re-activate</code></li>
</ul>
<p><strong>正式定义：</strong></p>
<table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>URI</td>
<td>[端点]’ <strong>/</strong> ‘资源路径[‘ <strong>？</strong>‘查询’</td>
</tr>
<tr>
<td>end-point</td>
<td>[scheme“ <strong>：//</strong> ”] [host [‘ <strong>：</strong> ‘port]]</td>
</tr>
<tr>
<td>schema</td>
<td>“ <strong>http</strong> ”或“ <strong>https</strong> ”</td>
</tr>
<tr>
<td>资源路径(resource-path)</td>
<td>“ <strong>/ v</strong> ”版本’ <strong>/</strong> ‘名称空间名称’ <strong>/</strong> ‘资源（’ <strong>/</strong> ‘资源）</td>
</tr>
<tr>
<td>资源(resource)</td>
<td>资源名称[‘ <strong>/</strong> ‘资源ID]</td>
</tr>
<tr>
<td>资源名称(resource-name)</td>
<td>Alpha（Alpha |数字|’-‘）*</td>
</tr>
<tr>
<td>资源编号(resource-id)</td>
<td>值</td>
</tr>
<tr>
<td>query</td>
<td>名称’ <strong>=</strong> ‘值（’ <strong>＆</strong> ‘名称=值）*</td>
</tr>
<tr>
<td>name</td>
<td>Alpha（Alpha |数字|’_’）*</td>
</tr>
<tr>
<td>value</td>
<td>URI百分比编码值</td>
</tr>
</tbody></table>
<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;   用单引号括住特殊字符</span><br><span class="line">&quot;	用双引号引起来的字符串</span><br><span class="line">()	使用括号进行分组</span><br><span class="line">[]	使用方括号指定可选表达式</span><br><span class="line">*	一个表达式可以重复零次或多次</span><br></pre></td></tr></table></figure>

<h4 id="1-3-资源名称"><a href="#1-3-资源名称" class="headerlink" title="1.3 资源名称"></a>1.3 资源名称</h4><p>将服务建模为一组资源时，开发人员必须遵循以下原则：</p>
<ul>
<li><p>必须使用名词，而不是动词。</p>
</li>
<li><p>资源名称对于单例必须为单数；集合的名称必须为复数。</p>
<ul>
<li>用户帐户上自动付款配置的说明<ul>
<li><code>GET /autopay</code> 返回完整的表示形式</li>
</ul>
</li>
<li>假设费用的集合：<ul>
<li><code>GET /charges</code> 返回已收取的费用清单</li>
<li><code>POST /charges</code> 创建一个新的收费资源， <code>/charges/1234</code></li>
<li><code>GET /charges/1234</code> 返回一次充电的完整表示</li>
</ul>
</li>
</ul>
</li>
<li><p>资源名称必须为小写字母，并且只能使用字母数字字符和连字符。</p>
</li>
<li><p>连字符（-）必须用作URI路径文字中的单词分隔符。<strong>请注意</strong>，这是连字符用作单词分隔符的唯一位置。在几乎所有其他情况下，必须使用下划线字符（_）。</p>
</li>
</ul>
<h4 id="1-4-查询参数名称"><a href="#1-4-查询参数名称" class="headerlink" title="1.4 查询参数名称"></a>1.4 查询参数名称</h4><ul>
<li>查询字符串中的文字/表达式应使用下划线（_）分隔。</li>
<li>查询参数值必须为百分比编码。</li>
<li>查询参数必须以字母开头，并且应全部小写。只能使用字母字符，数字和下划线（_）字符。</li>
<li>查询参数应该是可选的。</li>
<li>如<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#resource-collections">资源集合中</a>所示，某些查询参数名称是保留的。</li>
</ul>
<p>有关查询参数用法的更多特定信息，请参阅<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#uri-standards-query">URI标准</a>。</p>
<h3 id="2-字段名称"><a href="#2-字段名称" class="headerlink" title="2. 字段名称"></a>2. 字段名称</h3><p>表示形式的数据模型必须符合<a href="http://json.org/">JSON</a>。这些值本身可以是对象，字符串，数字，布尔值或对象数组。</p>
<ul>
<li>关键字名称必须为小写单词，并用下划线字符（_）分隔。<ul>
<li><code>foo</code></li>
<li><code>bar_baz</code></li>
</ul>
</li>
<li>前缀<code>is_</code>或<code>has_</code>不应用于布尔类型的键。</li>
<li>代表数组的字段应使用复数名词来命名（例如，authenticators-包含一个或多个Authenticator，products-包含一个或多个产品）。</li>
</ul>
<h3 id="3-枚举名称"><a href="#3-枚举名称" class="headerlink" title="3. 枚举名称"></a>3. 枚举名称</h3><p>枚举的条目（值）应仅由大写字母数字字符和下划线字符（_）组成。</p>
<ul>
<li><code>FIELD_10</code></li>
<li><code>NOT_EQUAL</code></li>
</ul>
<p>如果有一个行业标准要求我们执行其他操作，则枚举可能包含其他字符。</p>
<h3 id="4-链接关系名称"><a href="#4-链接关系名称" class="headerlink" title="4. 链接关系名称"></a>4. 链接关系名称</h3><p>表示的链接关系类型<code>rel</code>必须为小写。</p>
<ul>
<li>例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://uri.foo.com/v1/customer/partner-referrals/ALT-JFWXHGUV7VI/activate&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;activate&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;POST&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>

<h3 id="5-文件名称"><a href="#5-文件名称" class="headerlink" title="5. 文件名称"></a>5. 文件名称</h3><p>API使用的各种类型的JSON模式都应包含在单独的文件中，并使用<code>$ref</code>语法（例如<code>&quot;$ref&quot;:&quot;object.json&quot;</code>）进行引用。JSON模式文件应使用下划线命名语法，例如<code>transaction_history.json</code>。</p>
<h2 id="七、URI"><a href="#七、URI" class="headerlink" title="七、URI"></a>七、URI</h2><h3 id="1-资源路径"><a href="#1-资源路径" class="headerlink" title="1. 资源路径"></a>1. 资源路径</h3><p>API的<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#uri-components">资源路径</a>由URI的路径，查询和片段组成。它将包括API的主要版本，后跟名称空间，资源名称以及一个或多个子资源（可选）。例如，考虑以下URI。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.foo.com/v1/vault/credit-cards/CARD-7LT50814996943336KESEVWA</span><br></pre></td></tr></table></figure>

<p>下表列出了上述URI资源路径的各个部分。</p>
<table>
<thead>
<tr>
<th>路径片</th>
<th>描述</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><code>v1</code></td>
<td>指定API的主要版本1</td>
<td>API主版本用于区分同一API的两个向后不兼容的版本。API主版本是一个整数值，必须将其包含在URI中。</td>
</tr>
<tr>
<td><code>vault</code></td>
<td>命名空间</td>
<td>命名空间标识符用于提供资源的上下文和范围。它们由API平台实现的业务能力模型中的逻辑边界确定。</td>
</tr>
<tr>
<td><code>credit-cards</code></td>
<td>资源名称</td>
<td>如果资源名称表示资源的集合，则资源上的<code>GET</code>方法应检索资源列表。查询参数应用于指定搜索条件。</td>
</tr>
<tr>
<td><code>CARD-7LT50814996943336KESEVWA</code></td>
<td>资源ID</td>
<td>要从集合中检索特定资源，必须将资源ID指定为URI的一部分。子资源在下面讨论。</td>
</tr>
</tbody></table>
<h4 id="1-1-子资源"><a href="#1-1-子资源" class="headerlink" title="1.1 子资源"></a>1.1 子资源</h4><p>子资源表示从一种资源到另一种资源的关系。子资源名称提供了关系的含义。如果基数为1：1，则不需要其他信息。否则，子资源应提供用于唯一标识的子资源ID。如果基数为1：许多，则将返回所有子资源。不应支持不超过两个级别的子资源。</p>
<table>
<thead>
<tr>
<th>例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>GET https://api.foo.com/v1/customer-support/disputes/ABCD1234/documents</code></td>
<td>该调用应返回与争议ABCD1234相关的所有文档。</td>
</tr>
<tr>
<td><code>GET https://api.foo.com/v1/customer-support/disputes/ABCD1234/documents/102030</code></td>
<td>该调用应仅返回与此争议相关的特定文档的详细信息。请记住，这只是说明如何使用子资源ID的说明性示例。在实践中，应该避免两步调用。如果第二标识符是唯一的，<code>/v1/customer-support/documents/102030</code>则首选顶级资源（例如）。</td>
</tr>
<tr>
<td><code>GET https://api.foo.com/v1/customer-support/disputes/ABCD1234/transactions</code></td>
<td>以下示例应返回与此争议相关的所有交易及其详细信息，因此无需指定特定的交易ID。如果需要特定的事务ID，<code>/v1/customer-support/transactions/ABCD1234</code>则最好进行检索（假设ID是唯一的）。</td>
</tr>
</tbody></table>
<h4 id="1-2-资源标识符-1"><a href="#1-2-资源标识符-1" class="headerlink" title="1.2 资源标识符"></a>1.2 资源标识符</h4><p><a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#resource-identifier">资源标识符</a>标识资源或子资源。这些<strong>必须</strong>符合以下准则。</p>
<ul>
<li>资源标识符的生命周期必须由资源的域模型拥有，在其中可以保证它们唯一地标识单个资源。</li>
<li>API不得使用数据库序列号作为资源标识符。</li>
<li>优选使用<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>哈希ID（基于<a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a>）作为资源标识符。</li>
<li>出于安全性和数据完整性的原因，所有子资源ID必须仅在父资源内范围内。<br><strong>示例：</strong> <code>/users/1234/linked-accounts/ABCD</code><br>即使帐户“ ABCD”存在，也必须将其链接到用户1234，否则绝不能返回。</li>
<li>枚举值可用作子资源ID。应该使用枚举值的字符串表示形式。</li>
<li>不得有两个资源标识符，一个接一个。<br><strong>例：</strong> <code>https://api.foo.com/v1/payments/payments/12345/102030</code></li>
<li>资源ID应该尝试使用资源标识符字符或ASCII字符。有<strong>不应该</strong>是使用UTF-8字符的任何ID。</li>
<li>资源ID和查询参数值必须对URI未保留字符以外的任何字符执行URI百分比编码。使用UTF-8字符的查询参数值必须进行编码。</li>
</ul>
<h3 id="2-查询参数"><a href="#2-查询参数" class="headerlink" title="2. 查询参数"></a>2. 查询参数</h3><p>查询参数是在资源路径后指定的名称/值对，如RFC 3986 所述。在应用以下部分时，还应遵循<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#naming-conventions">命名约定</a>。</p>
<h5 id="筛选资源集合"><a href="#筛选资源集合" class="headerlink" title="筛选资源集合"></a>筛选资源集合</h5><ul>
<li>查询参数仅应用于限制资源收集或用作搜索或过滤条件。</li>
<li>集合中的资源标识符不应用于过滤集合结果，资源标识符应位于URI中。</li>
<li>分页参数应遵循<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#pagination">分页</a>准则。</li>
<li>默认的排序顺序应该被认为是不确定的和不确定的。如果需要明确的排序顺序，则查询参数<code>sort</code>应与以下常规语法一起使用：<code>&#123;field_name&#125;|&#123;asc|desc&#125;,&#123;field_name&#125;|&#123;asc|desc&#125;</code>。例如：<code>/accounts?sort=date_of_birth|asc,zip_code|desc</code></li>
</ul>
<h5 id="在单个资源上查询参数"><a href="#在单个资源上查询参数" class="headerlink" title="在单个资源上查询参数"></a>在单个资源上查询参数</h5><p>在使用一种资源的典型情况下（例如<code>/v1/payments/billing-plans/P-94458432VR012762KRWBZEUA</code>），不应使用查询参数。</p>
<h5 id="缓存友好的API"><a href="#缓存友好的API" class="headerlink" title="缓存友好的API"></a>缓存友好的API</h5><p>在极少数情况下，资源需要高度可缓存（通常是数据变化很小），可以使用查询参数，而不是<code>POST</code>+请求主体。至于<code>POST</code>会做出反应不可缓存，<code>GET</code>最好在这些情况下。这是唯一可能需要查询参数的情况。</p>
<h5 id="用POST查询参数"><a href="#用POST查询参数" class="headerlink" title="用POST查询参数"></a>用POST查询参数</h5><p>当<code>POST</code>用于操作时，通常不建议使用查询参数来支持请求正文字段。在<code>POST</code>提供分页结果的情况下（通常在<code>GET</code>不合适的复杂搜索API中），可以使用查询参数来提供指向下一页结果的超媒体链接。</p>
<h5 id="为同一查询参数传递多个值"><a href="#为同一查询参数传递多个值" class="headerlink" title="为同一查询参数传递多个值"></a>为同一查询参数传递多个值</h5><p>在将查询参数用于搜索功能时，通常需要传递多个值。例如，它可能出现的情况是一个资源可以有许多国家，如<code>OPEN</code>，<code>CLOSED</code>和<code>INVALID</code>。如果API客户端想要查找所有<code>CLOSED</code>或的项目<code>INVALID</code>怎么办？</p>
<ul>
<li>建议API通过重复查询参数来实现此功能。这是HTTP标准固有支持的，并且已经内置在大多数客户端库中。<ul>
<li>上面的查询将实现为<code>?status=CLOSED&amp;status=INVALID</code>。</li>
<li>在API规范中<code>&quot;repeated&quot;: true</code>，必须使用参数的定义部分中的参数将其标记为可重复。</li>
<li>参数名称应为单数。</li>
</ul>
</li>
<li>URI的实际长度限制非常低-最保守的是大约<a href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers#417184">2,000个字符</a>。因此，在某些情况下，API设计者可以选择使用单个查询参数来接受逗号分隔的值，以便在查询字符串中容纳更多的值。请记住，服务器和客户端库未始终提供此功能，这意味着实现者将需要编写其他字符串解析代码。由于额外的复杂性和与HTTP标准的差异，因此除非合理，否则不建议使用此解决方案。<ul>
<li>上面的查询将实现为<code>?statuses=CLOSED,INVALID</code>。</li>
<li>API规范中不得将参数标记为可重复。</li>
<li>该参数必须<code>&quot;type&quot;: &quot;string&quot;</code>在API规范中标记为，以容纳逗号分隔的值。<code>type</code>不得使用任何其他值。参数说明应指示接受逗号分隔的值。</li>
<li>查询参数名称应为复数形式，以提示使用该模式。</li>
<li>逗号（Unicode <code>U+002C</code>）应该用作值之间的分隔符。</li>
<li>API文档必须定义必要时如何转义分隔符。</li>
</ul>
</li>
</ul>
<h2 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h2><p>根据HTTP规范，可以使用整数和消息指定请求执行的结果。该数字称为<em>状态码</em>，该消息称为<em>原因短语</em>。原因短语是一种人类可读的消息，用于阐明响应的结果。<code>4xx</code>范围内的HTTP状态代码指示客户端错误（验证或逻辑错误），而范围内的HTTP状态代码<code>5xx</code>指示服务器端错误（通常是缺陷或中断）。但是，这些状态码和人类可读的原因短语不足以以机器可读的方式传达有关错误的足够信息。要解决错误，非人类的RESTful API使用者需要其他帮助。</p>
<p>因此，API必须返回符合<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04">Common Types</a>储存库中<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error.json"><code>error.json</code></a>定义的架构的JSON错误表示。建议API所属的名称空间具有与其关联的错误目录。请参阅<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#error-catalog">错误目录</a>以获取更多详细信息。</p>
<h3 id="1-错误模式"><a href="#1-错误模式" class="headerlink" title="1. 错误模式"></a>1. 错误模式</h3><p><code>error.json</code>作为模式的错误响应必须包括以下字段：</p>
<ul>
<li><p><code>name</code>：错误的易于理解的唯一名称。建议<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error_spec.json"><code>error_spec.json#name</code></a>在发送错误响应之前从错误目录中检索此值。</p>
</li>
<li><p>```<br>details</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：包含错误的各个实例的数组，其具体内容如下。客户端错误（</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4xx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ）必填。</span><br><span class="line"></span><br><span class="line">  - `field`：[JSON指向](http://tools.ietf.org/html/rfc6901)错误的字段（如果位于正文中）的[指针](http://tools.ietf.org/html/rfc6901)，否则为path参数或查询参数的名称。</span><br><span class="line">  - `value`：错误字段的值。</span><br><span class="line">  - `issue`：错误原因。建议[`error_spec_issue.json#issue`](https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error_spec_issue.json)在发送错误响应之前从错误目录中检索此值。</span><br><span class="line">  - `location`：在错误的字段中，所述的位置`query`，`path`或`body`。如果不存在此字段，则默认值为`body`。</span><br><span class="line"></span><br><span class="line">- `debug_id`：一个唯一的错误标识符，在服务器端生成并记录为关联目的。</span><br><span class="line"></span><br><span class="line">- `message`：一条人类可读的消息，描述了错误。此消息必须是问题的描述，而不是有关解决方法的建议。建议[`error_spec.json#message`](https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error_spec.json)在发送错误响应之前从错误目录中检索此值。</span><br><span class="line"></span><br><span class="line">- `links`：特定于错误情况的[HATEOAS](https://github.com/paypal/api-standards/blob/master/hypermedia.md)链接。使用这些链接可提供有关错误情况以及如何解决该问题的更多信息。您可以插入来自[`error_spec.json#suggested_application_actions`](https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error_spec.json)和/或[`error_spec.json#suggested_user_actions`](https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error_spec.json)此处的链接，以及与API相关的其他HATEOAS链接。</span><br><span class="line"></span><br><span class="line">以下字段是可选的：</span><br><span class="line"></span><br><span class="line">- `information_link`：（`deprecated`）与此错误相关的扩展开发人员信息的URI；这应该是指向错误类型的公开文档的链接。使用`links`代替。</span><br><span class="line"></span><br><span class="line">###### JSON指针的使用</span><br><span class="line"></span><br><span class="line">如果您使用其他方法`field`在已经发布的API中标识，则可以继续使用现有方法。但是，如果您打算迁移到建议的方法，则希望提高API的主要版本并为客户提供迁移帮助，因为这可能对他们来说是一个潜在的重大变化。</span><br><span class="line"></span><br><span class="line">JSON指针`field`应为[JSON字符串值](https://tools.ietf.org/html/rfc6901#section-5)。</span><br><span class="line"></span><br><span class="line">#### 输入验证错误</span><br><span class="line"></span><br><span class="line">在验证请求时，应按以下顺序解决各种问题：</span><br><span class="line"></span><br><span class="line">| 要求验证问题                                                 | HTTP状态码                 |</span><br><span class="line">| ------------------------------------------------------------ | -------------------------- |</span><br><span class="line">| 格式不正确的JSON。                                           | `400 Bad Request`          |</span><br><span class="line">| 包含客户端可以更改的验证错误。                               | `400 Bad Request`          |</span><br><span class="line">| 由于请求主体之外的因素而无法执行。该请求格式正确，但由于语义错误而无法遵循。 | `422 Unprocessable Entity` |</span><br><span class="line"></span><br><span class="line">### 2. 错误样本</span><br><span class="line"></span><br><span class="line">本节提供一些示例来描述[`error.json`](https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error.json)在各种情况下的用法。</span><br><span class="line"></span><br><span class="line">##### i. 验证错误响应-单个字段</span><br><span class="line"></span><br><span class="line">下面的示例`VALIDATION_ERROR`在一个字段中显示类型的验证错误。由于这是客户端错误，因此`400 Bad Request`应返回HTTP状态代码。</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;  </span><br><span class="line">   &quot;name&quot;:&quot;VALIDATION_ERROR&quot;,</span><br><span class="line">   &quot;details&quot;:[  </span><br><span class="line">      &#123;  </span><br><span class="line">         &quot;field&quot;:&quot;#/credit_card/expire_month&quot;,</span><br><span class="line">         &quot;issue&quot;:&quot;Required field is missing&quot;,</span><br><span class="line">         &quot;location&quot;:&quot;body&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;debug_id&quot;:&quot;123456789&quot;,</span><br><span class="line">   &quot;message&quot;:&quot;Invalid data provided&quot;,</span><br><span class="line">   &quot;information_link&quot;:&quot;http://developer.foo.com/apidoc/blah#VALIDATION_ERROR&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ii-验证错误响应-多个字段"><a href="#ii-验证错误响应-多个字段" class="headerlink" title="ii. 验证错误响应-多个字段"></a>ii. 验证错误响应-多个字段</h5><p>以下示例<code>VALIDATION_ERROR</code>在两个字段中显示了相同类型的验证错误。请注意，这<code>details</code>是一个列出错误中所有实例的数组。由于这两个都是客户端错误，因此<code>400 Bad Request</code>应返回HTTP状态代码。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;VALIDATION_ERROR&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;details&quot;</span>: [  </span><br><span class="line">      &#123;  </span><br><span class="line">         <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;/credit_card/expire_month&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;issue&quot;</span>: <span class="string">&quot;Required field is missing&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;body&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  </span><br><span class="line">         <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;/credit_card/currency&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;XYZ&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;issue&quot;</span>: <span class="string">&quot;Currency code is invalid&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;body&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">&quot;debug_id&quot;</span>: <span class="string">&quot;123456789&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Invalid data provided&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;information_link&quot;</span>: <span class="string">&quot;http://developer.foo.com/apidoc/blah#VALIDATION_ERROR&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="iii-验证错误响应-批量"><a href="#iii-验证错误响应-批量" class="headerlink" title="iii. 验证错误响应-批量"></a>iii. 验证错误响应-批量</h5><p>对于如下所示<code>OBJECT_NOT_FOUND_ERROR</code>和的异类客户端错误<code>MULTIPLE_CORE_BUNDLES</code>，将<code>errors</code>返回一个名为的数组。每个错误实例在此数组中均表示为一项。由于这些是客户端验证错误，因此<code>400 Bad Request</code>应返回HTTP状态代码。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;errors&quot;</span>: [  </span><br><span class="line">   &#123;  </span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;OBJECT_NOT_FOUND_ERROR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;debug_id&quot;</span>: <span class="string">&quot;38cdd677a83a4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Bundle is not found.&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;information_link&quot;</span>: <span class="string">&quot;&lt;link to public doc describing OBJECT_NOT_FOUND_ERROR error&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;details&quot;</span>: [  </span><br><span class="line">         &#123;  </span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;/bundles/0/bundle_id&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;33333&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;issue&quot;</span>: <span class="string">&quot;BUNDLE_NOT_FOUND&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;body&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;  </span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;MULTIPLE_CORE_BUNDLES&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;debug_id&quot;</span>: <span class="string">&quot;52cde38284sd3&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Multiple CORE bundles.&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;information_link&quot;</span>: <span class="string">&quot;&lt;link to public doc describing MULTIPLE_CORE_BUNDLES error&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;details&quot;</span>: [  </span><br><span class="line">         &#123;  </span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;/bundles/5/bundle_id&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;88888&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;issue&quot;</span>: <span class="string">&quot;MULTIPLE_CORE_BUNDLES&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;body&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="vi-语义验证错误响应"><a href="#vi-语义验证错误响应" class="headerlink" title="vi. 语义验证错误响应"></a>vi. 语义验证错误响应</h5><p>如果客户端输入的格式正确且有效，但请求操作可能需要与此URI之外的API或进程进行交互，<code>422 Unprocessable Entity</code>则应返回HTTP状态代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   &quot;name&quot;: &quot;BALANCE_ERROR&quot;,</span><br><span class="line">   &quot;debug_id&quot;: &quot;123456789&quot;,</span><br><span class="line">   &quot;message&quot;: &quot;The account balance is too low. Add balance to your account to proceed.&quot;,</span><br><span class="line">   &quot;information_link&quot;: &quot;http://developer.foo.com/apidoc/blah#BALANCE_ERROR&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-API规范中的错误声明"><a href="#2-API规范中的错误声明" class="headerlink" title="2. API规范中的错误声明"></a>2. API规范中的错误声明</h3><p>文档生成工具和客户端/服务器端绑定生成工具必须识别，这一点很重要<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/error.json"><code>error.json</code></a>。下一节显示了如何<code>error.json</code>在API规范中引用OpenAPI。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;responses&quot;: &#123;</span><br><span class="line">          &quot;200&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;Address successfully found and returned.&quot;,</span><br><span class="line">            &quot;schema&quot;: &#123;</span><br><span class="line">              &quot;$ref&quot;: &quot;address.json&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;403&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;Unauthorized request.  This error will occur if the SecurityContext header is not provided or does not include a party_id.&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;404&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;The requested address does not exist.&quot;,</span><br><span class="line">            &quot;schema&quot;: &#123;</span><br><span class="line">              &quot;$ref&quot;: &quot;v1/schema/json/draft-04/error.json&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;default&quot;: &#123;</span><br><span class="line">            &quot;description&quot;: &quot;Unexpected error response.&quot;,</span><br><span class="line">            &quot;schema&quot;: &#123;</span><br><span class="line">              &quot;$ref&quot;: &quot;v1/schema/json/draft-04/error.json&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、API版本控制"><a href="#九、API版本控制" class="headerlink" title="九、API版本控制"></a>九、API版本控制</h2><p>本节介绍如何版本化API。它描述了API的生命周期状态，列举了版本控制策略，描述了与向后兼容的准则，并描述了生命周期终止策略。</p>
<h3 id="1-API生命周期"><a href="#1-API生命周期" class="headerlink" title="1. API生命周期"></a>1. API生命周期</h3><p>以下是API生命周期状态的示例。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>计划(PLANNED)</td>
<td>API已计划开发。已经建立了API发布计划。</td>
</tr>
<tr>
<td>测试版(BETA)</td>
<td>API可以运行，并且可以供生产中的选定新订户使用，以进行测试，验证和推出新API的目的。</td>
</tr>
<tr>
<td>服役(LIVE)</td>
<td>API已投入使用，生产中的新订户均可使用。完全支持API版本。</td>
</tr>
<tr>
<td>已淘汰(DEPRECATED)</td>
<td>API是可操作的，并且在运行时可供现有订户使用。完全支持API版本，包括以向后兼容的方式解决的错误修复。API版本不适用于新订户。</td>
</tr>
<tr>
<td>退役(RETIRED)</td>
<td>API未从生产中发布，并且在运行时不再对任何订阅者可用。进入此状态的所有已部署应用程序的占用空间必须从生产和阶段环境中完全删除。</td>
</tr>
</tbody></table>
<h3 id="2-API版本政策"><a href="#2-API版本政策" class="headerlink" title="2. API版本政策"></a>2. API版本政策</h3><p>API是版本化产品，必须遵守以下版本化原则。</p>
<ol>
<li>API规范必须遵循版本控制方案，在此<code>v</code>版本中，引入版本时，主版本号是<code>1</code>第一个LIVE版本的序号，<code>0</code>而次要版本是任何主版本的第一个次要版本的序号。</li>
<li>每当对API进行增量更改时，无论是否向后兼容，都必须对API规范进行版本控制。这样就可以对更改进行标记，记录，审查，讨论，发布和传达。</li>
<li>API端点只能反映主要版本。</li>
<li>API规范版本反映了接口更改，可以与服务实现版本控制方案分开。</li>
<li>次要API版本必须与同一个主要版本中的所有先前次要版本保持向后兼容性。</li>
<li>主要的API版本可以保持与先前主要版本的向后兼容性。</li>
</ol>
<p>对于给定的功能集，<code>LIVE</code>所有主要版本和次要版本在任何给定时间都必须只有一个API版本处于状态。这样可以确保订阅者始终了解他们应该使用哪个版本的API产品。例如，v1.2 <code>RETIRED</code>，v1.3 <code>DEPRECATED</code>或v2.0 <code>LIVE</code>。</p>
<h3 id="3-向后兼容"><a href="#3-向后兼容" class="headerlink" title="3. 向后兼容"></a>3. 向后兼容</h3><p>API应该以向前和可扩展的方式进行设计，以保持兼容性并避免资源，功能和过多版本控制的重复。</p>
<p>API必须遵循以下原则才能被认为是向后兼容的：</p>
<ol>
<li>所有更改都必须加和。</li>
<li>所有更改都必须是可选的。</li>
<li>语义不得改变。</li>
<li>查询参数和请求主体参数必须无序。</li>
<li>现有资源的附加功能必须实现：<ol>
<li>作为可选扩展，或</li>
<li>作为对新子资源的操作，或者</li>
<li>如果不能合理扩展现有操作（例如，资源创建），则通过更改请求主体，同时仍可以接受所有先前存在的现有请求变化。</li>
</ol>
</li>
</ol>
<h4 id="3-1-向后不兼容更改的非详尽清单"><a href="#3-1-向后不兼容更改的非详尽清单" class="headerlink" title="3.1 向后不兼容更改的非详尽清单"></a>3.1 向后不兼容更改的非详尽清单</h4><p><strong>URIs</strong></p>
<ol>
<li>资源URI可以支持其他查询参数，但是不能是必需的。</li>
<li>没有新添加的查询参数，请求URI的API行为不得有任何变化。</li>
<li>具有约束条件的新参数不得添加到请求中。</li>
<li>现有参数，整个表示形式或资源的语义不应更改。</li>
<li>服务必须识别参数的先前有效值，并且在使用时不应抛出错误。</li>
<li>URI返回的HTTP状态代码一定不能有任何变化。</li>
<li>必须不存在的HTTP动词（如任何变化<code>GET</code>，<code>POST</code>，<code>PUT</code>或<code>PATCH</code>）由URI早期支持。URI可以支持一个新的HTTP动词。</li>
<li>URI的请求或响应标头的名称和类型不得有任何更改。可以添加其他头，只要它们是可选的。</li>
</ol>
<p><strong>API仅支持媒体类型<code>application/json</code>。以下内容适用于JSON表示形式的稳定性。</strong></p>
<ol>
<li>API响应的JSON对象中的现有属性必须继续以相同的名称和JSON类型（数字，整数，字符串，数组，对象）返回。</li>
<li>如果响应字段的值是一个数组，则该数组中内容的类型不得更改。</li>
<li>如果响应字段的值是一个对象，则兼容性策略必须整体应用于JSON对象。</li>
<li>可以随时将新属性添加到表示中，但是不应改变现有属性的含义。</li>
<li>添加的新属性一定不是必需的。</li>
<li>确保在响应中包含必填字段。</li>
<li>对于原始类型，除非在API文档中有描述的约束（例如，字符串的长度，ENUM类型的可能值），否则客户端不得假定这些值以任何方式受到约束。</li>
<li>如果对象的属性是URI，则它必须具有与URI相同的稳定性。</li>
<li>对于返回HATEOAS链接作为表示形式一部分的API，rel和href的值必须保持相同。</li>
<li>对于ENUM类型，不得支持已支持的枚举值或这些值的含义。</li>
</ol>
<h3 id="4-终止政策"><a href="#4-终止政策" class="headerlink" title="4. 终止政策"></a>4. 终止政策</h3><p>终止（EOL）策略规定了API版本从过渡<code>LIVE</code>到<code>RETIRED</code>状态的方式。它旨在确保需要从旧版API迁移到新版API的API客户获得一致且合理的过渡期，同时使健康的流程可以消除技术债务。</p>
<p><strong>次要API版本EOL</strong></p>
<p>根据版本控制政策，次要API版本必须与同一主要版本中的先前次要版本向后兼容。因此，次要API版本是<code>RETIRED</code>紧随同一主要版本的较新次要版本之后<code>LIVE</code>。此更改应不会对现有订户产生影响，因此无需通过<code>DEPRECATED</code>状态转换即可促进客户端迁移。</p>
<p><strong>主要API版本EOL</strong></p>
<p>根据版本控制政策，主要API版本可以与先前的主要版本向后兼容。因此，退休主要API版本时，以下规则适用。</p>
<ol>
<li>在<code>DEPRECATED</code>替代服务<code>LIVE</code>为所有将继续保留的功能提供清晰的客户迁移路径之前，不得使用主要的API版本。此应包括文档以及适当的迁移工具和示例代码，这些代码可为客户提供进行干净迁移所需的内容。</li>
<li>不推荐使用的API版本必须处于<code>DEPRECATED</code>最短状态，以便为客户客户提供足够的迁移通知。应根据具体情况考虑使用外部客户端弃用API版本，并且可能需要额外的弃用时间和/或约束，以最大程度地减少对业务的影响。</li>
<li>如果处于<code>LIVE</code>或<code>DEPRECATED</code>状态的版本化API 没有客户端，则可以<code>RETIRED</code>立即移至该状态。</li>
</ol>
<h4 id="4-1-生命周期终止政策–替代主要API版本简介"><a href="#4-1-生命周期终止政策–替代主要API版本简介" class="headerlink" title="4.1 生命周期终止政策–替代主要API版本简介"></a>4.1 生命周期终止政策–替代主要API版本简介</h4><p>由于导致淘汰已存在的API版本的新的主要API版本是一项重大的商业投资决定，因此API所有者必须在开始大量的设计和开发工作之前，为新的主要版本辩护。API所有者应该探索引入新的主要API版本的所有可能替代方法，目的是在决定引入新版本之前将对客户的影响最小化。理由应包括以下内容：</p>
<p>商业案例</p>
<ol>
<li>新版本交付的客户价值是现有版本无法实现的。</li>
<li>过时版本与新版本之间的成本效益分析。</li>
<li>解释引入新的主要版本的替代方法，以及为何未选择这些替代方法。</li>
<li>如果需要向后不兼容的更改来解决关键的安全问题，则不需要第1项和第2项。</li>
</ol>
<p>API设计</p>
<ol>
<li>新API版本中所有资源的域模型，以及它们与先前主要API版本的域模型的比较方式。</li>
<li>API操作及其实现的用例的描述。</li>
<li>定义性能和可用性的服务级别目标，该目标与要弃用的主要API版本相同或更好。</li>
</ol>
<p>迁移策略</p>
<ol>
<li>受影响的现有客户数量；内部，外部和合作伙伴。</li>
<li>沟通和支持计划，以告知现有客户新版本，价值和迁移路径。</li>
</ol>
<h2 id="十、弃用"><a href="#十、弃用" class="headerlink" title="十、弃用"></a>十、弃用</h2><p>本文档介绍了随着API的发展而弃用API部分的解决方案。它是API版本控制策略的扩展。</p>
<h3 id="使用条款"><a href="#使用条款" class="headerlink" title="使用条款"></a>使用条款</h3><p><em><code>API Element</code><em>在本文档中使用该术语来指代可能在API中弃用的</em>事物</em>。的示例<code>API Element</code>包括：端点，查询参数，路径参数，JSON对象架构中的属性，类型的JSON对象架构或自定义HTTP标头。</p>
<p>该术语*<code>old API</code>*用于表示您的API所取代的现有次要或主要版本或现有的其他API。</p>
<p>该术语*<code>new API</code>*用于表示您的API的新的次要版本或主要版本，或替代的新的其他API <code>old API</code>。</p>
<p>*<code>API definition</code>*是遵循<a href="http://swagger.io/specification">OpenAPI</a>的服务接口规范的形式。API的定义可以在中找到<code>swagger.json</code>。</p>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>定义API时，您必须做出许多具有长期影响的重大决策。目的是制作一个长寿，耐用和可重用的API。您正在尝试使其“正确”。但是实际上，您不会每次都成功。引入了新的需求。您对问题的理解会发生变化。当时看起来不错的决定，现在可能会限制您优雅地扩展API以满足新理解的能力。随着影响的逐渐集中，过去做出的轻量级决策现在似乎有些沉重。保持向后兼容性是一个持续的挑战。</p>
<p>一种选择是创建API的新主版本。这使您可以抛弃过去的决定而重新开始。不幸的是，这还意味着您的所有客户现在都需要迁移到新的端点，以便进行任何新工作来交付客户价值。这很难。没有良好的激励，许多客户就不会搬家。管理客户迁移有很多开销。您还需要在相当长的一段时间内支持两组接口。另一个考虑因素是您的API产品可能有多个端点，但是您要进行的重大更改只会影响一个端点。使您的客户为所有API端点迁移其应用程序只是为了“修复”一小部分，是一项非常沉重且昂贵的更改。从哲学和工程学的角度来看，虽然纯粹而简单，从投资回报率的角度来看，这通常是不合理的。本指南的目的是找到一个中间立场，该中间立场在需要进行微小更改时提供一条更实际的途径，但从本质上讲，这仍与<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#api-versioning-policy">API版本控制政策</a>。</p>
<h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><p>以下是弃用的要求。</p>
<ol>
<li>API开发人员应该能够弃用<code>API Element</code>次要版本的API。</li>
<li>API规范必须突出显示API的一个或多个已弃用的元素，以便API使用者知道。</li>
<li>API服务器务必在运行时通知客户端应用有关请求和/或响应中存在的不赞成使用的元素，以便工具可以识别此情况，记录警告并根据需要突出显示不赞成使用的元素的用法。</li>
<li>已过时<code>API Elements</code>必须为主要版本的生活依然支持或直至客户不再使用它们（的手段，以确定这都留给了API所有者的自由裁量权，因为这是他们的客户谁最终会受到影响）。</li>
</ol>
<h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>下面介绍如何解决上面列出的要求。该解决方案涉及使用注释解决文档相关需求，并使用自定义标头解决运行时相关需求。</p>
<ol>
<li><a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#deprecation-documentation">文献资料</a></li>
<li><a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#deprecation-runtime">运行</a></li>
</ol>
<h4 id="3-1-文献资料"><a href="#3-1-文献资料" class="headerlink" title="3.1 文献资料"></a>3.1 文献资料</h4><p>在API的定义中，名为的可选注释<code>x-deprecated</code>用于将标记<code>API Element</code>为。</p>
<h5 id="注释：x弃用"><a href="#注释：x弃用" class="headerlink" title="注释：x弃用"></a>注释：x弃用</h5><p><code>x-deprecated</code>可用于弃用任何类型的<code>API Element</code>。注释应在<code>API Element</code>定义的位置内联使用。期望通过反省API定义来生成文档的API工具会识别此注释，并突出显示<code>API Element</code>已弃用的相应注释。还假定该注释可以被包括生成实现绑定（POJO）的工具完全忽略。换句话说，将不会<code>@deprecated</code>为该<code>x-deprecated</code>注释生成任何特定于实现语言的构造（例如Java注解），也不在此解决方案的范围内。</p>
<p>据预计，该API文档将突出废弃的<code>API Elements</code>通过注释<code>x-deprecated</code>的API规范，清楚，并在适当的粒度。</p>
<h5 id="x弃用的注释的架构"><a href="#x弃用的注释的架构" class="headerlink" title="x弃用的注释的架构"></a>x弃用的注释的架构</h5><p>我们提供了特定的JSON对象类型，以用于弃用specific <code>API Elements</code>。本节列出了这些类型的架构。为的特定应用提供模式的目的<code>x-annotation</code>是使API开发人员易于注释<code>API definition</code>和API工具，以突出显示每个不推荐<code>API Element</code>使用的细节。</p>
<h6 id="通用架构元素"><a href="#通用架构元素" class="headerlink" title="通用架构元素"></a>通用架构元素</h6><p>以下是在用于JSON的新JSON对象类型中使用的常见模式类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;x-deprecatedValue&quot;: &#123;</span><br><span class="line">	&quot;type&quot;: &quot;string&quot;,</span><br><span class="line">	&quot;description&quot;: &quot;Value of the element that is deprecated. Use to deprecate a particular value in parameter or schema property as applicable.&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;x-deprecatedSee&quot;: &#123;</span><br><span class="line">	&quot;type&quot;: &quot;string&quot;,</span><br><span class="line">	&quot;description&quot;: &quot;URI (indirect or absolute) or name of to new parameter, resource, method, api_element, as applicable.&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;x-apiVersion&quot;: &#123;</span><br><span class="line">	&quot;pattern&quot;: &quot;^[1-9][0-9]*[.][0-9]+$&quot;,</span><br><span class="line">	&quot;minLength&quot;: 3,</span><br><span class="line">	&quot;maxLength&quot;: 8,</span><br><span class="line">	&quot;description&quot;: &quot;This string should contain the release or version number at which this schema element became deprecated. Version should be in the format &#x27;&#123;major&#125;.&#123;minor&#125;&#x27; (no leading &#x27;v&#x27;).&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="弃用的资源"><a href="#弃用的资源" class="headerlink" title="弃用的资源"></a>弃用的资源</h6><p>以下模式必须用于弃用中的资源对象<code>API definition</code>。中的资源对象的示例<code>swagger.json</code>是：<code>operation</code>和<code>paths</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;x-deprecatedResource&quot;: &#123;</span><br><span class="line">	&quot;type&quot;: &quot;object&quot;,</span><br><span class="line">	&quot;title&quot;: &quot;Schema for a deprecated resource.&quot;,</span><br><span class="line">	&quot;description&quot;: &quot;Schema for deprecating a resource API element. A resource API element could be an operation or paths.&quot;,</span><br><span class="line">	&quot;properties&quot;: &#123;</span><br><span class="line">		&quot;see&quot;: &#123;</span><br><span class="line">			&quot;$ref&quot;: &quot;#/definitions/x-deprecatedSee&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;since_version&quot;: &#123;</span><br><span class="line">			&quot;$ref&quot;: &quot;#/definitions/x-apiVersion&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下部分提供了几个示例，这些示例显示了资源级别的<code>deprecatedResource</code>for <code>x-deprecated</code>注释的用法。</p>
<h6 id="示例：不推荐使用的资源"><a href="#示例：不推荐使用的资源" class="headerlink" title="示例：不推荐使用的资源"></a>示例：不推荐使用的资源</h6><p>下面的示例演示弃用命名的资源<code>commercial-entities</code>在<code>swagger.json</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;paths&quot;: &#123;</span><br><span class="line">   </span><br><span class="line">    &quot;/commercial-entities&quot;: &#123;</span><br><span class="line">         &quot;x-deprecated&quot;: &#123;</span><br><span class="line">        		&quot;see&quot;: &quot;financial-entities&quot;,</span><br><span class="line">        		&quot;since_version&quot;: &quot;1.4&quot;</span><br><span class="line">        	&#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="示例：不推荐使用的方法"><a href="#示例：不推荐使用的方法" class="headerlink" title="示例：不推荐使用的方法"></a>示例：不推荐使用的方法</h6><p>下面的示例显示了不推荐使用的方法，<code>PUT /commercial-entities/&#123;merchant_id&#125;/agreements</code>并鼓励使用新方法<code>PATCH /commercial-entities/&#123;merchant_id&#125;/agreements</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;paths&quot;: &#123;</span><br><span class="line">    &quot;/commercial-entities/&#123;merchant_id&#125;/agreements&quot;: &#123;</span><br><span class="line">        &quot;put&quot;: &#123;</span><br><span class="line">            &quot;summary&quot;: &quot;Updates the Commercial Entity Agreements Details for a Merchant.&quot;,</span><br><span class="line">            &quot;operationId&quot;: &quot;commercial-entity.agreement.update&quot;,</span><br><span class="line">            &quot;x-deprecated&quot;: &#123;</span><br><span class="line">        			&quot;see&quot;: &quot;patch&quot;,</span><br><span class="line">        			&quot;since_version&quot;: &quot;1.4&quot;</span><br><span class="line">        	&#125;,</span><br><span class="line">        	&quot;parameters&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;merchant_id&quot;,</span><br><span class="line">                    &quot;in&quot;: &quot;path&quot;,</span><br><span class="line">                    &quot;description&quot;: &quot;The encrypted Merchant&#x27;s identifier.&quot;,</span><br><span class="line">                    &quot;required&quot;: true,</span><br><span class="line">                    &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;Agreements&quot;,</span><br><span class="line">                    &quot;in&quot;: &quot;body&quot;,</span><br><span class="line">                    &quot;description&quot;: &quot;An array of AgreementDetails&quot;,</span><br><span class="line">                    &quot;required&quot;: true,</span><br><span class="line">                    &quot;schema&quot;: &#123;</span><br><span class="line">                        &quot;$ref&quot;: &quot;./model/agreement_details.json&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h5 id="不推荐使用的参数"><a href="#不推荐使用的参数" class="headerlink" title="不推荐使用的参数"></a>不推荐使用的参数</h5><p><code>swagger.json</code>提供了一种为方法定义一个或多个参数的方法。参数的类型为：路径，查询和标头。通常，可以弃用查询和标头参数。<code>x-deprecated</code>对参数使用注释时，必须使用以下模式。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;x-deprecatedParameter&quot;</span>: &#123;</span><br><span class="line">	<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Schema for a deprecated parameter.&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Schema for deprecating an API element inline. The API element could be a custom HTTP header or a query param.&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;value&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/x-deprecatedValue&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;see&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/x-deprecatedSee&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;since_version&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/x-apiVersion&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下部分提供了几个示例，显示<code>deprecatedParameter</code>了<code>x-deprecated</code>在参数级别使用for 注释的情况。</p>
<h6 id="示例：不建议使用的查询参数"><a href="#示例：不建议使用的查询参数" class="headerlink" title="示例：不建议使用的查询参数"></a>示例：不建议使用的查询参数</h6><p>下面的示例显示<code>x-deprecated</code>批注中<code>swagger.json</code>用于指示查询参数已弃用的用法<code>record_date</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/commercial-entities/&#123;merchant_id&#125;&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;get&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;summary&quot;</span>: <span class="string">&quot;Gets a Commercial Entity as denoted by the merchant_id.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Gets the Commercial Entity as denoted by the merchant_id.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;operationId&quot;</span>: <span class="string">&quot;commercial-entity.get&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parameters&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;record_date&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;in&quot;</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;The date to use for the query; defaulted to yesterday.&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;required&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;x-deprecated&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;since_version&quot;</span>: <span class="string">&quot;1.5&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;see&quot;</span>: <span class="string">&quot;transaction_date&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;transaction_date&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;in&quot;</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;The date to use for the query; defaulted to yesterday.&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;required&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<h6 id="示例：不建议使用的标题"><a href="#示例：不建议使用的标题" class="headerlink" title="示例：不建议使用的标题"></a>示例：不建议使用的标题</h6><p>以下示例显示了一个已弃用的自定义HTTP标头，名为<code>CLIENT_INFO</code>。</p>
<h6 id="OpenAPI"><a href="#OpenAPI" class="headerlink" title="OpenAPI"></a>OpenAPI</h6><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/commercial-entities/&#123;merchant_id&#125;&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;get&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;summary&quot;</span>: <span class="string">&quot;Gets a Commercial Entity as denoted by the merchant_id.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Gets the Commercial Entity as denoted by the merchant_id.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;operationId&quot;</span>: <span class="string">&quot;commercial-entity.get&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parameters&quot;</span>: [</span><br><span class="line">            ...</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;CLIENT_INFO&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;in&quot;</span>: <span class="string">&quot;header&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Optional header for all the API&#x27;s to pass on api caller tracking information. This header helps capture any input from the caller service and pass it along to analytics for tracking .&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;in&quot;</span> : <span class="string">&quot;header&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;x-deprecated&quot;</span>: &#123;</span><br><span class="line">                     <span class="attr">&quot;since_version&quot;</span>: <span class="string">&quot;1.5&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<h6 id="示例：不建议使用的查询参数值"><a href="#示例：不建议使用的查询参数值" class="headerlink" title="示例：不建议使用的查询参数值"></a>示例：不建议使用的查询参数值</h6><p>以下示例显示了中的<code>x-deprecated</code>注释的用法，<code>swagger.json</code>以指示已弃用<code>y</code>名为的查询参数的特定值（）<code>fields</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/commercial-entities&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;get&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;summary&quot;</span>: <span class="string">&quot;Gets Commercial Entities.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Gets the Commercial Entities.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;operationId&quot;</span>: <span class="string">&quot;commercial-entity.get&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parameters&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;fields&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;in&quot;</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Fields to return in response, default is x, possible values are x, y, z.&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;required&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;x-deprecated&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;since_version&quot;</span>: <span class="string">&quot;1.5&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;y&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;transaction_date&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;in&quot;</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;The date to use for the query; defaulted to yesterday.&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;required&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<h5 id="弃用的JSON对象架构"><a href="#弃用的JSON对象架构" class="headerlink" title="弃用的JSON对象架构"></a>弃用的JSON对象架构</h5><p>为了将JSON对象架构内不建议使用JSON对象本身或一个或多个属性的一个模式，我们建议使用一种叫做架构<code>deprecatedSchema</code>的<code>x-deprecated</code>注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;x-deprecatedSchema&quot;: &#123;</span><br><span class="line">	&quot;type&quot;: &quot;array&quot;,</span><br><span class="line">	&quot;description&quot;: &quot;Schema for a collection of deprecated items in a schema.&quot;,</span><br><span class="line">	&quot;items&quot;: &#123;</span><br><span class="line">		&quot;$ref&quot;: &quot;#/definitions/x-deprecatedSchemaProperty&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;x-deprecatedSchemaProperty&quot;: &#123;</span><br><span class="line">	&quot;type&quot;: &quot;object&quot;,</span><br><span class="line">	&quot;title&quot;: &quot;Schema for a deprecated schema property or schema itself.&quot;,</span><br><span class="line">	&quot;description&quot;: &quot;Schema for deprecating an API element within JSON Object schema. The API element could be an individual property of a schema of a JSON type or an entire schema representing JSON object.&quot;,</span><br><span class="line">	&quot;required&quot;: [&quot;api_element&quot;],</span><br><span class="line">	&quot;properties&quot;: &#123;</span><br><span class="line">		&quot;api_element&quot;: &#123;</span><br><span class="line">			&quot;type&quot;: &quot;string&quot;,</span><br><span class="line">			&quot;description&quot;: &quot;JSON pointer to API element that is deprecated. If the API element is JSON Object schema of a type itself, JSON pointer MUST point to the root of that schema. If the API element is a property of schema, the JSON pointer MUST point to that property.&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;value&quot;: &#123;</span><br><span class="line">			&quot;$ref&quot;: &quot;#/definitions/x-deprecatedValue&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;see&quot;: &#123;</span><br><span class="line">			&quot;$ref&quot;: &quot;#/definitions/x-deprecatedSee&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;since_version&quot;: &#123;</span><br><span class="line">			&quot;$ref&quot;: &quot;#/definitions/x-apiVersion&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免使用<code>keywords</code>所需的扩展JSON draft-04架构来通过在架构的<code>x-annotation</code>元数据部分中使用来弃用架构本身或在行内弃用单个属性，我们在中选择了<code>x-annotation</code>在JSON Object的引用旁边使用的破坏性较小的途径<code>API definition</code>。因此，应该在<code>API definition</code>“引用”模式中使用该注释。如果可以使用内联，则应该继续并在架构或架构本身中注释不赞成使用的属性。</p>
<p>截至2017年3月，<a href="https://github.com/OAI/OpenAPI-Specification/blob/OpenAPI.next/versions/3.0.md">OpenAPI 3.0.0-rc0</a>引入了<code>deprecated</code>标志以应用于操作，参数和架构字段级别。<code>x-annotation</code>可以与<code>deprecated</code>标志一起使用，以为已弃用的标记提供其他有用的信息<code>API Element</code>。</p>
<h6 id="示例：响应中不建议使用的属性"><a href="#示例：响应中不建议使用的属性" class="headerlink" title="示例：响应中不建议使用的属性"></a>示例：响应中不建议使用的属性</h6><p>下面的示例显示<code>x-deprecated</code>批注中的用法，<code>API definitions</code>以指示已弃用作为<code>address</code>响应命名的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/commercial-entities/&#123;merchant_id&#125;&quot;: &#123;</span><br><span class="line">    &quot;get&quot;: &#123;</span><br><span class="line">        &quot;summary&quot;: &quot;Gets a Commercial Entity as denoted by the merchant_id.&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;Gets the Commercial Entity as denoted by the merchant_id.&quot;,</span><br><span class="line">        &quot;operationId&quot;: &quot;commercial-entity.get&quot;,</span><br><span class="line">        &quot;responses&quot;: &#123;</span><br><span class="line">            &quot;200&quot;: &#123;</span><br><span class="line">                &quot;description&quot;: &quot;The Commercial Entity.&quot;,</span><br><span class="line">                &quot;schema&quot;: &#123;</span><br><span class="line">                    &quot;$ref&quot;: &quot;./model/interaction/commercial-entities/merchant_id/get_response.json&quot;,</span><br><span class="line">                    &quot;x-deprecated&quot;: [</span><br><span class="line">    					   &#123;</span><br><span class="line">    						  &quot;api_element&quot;: &quot;./model/interaction/commercial-entities/merchant_id/get_response.json#/address&quot;,</span><br><span class="line">    						  &quot;see&quot;: &quot;./model/interaction/commercial-entities/merchant_id/get_response.json#/global_address&quot;,</span><br><span class="line">    						  &quot;since_version&quot;: &quot;1.4&quot;</span><br><span class="line">    					   &#125;</span><br><span class="line">    				    ] </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;default&quot;: &#123;</span><br><span class="line">                &quot;description&quot;: &quot;Unexpected error&quot;,</span><br><span class="line">                &quot;schema&quot;: &#123;</span><br><span class="line">                    &quot;$ref&quot;: &quot;v1/schema/json/draft-04/error.json&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h6 id="示例：响应中不推荐使用的枚举"><a href="#示例：响应中不推荐使用的枚举" class="headerlink" title="示例：响应中不推荐使用的枚举"></a>示例：响应中不推荐使用的枚举</h6><p>以下示例显示了中的<code>x-deprecated</code>注释的用法，<code>API definitions</code>以指示已弃用<code>FAILED</code>名为的属性使用的枚举<code>state</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/commercial-entities/&#123;merchant_id&#125;&quot;: &#123;</span><br><span class="line">     &quot;get&quot;: &#123;</span><br><span class="line">         &quot;summary&quot;: &quot;Gets a Commercial Entity as denoted by the specified merchant identifier.&quot;,</span><br><span class="line">         &quot;description&quot;: &quot;Gets the Commercial Entity as denoted by the specified merchant identifier.&quot;,</span><br><span class="line">         &quot;operationId&quot;: &quot;commercial-entity.get&quot;,</span><br><span class="line">         &quot;responses&quot;: &#123;</span><br><span class="line">             &quot;200&quot;: &#123;</span><br><span class="line">                 &quot;description&quot;: &quot;The Commercial Entity.&quot;,</span><br><span class="line">                 &quot;schema&quot;: &#123;</span><br><span class="line">                     &quot;$ref&quot;: &quot;./model/interaction/commercial-entities/merchant_id/get_response.json&quot;,</span><br><span class="line">                     &quot;x-deprecated&quot;: [</span><br><span class="line">     					   &#123;</span><br><span class="line">     						  &quot;api_element&quot;: &quot;./model/interaction/commercial-entities/merchant_id/get_response.json#/state&quot;,</span><br><span class="line">     						  &quot;value&quot;: &quot;FAILED&quot;,</span><br><span class="line">     						  &quot;since_version&quot;: &quot;1.4&quot;</span><br><span class="line">     					   &#125;</span><br><span class="line">     				    ] </span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             &quot;default&quot;: &#123;</span><br><span class="line">                 &quot;description&quot;: &quot;Unexpected error&quot;,</span><br><span class="line">                 &quot;schema&quot;: &#123;</span><br><span class="line">                     &quot;$ref&quot;: &quot;v1/schema/json/draft-04/error.json&quot;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>api-design</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT Kerberos Documentation (1.15.2)</title>
    <url>/2017/11/20/documents/mit_kerberos_documentation/</url>
    <content><![CDATA[<p>本文使用 Google 翻译 Kerberos 官方文档。如有不通顺或错误之处，请大家及时之处，不对的地方请大家参照官方文档</p>
<p><a href="http://web.mit.edu/kerberos/krb5-latest/doc/">MIT Kerberos Documentation (1.15.2)</a></p>
<span id="more"></span>

<p>[TOC]</p>
<h1 id="2-对于管理员"><a href="#2-对于管理员" class="headerlink" title="2 对于管理员"></a>2 对于管理员</h1><h2 id="1-1-安装指南"><a href="#1-1-安装指南" class="headerlink" title="1.1 安装指南"></a>1.1 安装指南</h2><h3 id="1-1-1-安装KDC"><a href="#1-1-1-安装KDC" class="headerlink" title="1.1.1 安装KDC"></a>1.1.1 安装KDC</h3><p>在生产环境中设置Kerberos时，最好将多个从属KDC与主KDC一起使用，以确保Kerberized服务的持续可用性。每个KDC都包含Kerberos数据库的副本。<br>主KDC包含领域数据库的可写拷贝，它会定期复制到从属KDC。所有数据库更改（如密码更改）都在主KDC上进行。当主KDC不可用时，从属KDC提供Kerberos票证授予<br>服务，但不提供数据库管理。麻省理工学院建议您安装所有KDC，以便能够作为主机或其中一个从机。这将使您能够轻松地切换主KDC与其中一个从站（如果需要）<br>（请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#switch-master-slave">切换主从KDC</a>）。<br>此安装过程基于该建议。</p>
<p><strong>警告</strong></p>
<ul>
<li>Kerberos系统依赖于正确的时间信息的可用性。确保主机和所有从机KDC都正确同步时钟。</li>
<li>最好在有限访问的安全和专用硬件上安装和运行KDC。如果您的KDC也是文件服务器，FTP服务器，Web服务器，甚至只是客户端机器，那么通过任何这些区域中的安全漏洞获取root访问权限的用户可能会访问Kerberos数据库。</li>
</ul>
<h4 id="1-1-1-1-安装和配置主KDC"><a href="#1-1-1-1-安装和配置主KDC" class="headerlink" title="1.1.1.1 安装和配置主KDC"></a>1.1.1.1 安装和配置主KDC</h4><p>从操作系统提供的软件包或源中安装Kerberos（请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/build/doing_build.html#do-build">单个树中的构建</a>）。</p>
<p>注意</p>
<p>为了本文档的目的，我们将使用以下名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos.mit.edu    - master KDC</span><br><span class="line">kerberos-1.mit.edu  - slave KDC</span><br><span class="line">ATHENA.MIT.EDU      - realm name</span><br><span class="line">.k5.ATHENA.MIT.EDU  - stash file</span><br><span class="line">admin/admin         - admin principal</span><br></pre></td></tr></table></figure>

<p>有关此主题文件的默认名称和位置，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#mitk5defaults">MIT Kerberos默认值</a>。调整系统环境的名称和路径。</p>
<h4 id="1-1-1-2-编辑KDC配置文件"><a href="#1-1-1-2-编辑KDC配置文件" class="headerlink" title="1.1.1.2 编辑KDC配置文件"></a>1.1.1.2 编辑KDC配置文件</h4><p>修改配置文件<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>和 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf</a>，以反映您的领域的正确信息（如域名域映射和Kerberos服务器名称）。（有关这些文件的推荐默认位置，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#mitk5defaults">MIT Kerberos默认值</a>）。</p>
<p>配置中的大多数标签都具有默认值，对大多数站点都有效。<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>文件中有一些标签必须指定其值，本节将对这些标签进行 说明。</p>
<p>如果这些配置文件的位置与默认配置文件的位置不同，请将<strong>KRB5_CONFIG</strong>和<strong>KRB5_KDC_PROFILE</strong>环境变量分别设置为指向krb5.conf和kdc.conf。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5_CONFIG=/yourdir/krb5.conf</span><br><span class="line">export KRB5_KDC_PROFILE=/yourdir/kdc.conf</span><br></pre></td></tr></table></figure>

<h5 id="krb5-conf"><a href="#krb5-conf" class="headerlink" title="krb5.conf"></a>krb5.conf</h5><p>如果您不使用DNS TXT记录（请参阅将<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#mapping-hostnames">主机名映射到Kerberos领域</a>），必须在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#libdefaults">libdefaults</a> 部分中指定<strong>default_realm</strong>。如果您不使用DNS URI或SRV记录（请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#kdc-hostnames">KDC</a>和<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#kdc-discovery">KDC发现的</a><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#kdc-hostnames">主机名</a>），则必须在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#realms">域</a>部分中包含每个 <em>领域</em> 的 <strong>kdc</strong> 标签。要在每个领域与kadmin服务器进行通信， 必须在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#realms">域</a>部分中设置<strong>admin_server</strong>标记 。</p>
<p>一个例子krb5.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[libdefaults]</span><br><span class="line">    default_realm = ATHENA.MIT.EDU</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        kdc = kerberos.mit.edu</span><br><span class="line">        kdc = kerberos-1.mit.edu</span><br><span class="line">        admin_server = kerberos.mit.edu</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="kdc-conf"><a href="#kdc-conf" class="headerlink" title="kdc.conf"></a>kdc.conf</h5><p>The kdc.conf file can be used to control the listening ports of theKDC and kadmind, as well as realm-specific defaults, the database typeand location, and logging.</p>
<p>An example kdc.conf file:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kdcdefaults]</span><br><span class="line">    kdc_listen = 88</span><br><span class="line">    kdc_tcp_listen = 88</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        kadmind_port = 749</span><br><span class="line">        max_life = 12h 0m 0s</span><br><span class="line">        max_renewable_life = 7d 0h 0m 0s</span><br><span class="line">        master_key_type = aes256-cts</span><br><span class="line">        supported_enctypes = aes256-cts:normal aes128-cts:normal</span><br><span class="line">        # If the default location does not suit your setup,</span><br><span class="line">        # explicitly configure the following values:</span><br><span class="line">        #    database_name = /var/krb5kdc/principal</span><br><span class="line">        #    key_stash_file = /var/krb5kdc/.k5.ATHENA.MIT.EDU</span><br><span class="line">        #    acl_file = /var/krb5kdc/kadm5.acl</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">    # By default, the KDC and kadmind will log output using</span><br><span class="line">    # syslog.  You can instead send log output to files like this:</span><br><span class="line">    kdc = FILE:/var/log/krb5kdc.log</span><br><span class="line">    admin_server = FILE:/var/log/kadmin.log</span><br><span class="line">    default = FILE:/var/log/krb5lib.log</span><br></pre></td></tr></table></figure>

<p>替换<code>ATHENA.MIT.EDU</code>和<code>kerberos.mit.edu分别</code>与您的Kerberos领域和服务器的名称。</p>
<p><strong>注意：</strong></p>
<p>您必须对<strong>database_name</strong>， <strong>key_stash_file</strong>和<strong>acl_file</strong>使用的目标目录（这些目录必须存在）具有写入权限。</p>
<h4 id="1-1-1-2-创建KDC数据库"><a href="#1-1-1-2-创建KDC数据库" class="headerlink" title="1.1.1.2  创建KDC数据库"></a>1.1.1.2  创建KDC数据库</h4><p>您将在主KDC上使用<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kdb5_util.html#kdb5-util-8">kdb5_util</a>命令创建Kerberos数据库和可选的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/stash_file_def.html#stash-definition">存储文件</a>。</p>
<p>注意</p>
<p>如果您选择不安装存储文件，KDC将在每次启动时提示您输入主密钥。这意味着KDC无法自动启动，例如在系统重启后。</p>
<p><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kdb5_util.html#kdb5-util-8">kdb5_util</a>将提示您输入Kerberos数据库的主密码。该密码可以是任何字符串。一个好的密码是你可以记住的密码，但没有人能猜到。不良密码的例子是可以在字典中找到的字词，任何常见或受欢迎的名称，特别是着名人物（或卡通人物），您的用户名（任何形式）（例如，前进，后退，重复两次等），以及本手册中出现的任何样本密码。如果本手册中没有出现的密码的一个例子是“MITiys4K5！”，表示“MIT是Kerberos 5的来源”（这是每个单词的第一个字母，用数字“ 4“表示”for“，最后包括标点符号。）</p>
<p>以下是使用<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kdb5_util.html#kdb5-util-8">kdb5_util</a>命令在主KDC上创建Kerberos数据库和存储文件的示例。用您的Kerberos领域的名称替换<code>ATHENA.MIT.EDU</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% kdb5_util create -r ATHENA.MIT.EDU -s</span><br><span class="line"></span><br><span class="line">Initializing database &#x27;/usr/local/var/krb5kdc/principal&#x27; for realm &#x27;ATHENA.MIT.EDU&#x27;,</span><br><span class="line">master key name &#x27;K/M@ATHENA.MIT.EDU&#x27;</span><br><span class="line">You will be prompted for the database Master Password.</span><br><span class="line">It is important that you NOT FORGET this password.</span><br><span class="line">Enter KDC database master key:  &lt;= Type the master password.</span><br><span class="line">Re-enter KDC database master key to verify:  &lt;= Type it again.</span><br><span class="line">shell%</span><br></pre></td></tr></table></figure>

<p>这将在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR </a> <code>/krb5kdc</code>（或在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf</a>中<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">指定</a>的位置）创建五个文件：</p>
<ul>
<li>两个Kerberos数据库文件，<code>principal</code>和<code>principal.ok</code></li>
<li>Kerberos管理数据库文件<code>principal.kadm5</code></li>
<li>管理数据库锁文件，<code>principal.kadm5.lock</code></li>
<li>在此示例中为<code>.k5.ATHENA.MIT.EDU</code>的存储文件。如果您不想使用存储文件，请运行上述命令而不使用**-s**选项。</li>
</ul>
<p>有关管理Kerberos数据库的更多信息，请参阅Kerberos数据库 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#db-operations">上的操作</a>。</p>
<h4 id="1-1-1-3-将管理员添加到ACL文件"><a href="#1-1-1-3-将管理员添加到ACL文件" class="headerlink" title="1.1.1.3 将管理员添加到ACL文件"></a>1.1.1.3 将管理员添加到ACL文件</h4><p>接下来，您需要创建一个访问控制列表（ACL）文件，并将至少一个管理员的Kerberos主体放在其中。该文件由<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>守护进程用于控制哪些主体可以查看和对Kerberos数据库文件进行特权修改。ACL文件名由<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf中</a>的<strong>acl_file</strong> 变量决定; 默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR</a> <code>/ krb5kdc/kadm5.acl</code>。</p>
<p>有关Kerberos ACL文件的更多信息，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kadm5_acl.html#kadm5-acl-5">kadm5.acl</a>。</p>
<h4 id="1-1-1-4-将管理员添加到Kerberos数据库"><a href="#1-1-1-4-将管理员添加到Kerberos数据库" class="headerlink" title="1.1.1.4 将管理员添加到Kerberos数据库"></a>1.1.1.4 将管理员添加到Kerberos数据库</h4><p>接下来，您需要向Kerberos数据库添加管理主体（即，允许管理Kerberos数据库的主体）。您现在<em>必须</em>至少添加一个主体，以允许通过网络进行Kerberos管理守护程序kadmind和kadmin程序之间的通信，以便进一步管理。为此，请使用主KDC上的kadmin.local实用程序。kadmin.local旨在在主KDC主机上运行，而不对管理服务器使用Kerberos身份验证; 相反，它必须对本地文件系统上的Kerberos数据库具有读写访问权限。</p>
<p>您创建的管理员主体应该是您添加到ACL文件的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#admin-acl">管理员</a>（请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#admin-acl">将管理员添加到ACL文件</a>）。</p>
<p>在以下示例中，将 创建管理主体<code>admin/admin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% kadmin.local</span><br><span class="line"></span><br><span class="line">kadmin.local: addprinc admin/admin@ATHENA.MIT.EDU</span><br><span class="line"></span><br><span class="line">WARNING: no policy specified for &quot;admin/admin@ATHENA.MIT.EDU&quot;;</span><br><span class="line">assigning &quot;default&quot;.</span><br><span class="line">Enter password for principal admin/admin@ATHENA.MIT.EDU:  &lt;= Enter a password.</span><br><span class="line">Re-enter password for principal admin/admin@ATHENA.MIT.EDU:  &lt;= Type it again.</span><br><span class="line">Principal &quot;admin/admin@ATHENA.MIT.EDU&quot; created.</span><br><span class="line">kadmin.local:</span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-5-在主KDC上启动Kerberos守护进程"><a href="#1-1-1-5-在主KDC上启动Kerberos守护进程" class="headerlink" title="1.1.1.5 在主KDC上启动Kerberos守护进程"></a>1.1.1.5 在主KDC上启动Kerberos守护进程</h4><p>此时，您可以在主KDC上启动Kerberos KDC（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>）和管理守护程序。要这样做，键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% krb5kdc</span><br><span class="line">shell% kadmind</span><br></pre></td></tr></table></figure>

<p>每个服务器守护进程将在后台进行分支和运行。</p>
<p>注意</p>
<p>假设您希望这些守护进程在启动时自动启动，可以将它们添加到KDC的<code>/ etc / rc</code>或 <code>/ etc / inittab</code>文件中。为了做到这一点，你需要一个 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/stash_file_def.html#stash-definition">藏书文件</a>。</p>
<p>您可以通过在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf中</a>定义的日志记录位置中检查其启动消息来验证它们是否正常启动 （请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#logging">logging</a>）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% tail /var/log/krb5kdc.log</span><br><span class="line">Dec 02 12:35:47 beeblebrox krb5kdc[3187](info): commencing operation</span><br><span class="line">shell% tail /var/log/kadmin.log</span><br><span class="line">Dec 02 12:35:52 beeblebrox kadmind[3189](info): starting</span><br></pre></td></tr></table></figure>

<p>启动时守护程序遇到的任何错误也将列在日志记录输出中。</p>
<p>作为附加验证，请检查<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/kinit.html#kinit-1">kinit是否</a>成功执行了您在上一步中创建的主体（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#addadmin-kdb">将管理员添加到Kerberos数据库</a>）。跑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% kinit admin/admin@ATHENA.MIT.EDU</span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-6-安装从KDC"><a href="#1-1-1-6-安装从KDC" class="headerlink" title="1.1.1.6 安装从KDC"></a>1.1.1.6 安装从KDC</h4><p>您现在可以开始配置从属KDC。</p>
<p><strong>注意：</strong></p>
<p>假设您正在设置KDC，以便您可以轻松地使用其中一个从站切换主KDC，则应在主KDC和从KDC上执行以上步骤，除非另有说明。</p>
<h5 id="为从KDC创建主机keytabs"><a href="#为从KDC创建主机keytabs" class="headerlink" title="为从KDC创建主机keytabs"></a>为从KDC创建主机keytabs</h5><p>每个KDC需要Kerberos数据库中的<code>主机</code>密钥。将数据库转储文件从主KDC传播到辅助KDC服务器时，这些密钥用于相互验证。</p>
<p>在主KDC上，连接到管理界面，并为每个KDC的<code>主机</code>服务创建主机主体。例如，如果主KDC被称为<code>kerberos.mit.edu</code>，并且您有一个名为<code>kerberos-1.mit.edu</code>的从KDC ，您将键入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% kadmin</span><br><span class="line">kadmin: addprinc -randkey host/kerberos.mit.edu</span><br><span class="line">NOTICE: no policy specified for &quot;host/kerberos.mit.edu@ATHENA.MIT.EDU&quot;; assigning &quot;default&quot;</span><br><span class="line">Principal &quot;host/kerberos.mit.edu@ATHENA.MIT.EDU&quot; created.</span><br><span class="line"></span><br><span class="line">kadmin: addprinc -randkey host/kerberos-1.mit.edu</span><br><span class="line">NOTICE: no policy specified for &quot;host/kerberos-1.mit.edu@ATHENA.MIT.EDU&quot;; assigning &quot;default&quot;</span><br><span class="line">Principal &quot;host/kerberos-1.mit.edu@ATHENA.MIT.EDU&quot; created.</span><br></pre></td></tr></table></figure>

<p>将主KDC服务器置于Kerberos数据库中并不是绝对必要的，但如果希望能够与其中一个从站交换主KDC，则可以方便。</p>
<p>接下来，为所有参与的KDC 提取<code>主机</code>随机密钥，并将其存储在每个主机的默认密钥表文件中。理想情况下，您应该在自己的KDC上本地提取每个keytab。如果这不可行，您应该使用加密会话来通过网络发送它们。要直接在名为<code>kerberos-1.mit.edu</code>的从属KDC上提取密钥表 ，您将执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kadmin: ktadd host/kerberos-1.mit.edu</span><br><span class="line">Entry for principal host/kerberos-1.mit.edu with kvno 2, encryption</span><br><span class="line">    type aes256-cts-hmac-sha1-96 added to keytab FILE:/etc/krb5.keytab.</span><br><span class="line">Entry for principal host/kerberos-1.mit.edu with kvno 2, encryption</span><br><span class="line">    type aes128-cts-hmac-sha1-96 added to keytab FILE:/etc/krb5.keytab.</span><br><span class="line">Entry for principal host/kerberos-1.mit.edu with kvno 2, encryption</span><br><span class="line">    type des3-cbc-sha1 added to keytab FILE:/etc/krb5.keytab.</span><br><span class="line">Entry for principal host/kerberos-1.mit.edu with kvno 2, encryption</span><br><span class="line">    type arcfour-hmac added to keytab FILE:/etc/krb5.keytab.</span><br></pre></td></tr></table></figure>

<p>如果您正在为主KDC上的从属KDC提供一个名为<code>kerberos-1.mit.edu</code>的密钥表 ，那么您应该为该机器的keytab使用专用的临时密钥表文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kadmin: ktadd -k /tmp/kerberos-1.keytab host/kerberos-1.mit.edu</span><br><span class="line">Entry for principal host/kerberos-1.mit.edu with kvno 2, encryption</span><br><span class="line">    type aes256-cts-hmac-sha1-96 added to keytab FILE:/etc/krb5.keytab.</span><br><span class="line">Entry for principal host/kerberos-1.mit.edu with kvno 2, encryption</span><br><span class="line">    type aes128-cts-hmac-sha1-96 added to keytab FILE:/etc/krb5.keytab.</span><br></pre></td></tr></table></figure>

<p>文件<code>/tmp/kerberos-1.keytab</code>可以作为<code>/etc/krb5.keytab</code>安装 在主机<code>kerberos-1.mit.edu上</code>。</p>
<h5 id="配置从KDC"><a href="#配置从KDC" class="headerlink" title="配置从KDC"></a>配置从KDC</h5><p>数据库传播复制主数据库的内容，但不传播配置文件，存储文件或kadm5 ACL文件。以下文件必须手动复制到每个从站（有关这些文件的默认位置，请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#mitk5defaults">MIT Kerberos默认值</a>）：</p>
<ul>
<li>的krb5.conf</li>
<li>kdc.conf中</li>
<li>的kadm5.acl</li>
<li>主密钥存档文件</li>
</ul>
<p>将复制的文件移动到相应的目录中，与主KDC完全相同。kadm5.acl只需要允许从站与主KDC交换。</p>
<p>数据库通过<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kpropd.html#kpropd-8">kpropd</a>守护进程从主KDC传播到从属KDC 。您必须明确指定允许在从机上使用新数据库提供Kerberos转储更新的主体。在KDC状态目录中创建一个名为kpropd.acl的文件，其中包含每个KDC 的<code>主机</code>主体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host/kerberos.mit.edu@ATHENA.MIT.EDU</span><br><span class="line">host/kerberos-1.mit.edu@ATHENA.MIT.EDU</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>如果您希望在一段时间内切换主从KDC，请在所有KDC上的kpropd.acl文件中列出所有参与的KDC服务器的主机主体。否则，您只需要在KDC的kpropd.acl文件中列出主KDC的主机主体。</p>
<p>然后，将以下行添加到每个KDC 上的<code>/etc/inetd.conf中</code>（调整路径为kpropd）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">krb5_prop stream tcp nowait root /usr/local/sbin/kpropd kpropd</span><br></pre></td></tr></table></figure>

<p>您还需要在每个KDC上的<code>/etc/services中</code>添加以下行（如果尚未存在）（假定使用默认端口）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">krb5_prop       754/tcp               # Kerberos slave propagation</span><br></pre></td></tr></table></figure>

<p>重新启动inetd守护进程。</p>
<p>或者，将<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kpropd.html#kpropd-8">kpropd</a>作为独立守护进程启动。启用增量传播时，这是必需的。</p>
<p>现在，从KDC能够接受数据库传播，您需要从主服务器传播数据库。</p>
<p>注意：不要启动从机KDC; 您仍然没有主数据库的副本。</p>
<h5 id="将数据库传播到每个从属"><a href="#将数据库传播到每个从属" class="headerlink" title="将数据库传播到每个从属"></a>将数据库传播到每个从属</h5><p>首先，在主KDC上创建数据库的转储文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% kdb5_util dump /usr/local/var/krb5kdc/slave_datatrans</span><br></pre></td></tr></table></figure>

<p>然后，将数据库手动传播到每个从属KDC，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% kprop -f /usr/local/var/krb5kdc/slave_datatrans kerberos-1.mit.edu</span><br><span class="line"></span><br><span class="line">Database propagation to kerberos-1.mit.edu: SUCCEEDED</span><br></pre></td></tr></table></figure>

<p>您将需要一个脚本来转储和传播数据库。以下是一个Bourne shell脚本的例子。</p>
<p><strong>注意：</strong></p>
<p>请记住，您需要 使用KDC状态目录的名称替换<code>/usr/local/var/krb5kdc</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">kdclist = &quot;kerberos-1.mit.edu kerberos-2.mit.edu&quot;</span><br><span class="line"></span><br><span class="line">kdb5_util dump /usr/local/var/krb5kdc/slave_datatrans</span><br><span class="line"></span><br><span class="line">for kdc in $kdclist</span><br><span class="line">do</span><br><span class="line">    kprop -f /usr/local/var/krb5kdc/slave_datatrans $kdc</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>您将需要设置一个cron作业以在您之前决定的时间间隔内运行此脚本（请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#db-prop">数据库传播</a>）。</p>
<p>现在，从KDC具有Kerberos数据库的副本，您可以启动krb5kdc守护程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell% krb5kdc</span><br></pre></td></tr></table></figure>

<p>与主KDC一样，您可能希望将此命令添加到KDC的<code>/etc/rc</code>或<code>/etc/inittab</code>文件中，以便在启动时自动启动krb5kdc守护程序。</p>
<h5 id="安装失败了？"><a href="#安装失败了？" class="headerlink" title="安装失败了？"></a>安装失败了？</h5><p>您可能会遇到以下错误消息。有关可能的原因和解决方案的更详细的讨论，请单击错误链接重定向到<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/troubleshoot.html#troubleshoot">故障排除</a> 部分。</p>
<ol>
<li><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/troubleshoot.html#kprop-no-route">kprop：连接到服务器时没有到主机的路由</a></li>
<li><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/troubleshoot.html#kprop-con-refused">kprop：连接到服务器时拒绝连接</a></li>
<li><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/troubleshoot.html#kprop-sendauth-exchange">kprop：服务器拒绝身份验证（在sendauth交换期间），同时向服务器进行身份验证</a></li>
</ol>
<h4 id="1-1-1-7-将Kerberos主体添加到数据库"><a href="#1-1-1-7-将Kerberos主体添加到数据库" class="headerlink" title="1.1.1.7 将Kerberos主体添加到数据库"></a>1.1.1.7 将Kerberos主体添加到数据库</h4><p>一旦KDC建立并运行，就可以使用 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmin_local.html#kadmin-1">kadmin</a>将用户，主机和其他服务的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmin_local.html#kadmin-1">主体</a>加载到Kerberos数据库。此过程在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#add-mod-del-princs">添加，修改和删除主体中</a>有详细描述。</p>
<p>您可能偶尔想使用您的一个从属KDC作为主人。如果升 级主KDC，或者主KDC有磁盘崩溃，可能会发生这种情况。有关说明，请参阅以下部分。</p>
<h4 id="1-1-1-9-开关主机和从KDC"><a href="#1-1-1-9-开关主机和从KDC" class="headerlink" title="1.1.1.9 开关主机和从KDC"></a>1.1.1.9 开关主机和从KDC</h4><p>您可能偶尔想使用您的一个从属KDC作为主人。如果升级主KDC，或者主KDC有磁盘崩溃，可能会发生这种情况。</p>
<p>假设您已将所有KDC配置为能够用作主KDC或从KDC（如本文档所推荐）），则您需要做的是进行更换：</p>
<p>如果主KDC仍在运行，请在<em>旧主</em> KDC 上执行以下操作：</p>
<ol>
<li>杀死kadmind进程。</li>
<li>禁用传播数据库的cron作业。</li>
<li>手动运行数据库传播脚本，以确保从站全部拥有数据库的最新副本（请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#kprop-to-slaves">将数据库传播到每个从站KDC</a>）。</li>
</ol>
<p>在<em>新</em>主人KDC上：</p>
<ol>
<li>启动<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>守护程序（请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#start-kdc-daemons">在主KDC上启动Kerberos守护程序</a>）。</li>
<li>设置cron作业以传播数据库（请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#kprop-to-slaves">将数据库传播到每个从属KDC</a>）。</li>
<li>切换旧的和新的主KDC的CNAME。如果不能这样做，您需要在Kerberos领域的每台客户端机器上更改<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>文件。</li>
</ol>
<h4 id="1-1-1-10-增量数据库传播"><a href="#1-1-1-10-增量数据库传播" class="headerlink" title="1.1.1.10 增量数据库传播"></a>1.1.1.10 增量数据库传播</h4><p>如果您希望Kerberos数据库变大，您可能希望将增量传播设置为从属KDC。有关 详细信息，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#incr-db-prop">增量数据库传播</a>。</p>
<h3 id="1-1-2-安装和配置UNIX客户机"><a href="#1-1-2-安装和配置UNIX客户机" class="headerlink" title="1.1.2 安装和配置UNIX客户机"></a>1.1.2 安装和配置UNIX客户机</h3><p>Kerberized客户端程序包括<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/kinit.html#kinit-1">kinit</a>， <a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/klist.html#klist-1">klist</a>，<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/kdestroy.html#kdestroy-1">kdestroy</a>和<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/kpasswd.html#kpasswd-1">kpasswd</a>。所有这些程序都在目录<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">BINDIR中</a>。</p>
<p>您通常可以通过使用PAM将Kerberos与登录系统集成在客户端计算机上。细节因操作系统而异，应在操作系统文档中介绍。如果这样做，您需要确保您的用户知道在登录时使用其Kerberos密码。</p>
<p>您还需要教育您的用户使用票证管理程序kinit，klist和kdestroy。如果您没有将Kerberos密码更改集成到本机密码程序中（通常通过PAM），您将需要教育用户使用kpasswd代替其非Kerberos对等体passwd。</p>
<h4 id="1-1-2-1客户机配置文件"><a href="#1-1-2-1客户机配置文件" class="headerlink" title="1.1.2.1客户机配置文件"></a>1.1.2.1客户机配置文件</h4><p>运行Kerberos的每台机器都应该有一个<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>文件。至少应在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#libdefaults">libdefaults</a> 中定义<strong>default_realm</strong>设置 。如果您没有使用DNS SRV记录（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#kdc-hostnames">KDC的主机名</a>）或URI记录（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html#kdc-discovery">KDC Discovery</a>），它还必须包含一个<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#realms">域</a> 部分，其中包含您所在领域的KDC的信息。</p>
<p>考虑将<strong>rdns</strong>设置为false，以减少对服务主机名的正确DNS信息的依赖。关闭此标志表示通过转发名称解析（将您的域名添加到不合格的主机名，并在DNS中解析CNAME记录），服务主机名将被规范化，但不能通过反向地址查找。只有历史原因，此标志的默认值为true。</p>
<p>如果您期望用户经常使用可转发凭证登录到远程主机（例如，使用ssh），请考虑将可<strong>转发</strong>设置 为true，以便用户默认获得可转发的故障单。否则用户将需要使用<code>kinit -f</code>来获得可前往的票证。</p>
<p>考虑调整<strong>ticket_lifetime</strong>设置以匹配用户可能的会话长度。例如，如果您的大多数用户将登录八小时工作日，则可以将默认值设置为十小时，以便在早晨获得的票据在工作日结束后不久即将到期。用户仍然可以在必要时手动请求更长的票据，最多允许每个用户在KDC上的主体记录允许的最大值。</p>
<p>如果客户机主机可以访问不同领域的服务，定义<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#domain-realm">domain_realm</a>映射可能是有用的，以便客户端知道哪些主机属于哪个领域。但是，如果您的客户端和KDC正在运行1.7或更高版本，那么在客户端机器上保留此部分，只需将其定义在KDC的krb5.conf中即可。</p>
<h3 id="1-1-3-UNIX应用服务器"><a href="#1-1-3-UNIX应用服务器" class="headerlink" title="1.1.3 UNIX应用服务器"></a>1.1.3 UNIX应用服务器</h3><p>应用服务器是通过网络提供一个或多个服务的主机。应用服务器可以是“安全的”或“不安全的”。安全的主机被设置为要求从连接到它的每个客户端进行认证。“不安全”的主机仍将提供Kerberos身份验证，但也允许未经身份验证的客户端进行连接。</p>
<p>如果您在所有客户机上安装了Kerberos V5，MIT建议您使主机安全，以利用Kerberos身份验证提供的安全性。但是，如果某些客户端没有安装Kerberos V5，则可以运行不安全的服务器，并且还可以利用Kerberos V5的单点登录功能。</p>
<h4 id="1-1-3-1-keytab文件"><a href="#1-1-3-1-keytab文件" class="headerlink" title="1.1.3.1 keytab文件"></a>1.1.3.1 keytab文件</h4><p>所有Kerberos服务器计算机都需要一个keytab文件才能向KDC进行身份验证。默认情况下，在类UNIX系统上，此文件名为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">DEFKTNAME</a>。keytab文件是主机密钥的本地副本。keytab文件是入侵的潜在入口点，如果被破坏，将允许不受限制地访问其主机。keytab文件只能由root读取，只能存在于本机的本地磁盘上。该文件不应该是机器的任何备份的一部分，除非访问备份数据与访问机器的root密码一样紧密。</p>
<p>为了生成主机的密钥表，主机必须在Kerberos数据库中具有一个主体。在主机的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#add-mod-del-princs">添加，修改和删除</a>过程中，对主机数据库的添加过程进行了详细描述。（请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/install_kdc.html#slave-host-key">为从属KDC创建主机</a>密钥表进行简要说明。）keytab是通过运行<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmin_local.html#kadmin-1">kadmin</a>并发出<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmin_local.html#ktadd">ktadd</a> 命令生成的。</p>
<p>例如，要生成一个密钥表文件，以允许主机 <code>trillium.mit.edu</code>为服务主机，FTP，和流行，管理员认证<code>joeadmin</code>会发出命令（在 <code>trillium.mit.edu</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trillium% kadmin</span><br><span class="line">kadmin5: ktadd host/trillium.mit.edu ftp/trillium.mit.edu</span><br><span class="line">    pop/trillium.mit.edu</span><br><span class="line">kadmin: Entry for principal host/trillium.mit.edu@ATHENA.MIT.EDU with</span><br><span class="line">    kvno 3, encryption type DES-CBC-CRC added to keytab</span><br><span class="line">    FILE:/etc/krb5.keytab.</span><br><span class="line">kadmin: Entry for principal ftp/trillium.mit.edu@ATHENA.MIT.EDU with</span><br><span class="line">    kvno 3, encryption type DES-CBC-CRC added to keytab</span><br><span class="line">    FILE:/etc/krb5.keytab.</span><br><span class="line">kadmin: Entry for principal pop/trillium.mit.edu@ATHENA.MIT.EDU with</span><br><span class="line">    kvno 3, encryption type DES-CBC-CRC added to keytab</span><br><span class="line">    FILE:/etc/krb5.keytab.</span><br><span class="line">kadmin5: quit</span><br><span class="line">trillium%</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-2关于安全主机的一些建议"><a href="#1-1-3-2关于安全主机的一些建议" class="headerlink" title="1.1.3.2关于安全主机的一些建议"></a>1.1.3.2关于安全主机的一些建议</h4><p>Kerberos V5可以保护您的主机免受某些类型的入侵攻击，但是可以安装Kerberos V5，并且仍然使您的主机容易受到攻击。显然，安装指南不是试图为每一次可能的攻击列出一个详尽的反措施清单，但值得注意的是一些较大的漏洞和如何关闭它们。</p>
<p>我们建议安全机器的备份排除keytab文件（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">DEFKTNAME</a>）。如果不可能，备份应至少在本地完成，而不是通过网络完成，并且备份磁带应该是物理上安全的。</p>
<p>keytab文件和由root运行的任何程序（包括Kerberos V5二进制文件）应保存在本地磁盘上。keytab文件只能由root读取。</p>
<h2 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h2><p>Kerberos使用配置文件来允许管理员在每个机器的基础上指定设置。 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>适用于使用Kerboros库的所有应用程序，在客户端和服务器上。对于KDC特定应用程序，可以在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf中</a>指定其他设置 ; 这两个文件被合并到直接访问KDC数据库的应用程序使用的配置文件。 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kadm5_acl.html#kadm5-acl-5">kadm5.acl</a> 也仅用于KDC，它控制修改KDC数据库的权限。</p>
<h3 id="1-2-1-krb5-conf"><a href="#1-2-1-krb5-conf" class="headerlink" title="1.2.1 krb5.conf"></a>1.2.1 krb5.conf</h3><p>krb5.conf文件包含Kerberos配置信息，包括感兴趣的Kerberos领域的KDC和管理服务器的位置，默认为当前领域和Kerberos应用程序，并将主机名映射到Kerberos领域。通常，您应该将krb5.conf文件安装在<code>/ etc</code>目录中 。您可以通过设置环境变量<strong>KRB5_CONFIG</strong>覆盖默认位置。可以在<strong>KRB5_CONFIG中</strong>指定多个冒号分隔的文件名; 所有存在的文件将被读取。从版本1.14开始，目录名也可以在<strong>KRB5_CONFIG中</strong>指定; 名称中仅包含字母数字字符，破折号或下划线的目录中的所有文件将被读取。</p>
<h4 id="1-2-1-1-结构"><a href="#1-2-1-1-结构" class="headerlink" title="1.2.1.1 结构"></a>1.2.1.1 结构</h4><p>krb5.conf文件以Windows INI文件的样式设置。部分由节名称以方括号表示。每个部分可能包含零个或多个关系，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo = bar</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fubar = &#123;</span><br><span class="line">    foo = bar</span><br><span class="line">    baz = quux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一行的末尾放置“*”表示这是 标签的<em>最终</em>值。这意味着，此配置文件的其余部分和任何其他配置文件都不会检查此标签的任何其他值。</p>
<p>例如，如果你有以下几行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo = bar*</span><br><span class="line">foo = baz</span><br></pre></td></tr></table></figure>

<p>那么<code>foo</code>（<code>baz</code>）的第二个值将永远不会被读取。</p>
<p>krb5.conf文件可以包括在一行开头使用以下指令之一的其他文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include FILENAME</span><br><span class="line">includedir DIRNAME</span><br></pre></td></tr></table></figure>

<p><em>FILENAME</em>或<em>DIRNAME</em>应该是绝对路径。命名的文件或目录必须存在并且可读。包括一个目录包括目录中的所有文件，其名称仅由字母数字字符，破折号或下划线组成。从版本1.15开始，名称以“.conf”结尾的文件也包括在内，除非名称以“.”开头。包含的配置文件在语法上独立于其父级，因此每个包含的文件必须以段头开头。</p>
<p>krb5.conf文件可以指定从可加载模块而不是文件本身获取配置，使用以下指令在任何段头之前的行开头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module MODULEPATH:RESIDUAL</span><br></pre></td></tr></table></figure>

<p><em>MODULEPATH</em>可能相对于krb5安装的库路径，也可能是绝对路径。 在初始化时间<em>内向</em>模块提供<em>RESIDUAL</em>。如果krb5.conf使用模块指令，那么<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf</a>也应该使用一个。</p>
<h4 id="1-2-1-2部分"><a href="#1-2-1-2部分" class="headerlink" title="1.2.1.2部分"></a>1.2.1.2部分</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#libdefaults">libdefaults</a></td>
<td>Kerberos V5库使用的设置</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#realms">realms</a></td>
<td>领域特定的联系信息和设置</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#domain-realm">domain_realm</a></td>
<td>将服务器主机名映射到Kerberos领域</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#capaths">capaths</a></td>
<td>非层次交叉领域的认证路径</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#appdefaults">appdefaults</a></td>
<td>某些Kerberos V5应用程序使用的设置</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#plugins">plugins</a></td>
<td>控制插件模块注册</td>
</tr>
</tbody></table>
<p>另外，krb5.conf可能包含 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf</a> 中描述的任何关系 ，但不是推荐的做法。</p>
<h5 id="libdefaults"><a href="#libdefaults" class="headerlink" title="[libdefaults]"></a>[libdefaults]</h5><p>libdefaults部分可能包含以下任何关系：</p>
<ul>
<li><strong>allow_weak_crypto</strong></li>
</ul>
<p>如果这个标志被设置为false，那么弱加密类型（如指出的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#encryption-types">加密类型</a>在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf中</a>）将被过滤掉的名单<strong>default_tgs_enctypes</strong>， <strong>default_tkt_enctypes</strong>和<strong>permitted_enctypes</strong>。此标记的默认值为false，这可能会导致现有Kerberos基础结构中的身份验证失败，该基础架构不支持强密码。受影响环境中的用户应将此标记设置为true，直到其基础架构采用更强的密码。</p>
<ul>
<li><strong>ap_req_checksum_type</strong></li>
</ul>
<p>一个整数，用于指定在认证者中使用的AP-REQ校验和的类型。该变量应该被取消设置，因此将使用正在使用的加密密钥的相应校验和。如果向后兼容性需要特定的校验和类型，则可以进行设置。有关可能的值及其含义，请参阅<strong>kdc_req_checksum_type</strong> 配置选项。</p>
<ul>
<li><strong>canonicalize</strong></li>
</ul>
<p>如果此标志设置为true，则向KDC发出的初始票据请求将请求客户主体名称的规范化，并且将接受不同于客户主体的答复，而不是所请求的主体将被接受。默认值为false。</p>
<ul>
<li><strong>ccache_type</strong></li>
</ul>
<p>此参数确定由<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/kinit.html#kinit-1">kinit</a>或其他程序创建的凭据高速缓存类型的格式。默认值为4，表示最新的格式。可以使用较小的值与与同一主机上的凭据缓存交互的非常旧的Kerberos实现的兼容性。</p>
<ul>
<li><strong>clockskew</strong></li>
</ul>
<p>在假设Kerberos消息无效之前，设置库允许的最大允许数量的clockskew（以秒为单位）。默认值为300秒，或五分钟。</p>
<p>在评估票的开始和到期时间时，也会使用clockskew设置。例如，如果持续时间比<strong>clockskew</strong>设置更短，那么仍然可以使用到达其到期时间的票证（如果是可更新的票证，则更新）。</p>
<ul>
<li><strong>default_ccache_name</strong></li>
</ul>
<p>此关系指定默认凭据缓存的名称。默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">DEFCCNAME</a>。此关系需要参数扩展（见下文）。新版本1.11。</p>
<ul>
<li><strong>default_client_keytab_name</strong></li>
</ul>
<p>此关系指定用于获取客户端凭据的默认密钥表的名称。默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">DEFCKTNAME</a>。此关系需要参数扩展（见下文）。新版本1.11。</p>
<ul>
<li><strong>default_keytab_name</strong></li>
</ul>
<p>此关系指定了应用程序服务器（如sshd）使用的默认密钥表名称。默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">DEFKTNAME</a>。此关系需要参数扩展（见下文）。</p>
<ul>
<li><strong>default_realm</strong></li>
</ul>
<p>标识客户端的默认Kerberos领域。将其值设置为您的Kerberos领域。如果未设置此值，则在调用诸如<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_commands/kinit.html#kinit-1">kinit的</a>程序时，必须为每个Kerberos主体指定一个域。</p>
<ul>
<li><strong>default_tgs_enctypes</strong></li>
</ul>
<p>标识在制作TGS-REQ时客户端应该请求的会话密钥加密类型的支持列表，按照从最高到最低的优先顺序。列表可以用逗号或空格分隔。见<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#encryption-types">加密类型</a>在 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf中</a>对这个标签接收到的值的列表。默认值为<code>aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96 aes128-cts-hmac-sha256-128 aes256-cts-hmac-sha384-192 des3-cbc-sha1 arcfour-hmac-md5 山茶花256 -cts-cmac camellia128 -cts-cmac des-cbc-crc des-cbc-md5 des-cbc-md4</code>，但是单DES加密类型将从该列表中隐式删除，如果 <strong>allow_weak_crypto</strong>为false。</p>
<p>除非具体的向后兼容性目的要求，否则不要设置此; 这种设置的陈旧值可以防止客户端在升级库时利用新的更强的enctypes。</p>
<ul>
<li><strong>default_tkt_enctypes</strong></li>
</ul>
<p>标识在制作AS-REQ时客户端应该请求的会话密钥加密类型的支持列表，按照从最高到最低的优先顺序。格式与default_tgs_enctypes相同。该标签的默认值为 <code>aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96aes128-cts-hmac-sha256-128 aes256-cts-hmac-sha384-192 des3-cbc-sha1 arcfour- hmac-md5 camellia256-cts-cmac camellia128 -cts-cmac des-cbc-crc des-cbc-md5 des-cbc-md4</code>，但是如果<strong>allow_weak_crypto的</strong>值为false ，则单DES加密类型将从该列表中隐式删除。</p>
<p>除非具体的向后兼容性目的要求，否则不要设置此; 这种设置的陈旧值可以防止客户端在升级库时利用新的更强的enctypes。</p>
<ul>
<li><strong>dns_canonicalize_hostname</strong></li>
</ul>
<p>指示名称查找是否用于规范化用于服务主体名称的主机名。将此标志设置为false可以通过减少对DNS的依赖来提高安全性，但这意味着短名称不会被规范化为完全限定的主机名。默认值为true。</p>
<ul>
<li><strong>dns_lookup_kdc</strong></li>
</ul>
<p>指示是否应该使用DNS SRV记录来定位KDCs和其他服务器的领域，如果它们没有列在领域的krb5.conf信息中。（请注意，为了与kadmind联系，请注意，admin_server条目必须在krb5.conf域中，因为kadmin的DNS实现不完整。）</p>
<p>启用此选项会打开一种拒绝服务攻击，如果有人欺骗DNS记录并将您重定向到另一个服务器。然而，这并不比拒绝服务更糟糕，因为这个假的KDC将无法解码您发送的任何东西（除了没有加密数据的初始票据请求之外），假的KDC发送的任何东西都不会在没有验证的情况下被信任使用一些秘密，它不会知道。</p>
<ul>
<li><strong>dns_uri_lookup</strong></li>
</ul>
<p>指示是否应该使用DNS URI记录来定位KDCs和其他服务器的领域，如果它们没有列在领域的krb5.conf信息中。如果没有找到URI记录，SRV记录将用作回退。默认值为true。新版本1.15。</p>
<ul>
<li><strong>err_fmt</strong></li>
</ul>
<p>此关系允许自定义错误消息格式化。如果设置了一个值，错误消息将通过将％M的正常错误消息和％C的错误代码替换为格式。</p>
<ul>
<li><strong>extra_addresses</strong></li>
</ul>
<p>这允许计算机使用多个本地地址，以便允许Kerberos在使用NAT的网络中工作，同时仍然使用受地址限制的故障单。地址应以逗号分隔的列表。如果<strong>noaddresses</strong>为true，则此选项不起作用 。</p>
<ul>
<li><strong>forwardable</strong></li>
</ul>
<p>如果这个标志是真的，如果KDC允许，默认情况下，初始票可以转发。默认值为false。</p>
<ul>
<li><strong>ignore_acceptor_hostname</strong></li>
</ul>
<p>当接受基于主机的服务主体的GSSAPI或krb5安全上下文时，忽略调用应用程序传递的任何主机名，并允许客户端对与服务名称和领域名称（如果给定）匹配的密钥表中的任何服务主体进行身份验证。此选项可以提高多宿主主机上的服务器应用程序的管理灵活性，但可能危及虚拟主机环境的安全性。默认值为false。1.10版新功能</p>
<ul>
<li><strong>k5login_authoritative</strong></li>
</ul>
<p>如果此标志为真，则如果 存在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/user/user_config/k5login.html#k5login-5">.k5login</a>文件，则主体必须列在本地用户的k5login文件中才能被授予登录访问权限。如果此标志为假，即使存在k5login文件但未列出主体，仍可通过其他机制授予委托人登录访问权限。默认值为true。</p>
<ul>
<li><strong>k5login_directory</strong></li>
</ul>
<p>如果设置，库将在命名目录中查找本地用户的k5login文件，文件名与本地用户名对应。如果未设置，库将在用户的主目录中查找k5login文件，文件名为.k5login。出于安全原因，.k5login文件必须由本地用户或root拥有。</p>
<ul>
<li><strong>kcm_mach_service</strong></li>
</ul>
<p>仅在OS X上，确定KCM凭据高速缓存类型用于联系KCM守护程序的引导服务的名称。如果值为<code>-</code>，则不会使用Mach RPC与KCM守护程序联系。默认值为<code>org.h5l.kcm</code>。</p>
<ul>
<li><strong>kcm_socket</strong></li>
</ul>
<p>确定用于访问KCM守护程序的KCM凭据缓存类型的Unix域套接字的路径。如果值为 <code>-</code>，则Unix域套接字将不会用于联系KCM守护程序。默认值为 <code>/var/run/.heim_org.h5l.kcm-socket</code>。</p>
<ul>
<li><strong>kdc_default_options</strong></li>
</ul>
<p>请求初始票证的默认KDC选项（为多个值计数）。默认设置为0x00000010（KDC_OPT_RENEWABLE_OK）。</p>
<ul>
<li><strong>kdc_timesync</strong></li>
</ul>
<p>该关系的接受值为1或0.如果不为零，客户端计算机将计算它们的时间与KDC在票证中的时间戳中返回的时间之间的差异，并在请求时使用此值来校正不准确的系统时钟服务票或认证服务。此修正因子仅由Kerberos库使用; 它不用于更改系统时钟。默认值为1。</p>
<ul>
<li><strong>kdc_req_checksum_type</strong></li>
</ul>
<p>一个整数，用于指定用于KDC请求的校验和的类型，以便与很旧的KDC实现兼容。此值仅用于DES密钥; 其他键使用这些键的首选校验和类型。</p>
<p>可能的值及其含义如下。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CRC32</td>
</tr>
<tr>
<td>2</td>
<td>RSA MD4</td>
</tr>
<tr>
<td>3</td>
<td>RSA MD4 DES</td>
</tr>
<tr>
<td>4</td>
<td>DES CBC</td>
</tr>
<tr>
<td>7</td>
<td>RSA MD5</td>
</tr>
<tr>
<td>8</td>
<td>RSA MD5 DES</td>
</tr>
<tr>
<td>9</td>
<td>NIST SHA</td>
</tr>
<tr>
<td>12</td>
<td>HMAC SHA1 DES3</td>
</tr>
<tr>
<td>-138</td>
<td>Microsoft MD5 HMAC校验和类型</td>
</tr>
</tbody></table>
<ul>
<li><strong>noaddresses</strong></li>
</ul>
<p>如果此标志为真，则不会对设置的地址限制进行初始票证的请求，从而允许在NAT之间使用票证。默认值为true。</p>
<ul>
<li><strong>permitted_enctypes</strong></li>
</ul>
<p>标识允许在会话密钥加密中使用的所有加密类型。该标签的默认值为 <code>aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96 aes128-cts-hmac-sha256-128 aes256-cts-hmac-sha384-192 des3-cbc-sha1 arcfour- hmac-md5 camellia256-cts-cmac camellia128 -cts-cmac des-cbc-crc des-cbc-md5 des-cbc-md4</code>，但是如果<strong>allow_weak_crypto的</strong>值为false ，则单DES加密类型将从该列表中隐式删除。</p>
<ul>
<li><strong>plugin_base_dir</strong></li>
</ul>
<p>如果设置，则确定krb5插件所在的基本目录。默认值是krb5库目录的<code>krb5 / plugins</code>子目录。</p>
<ul>
<li><strong>preferred_preauth_types</strong></li>
</ul>
<p>这允许您设置客户端将尝试的首选预认证类型，其他可能由KDC发布的其他类型。此设置的默认值为“17,16,15,14”，这将强制libkrb5尝试使用PKINIT（如果支持）。</p>
<ul>
<li><strong>proxiable</strong></li>
</ul>
<p>如果这个标志是真的，如果KDC允许，默认情况下初始门票将可以启用。默认值为false。</p>
<ul>
<li><strong>rdns</strong></li>
</ul>
<p>如果这个标志是真的，除了前向名称查找之外，还将使用反向名称查找来规范化用于服务主体名称的主机名。如果<strong>dns_canonicalize_hostname</strong>设置为false，则此标志无效。默认值为true。</p>
<ul>
<li><strong>realm_try_domains</strong></li>
</ul>
<p>指示主机的域组件是否应用于确定主机的Kerberos领域。此变量的值为整数：-1表示不搜索，0表示尝试主机的域本身，1表示也尝试域的直接父项等等。库用于定位Kerberos领域的通常机制用于确定域是否是有效领域，如果设置了<strong>dns_lookup_kdc</strong>，则可能涉及到DNS的咨询。默认情况下不是搜索域组件。</p>
<ul>
<li><strong>renew_lifetime</strong></li>
</ul>
<p>（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/date_format.html#duration">持续时间</a>字符串）设置初始票据请求的默认可更新生命周期。默认值为0。</p>
<ul>
<li><strong>safe_checksum_type</strong></li>
</ul>
<p>一个整数，指定用于KRB-SAFE请求的校验和的类型。默认设置为8（RSA MD5 DES）。为了与与DCE 1.1或更早版本的Kerberos库链接的应用程序兼容，请使用3的值来使用RSA MD4 DES。当该值与会话密钥类型不兼容时，该字段将被忽略。有关 可能的值及其含义，请参阅<strong>kdc_req_checksum_type</strong>配置选项。</p>
<ul>
<li><strong>ticket_lifetime</strong></li>
</ul>
<p>（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/date_format.html#duration">持续时间</a>字符串）设置初始票据请求的默认生命周期。默认值为1天。</p>
<ul>
<li><strong>udp_preference_limit</strong></li>
</ul>
<p>当向KDC发送消息时，如果消息的大小高于<strong>udp_preference_limit</strong>，则库将尝试在UDP之前使用TCP 。如果消息小于 <strong>udp_preference_limit</strong>，则UDP将在TCP之前尝试。无论大小如何，如果第一次尝试失败，将尝试两个协议。</p>
<ul>
<li><strong>verify_ap_req_nofail</strong></li>
</ul>
<p>如果此标志为真，则如果客户端计算机没有密钥表，则尝试验证初始凭据将失败。默认值为false。</p>
<ul>
<li>​</li>
</ul>
<h5 id="realms"><a href="#realms" class="headerlink" title="[realms]"></a>[realms]</h5><p>文件的[realms]部分中的每个标签都是Kerberos领域的名称。标签的值是具有定义该特定领域的属性的关系的子部分。对于每个领域，可以在领域的子部分中指定以下标签：</p>
<ul>
<li><strong>admin_server</strong></li>
</ul>
<p>标识管理服务器正在运行的主机。通常，这是主Kerberos服务器。为了与 领域的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>服务器进行通信，必须为此标签赋予一个值。</p>
<ul>
<li><strong>auth_to_local</strong></li>
</ul>
<p>此标签允许您设置将主体名称映射到本地用户名的一般规则。如果正在翻译的主体名称没有显式映射，则将使用它。可能的值是：</p>
<p>​    <strong>RULE</strong>:<em>exp</em></p>
<p>​    本地名称将从制定<em>EXP</em>。</p>
<p>​    对于格式<em>EXP</em>是*[ <em><strong>Ñ <em><strong>：</strong></em>字符串</strong></em>（<em><strong>正则表达式</strong></em>）S / <em><strong>图案</strong></em>/ <em><strong>更换</strong></em>/克<strong>。整数<em>n</em>表示目标主体应具有多少个组件。如果此匹配，则一个字符串将被从形成<em>的字符串</em>，替换主要为境界<code>$ 0</code>和<em>Ñ</em> “日本金的成分 <code>$ N</code>（例如，如果主要是<code>输入johndoe /管理员</code>然后 <code>[2：$ 2 $ 1foo ]</code>将导致字符串 <code>adminjohndoefoo</code>）。如果此字符串与<em>regexp</em>匹配</strong>，那么<code>s // [g]</code>替换命令将在字符串上运行。可选<strong>克</strong>将导致取代是全球性的过<em>串</em>，而不是在只更换第一匹配<em>串</em>。</p>
<p>​    <strong>DEFAULT</strong></p>
<p>​    主体名称将用作本地用户名。如果主体具有多个组件或不在默认领域，则此规则不适用，转换将失败。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[realms]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        auth_to_local = RULE:[2:$1](johndoe)s/^.*$/guest/</span><br><span class="line">        auth_to_local = RULE:[2:$1;$2](^.*;admin$)s/;admin$//</span><br><span class="line">        auth_to_local = RULE:[2:$2](^.*;root)s/^.*$/root/</span><br><span class="line">        auto_to_local = DEFAULT</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将导致任何没有<code>root</code>或<code>admin的</code>主体作为使用默认规则进行翻译的第二个组件。<code>管理员</code>的第二个组成部分的主体将成为其第一个组成部分。 <code>root</code>将被用作具有<code>root</code>的第二个组件的任何主体的本地名称。这两个规则的例外是任何主体<code>johndoe / *</code>，它将始终获取本地名称<code>guest</code>。</p>
<ul>
<li><strong>auth_to_local_names</strong></li>
</ul>
<p>本小节允许您将主体名称的显式映射设置为本地用户名。标签是映射名称，值是相应的本地用户名。</p>
<ul>
<li><strong>default_domain</strong></li>
</ul>
<p>此标记指定在将Kerberos 4服务主体转换为Kerberos 5主体时（例如，将<code>rcmd.hostname</code>转换为 <code>host / hostname.domain</code>）时，用于扩展主机名的域。</p>
<ul>
<li><strong>http_anchors</strong></li>
</ul>
<p>当通过HTTPS代理访问KDC和kpasswd服务器时，可以使用此标记来指定应信任的CA证书的位置，以发出代理服务器的证书。如果未指定，则使用系统级默认的CA证书集。</p>
<p>值的语法与<strong>pkinit_anchors</strong>标记的值相似 ：</p>
<p>​    <strong>FILE:</strong> <em>filename</em></p>
<p>​    <em>filename</em>被认为是OpenSSL风格的ca-bundle文件的名称。</p>
<p>​    <strong>DIR:</strong> <em>dirname</em></p>
<p>​    <em>dirname</em>被假定为包含CA证书的目录。目录中的所有文件将被检查; 如果它们包含证书（以PEM格式），则将被使用。</p>
<p>​    <strong>ENV:</strong> <em>envvar</em></p>
<p>​    <em>envvar</em>指定已设置为符合先前值之一的值的环境变量的名称。例如， <code>ENV：X509_PROXY_CA</code>，其中环境变量<code>X509_PROXY_CA</code>已设置为<code>FILE：/tmp/my_proxy.pem</code>。</p>
<ul>
<li><strong>kdc</strong></li>
</ul>
<p>为该领域运行KDC的主机的名称或地址。可以包括与冒号的主机名分隔的可选端口号。如果名称或地址包含冒号（例如，如果是IPv6地址），请将其括在方括号中以区分冒号和端口分隔符。为使您的计算机能够与每个领域的KDC进行通信，必须在配置文件中的每个领域中给予该标签一个值，或者必须有指定KDC的DNS SRV记录。</p>
<ul>
<li><strong>kpasswd_server</strong></li>
</ul>
<p>指向执行所有密码更改的服务器。如果没有这样的条目，<strong>admin_server</strong> 主机上的端口464 将被尝试。</p>
<ul>
<li><strong>master_kdc</strong></li>
</ul>
<p>标识主KDC（s）。目前，仅在一种情况下使用此标签：如果由于密码无效而尝试获取凭证失败，则客户端软件将尝试联系主KDC，以防用户密码刚刚更改，更新的数据库具有尚未传播到从属服务器。</p>
<ul>
<li><strong>v4_instance_convert</strong></li>
</ul>
<p>此小节允许管理员配置<strong>default_domain</strong>映射规则的例外。它包含V4实例（标签名称），它应该转换为某个特定主机名（标记值）作为Kerberos V5主体名称中的第二个组件。</p>
<ul>
<li><strong>v4_realm</strong></li>
</ul>
<p>当将V5主体名称转换为V4主体名称时，此关系由krb524库例程使用。当V4域名和V5域名不相同时使用，但仍然共享相同的主体名称和密码。标记值是Kerberos V4领域名称。</p>
<h5 id="domain-realm"><a href="#domain-realm" class="headerlink" title="[domain_realm]"></a>[domain_realm]</h5><p>[domain_realm]部分提供从域名或主机名到Kerberos领域名称的翻译。标签名称可以是主机名或域名，其中域名由句点（<code>.</code>）的前缀指示。该关系的值是该特定主机或域的Kerberos域名。主机名关系隐含地提供相应的域名关系，除非提供了明确的域名关系。可以在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#realms">领域</a>部分或使用DNS SRV记录来标识Kerberos领域。主机名和域名应小写。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[domain_realm]</span><br><span class="line">    crash.mit.edu = TEST.ATHENA.MIT.EDU</span><br><span class="line">    .dev.mit.edu = TEST.ATHENA.MIT.EDU</span><br><span class="line">    mit.edu = ATHENA.MIT.EDU</span><br></pre></td></tr></table></figure>

<p>将名称为<code>crash.mit.edu</code>的主机映射到 <code>TEST.ATHENA.MIT.EDU</code>领域。第二个条目将域<code>dev.mit.edu</code>下的所有主机映射到<code>TEST.ATHENA.MIT.EDU</code>域中，而不是名为<code>dev.mit.edu</code>的主机。主机由第三项，它映射主机匹配<code>mit.edu</code>和域下的所有主机<code>mit.edu</code>不前的规则匹配到的境界<code>ATHENA.MIT.EDU</code>。</p>
<p>如果没有翻译条目适用于用于服务票证请求的服务主体的主机名，库将尝试从客户端领域的KDC获得适当领域的引用。如果这不成功，主机的领域被认为是转换为大写的主机名的域部分，除非[libdefaults]中的<strong>realm_try_domains</strong>设置导致使用不同的父域。</p>
<h5 id="capaths"><a href="#capaths" class="headerlink" title="[capaths]"></a>[capaths]</h5><p>为了执行直接（非分层）交叉领域认证，需要进行配置来确定领域之间的认证路径。</p>
<p>客户端将使用此部分来查找其领域和服务器领域之间的认证路径。服务器将使用此部分来验证客户端使用的身份验证路径，方法是检查接收到的故障单的转接字段。</p>
<p>每个参与的客户端都有一个标签，每个标签都有每个服务器领域的子标签。子标签的值是可以参与跨域认证的中间域。如果存在多于一个中间领域，则可能会重复子标签。值“。”表示两个领域直接共享密钥，不允许中间域参与。</p>
<p>只有客户端或服务器上需要的那些条目才需要存在。一个客户端需要一个标签为其本地领域与子标签所有的服务器领域将需要验证。服务器领域的子标签需要一个服务器的每个领域的标签。</p>
<p>例如，<code>ANL.GOV</code>，<code>PNL.GOV</code>和<code>NERSC.GOV</code>都希望使用<code>ES.NET</code>领域作为中间领域。ANL具有<code>TEST.ANL.GOV</code>的子<code>域</code>，它将使用<code>NERSC.GOV进行</code>认证， 但不会<code>PNL.GOV</code>。<code>ANL.GOV</code>系统的[capaths]部分将如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capaths]</span><br><span class="line">    ANL.GOV = &#123;</span><br><span class="line">        TEST.ANL.GOV = .</span><br><span class="line">        PNL.GOV = ES.NET</span><br><span class="line">        NERSC.GOV = ES.NET</span><br><span class="line">        ES.NET = .</span><br><span class="line">    &#125;</span><br><span class="line">    TEST.ANL.GOV = &#123;</span><br><span class="line">        ANL.GOV = .</span><br><span class="line">    &#125;</span><br><span class="line">    PNL.GOV = &#123;</span><br><span class="line">        ANL.GOV = ES.NET</span><br><span class="line">    &#125;</span><br><span class="line">    NERSC.GOV = &#123;</span><br><span class="line">        ANL.GOV = ES.NET</span><br><span class="line">    &#125;</span><br><span class="line">    ES.NET = &#123;</span><br><span class="line">        ANL.GOV = .</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>NERSC.GOV</code> 系统上使用的配置文件的[capaths]部分将如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capaths]</span><br><span class="line">    NERSC.GOV = &#123;</span><br><span class="line">        ANL.GOV = ES.NET</span><br><span class="line">        TEST.ANL.GOV = ES.NET</span><br><span class="line">        TEST.ANL.GOV = ANL.GOV</span><br><span class="line">        PNL.GOV = ES.NET</span><br><span class="line">        ES.NET = .</span><br><span class="line">    &#125;</span><br><span class="line">    ANL.GOV = &#123;</span><br><span class="line">        NERSC.GOV = ES.NET</span><br><span class="line">    &#125;</span><br><span class="line">    PNL.GOV = &#123;</span><br><span class="line">        NERSC.GOV = ES.NET</span><br><span class="line">    &#125;</span><br><span class="line">    ES.NET = &#123;</span><br><span class="line">        NERSC.GOV = .</span><br><span class="line">    &#125;</span><br><span class="line">    TEST.ANL.GOV = &#123;</span><br><span class="line">        NERSC.GOV = ANL.GOV</span><br><span class="line">        NERSC.GOV = ES.NET</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当标记中使用子标签多于一次时，客户端将使用值的顺序来确定路径。值的顺序对于服务器来说并不重要。</p>
<h5 id="appdefaults"><a href="#appdefaults" class="headerlink" title="[appdefaults]"></a>[appdefaults]</h5><p>[appdefaults]部分中的每个标签命名一个Kerberos V5应用程序或某些Kerberos V5应用程序使用的选项。标签的值定义了该应用程序的默认行为。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[appdefaults]</span><br><span class="line">    telnet = &#123;</span><br><span class="line">        ATHENA.MIT.EDU = &#123;</span><br><span class="line">            option1 = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    telnet = &#123;</span><br><span class="line">        option1 = true</span><br><span class="line">        option2 = true</span><br><span class="line">    &#125;</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        option2 = false</span><br><span class="line">    &#125;</span><br><span class="line">    option2 = true</span><br></pre></td></tr></table></figure>

<p>指定选项值的上述四种方式按优先级递减的顺序显示。在这个例子中，如果telnet在领域EXAMPLE.COM中运行，默认情况下应该将option1和option2设置为true。然而，<code>ATHENA.MIT.EDU</code>领域的telnet程序 应该将<code>option1</code>设置为false，将 <code>option2</code>设置为true。默认情况下，ATHENA.MIT.EDU中的任何其他程序应该将<code>option2</code>设置为false。任何在其他领域运行的程序都应该将<code>option2</code>设置为true。</p>
<p>每个应用程序的可指定选项的列表可以在该应用程序的手册页中找到。此处指定的应用程序默认值将由<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#realms">领域</a>部分中指定的应用程序覆盖。</p>
<h5 id="plugins"><a href="#plugins" class="headerlink" title="[plugins]"></a>[plugins]</h5><ul>
<li><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#pwqual">pwqual</a> interface</li>
<li><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#kadm5-hook">kadm5_hook</a> interface</li>
<li><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#clpreauth">clpreauth</a> and <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#kdcpreauth">kdcpreauth</a> interfaces</li>
</ul>
<h4 id="1-2-1-3-参数扩展"><a href="#1-2-1-3-参数扩展" class="headerlink" title="1.2.1.3 参数扩展"></a>1.2.1.3 参数扩展</h4><p>从版本1.11开始，几个变量（如 <strong>default_keytab_name</strong>）允许扩展参数。有效参数有：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>%{TEMP}</td>
<td>临时目录</td>
</tr>
<tr>
<td>%{uid}</td>
<td>Unix真正的UID或Windows SID</td>
</tr>
<tr>
<td>%{euid}</td>
<td>Unix有效的用户ID或Windows SID</td>
</tr>
<tr>
<td>%{USERID}</td>
<td>与％{uid}相同</td>
</tr>
<tr>
<td>%{null}</td>
<td>空字符串</td>
</tr>
<tr>
<td>%{LIBDIR}</td>
<td>安装库目录</td>
</tr>
<tr>
<td>%{BINDIR}</td>
<td>安装二进制目录</td>
</tr>
<tr>
<td>%{SBINDIR}</td>
<td>安装admin二进制目录</td>
</tr>
<tr>
<td>%{username}</td>
<td>（Unix）有效用户名的用户名</td>
</tr>
<tr>
<td>%{APPDATA}</td>
<td>（Windows）当前用户的漫游应用程序数据</td>
</tr>
<tr>
<td>%{COMMON_APPDATA}</td>
<td>（Windows）所有用户的应用程序数据</td>
</tr>
<tr>
<td>%{LOCAL_APPDATA}</td>
<td>（Windows）当前用户的本地应用程序数据</td>
</tr>
<tr>
<td>%{SYSTEM}</td>
<td>（Windows）Windows系统文件夹</td>
</tr>
<tr>
<td>%{WINDOWS}</td>
<td>（Windows）Windows系统文件夹</td>
</tr>
<tr>
<td>%{USERCONFIG}</td>
<td>（Windows）Windows系统文件夹</td>
</tr>
<tr>
<td>%{COMMONCONFIG}</td>
<td>（Windows）常用MIT krb5配置文件目录</td>
</tr>
</tbody></table>
<h4 id="1-2-1-4-示例krb5-conf文件"><a href="#1-2-1-4-示例krb5-conf文件" class="headerlink" title="1.2.1.4 示例krb5.conf文件"></a>1.2.1.4 示例krb5.conf文件</h4><p>以下是通用krb5.conf文件的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[libdefaults]</span><br><span class="line">    default_realm = ATHENA.MIT.EDU</span><br><span class="line">    dns_lookup_kdc = true</span><br><span class="line">    dns_lookup_realm = false</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        kdc = kerberos.mit.edu</span><br><span class="line">        kdc = kerberos-1.mit.edu</span><br><span class="line">        kdc = kerberos-2.mit.edu</span><br><span class="line">        admin_server = kerberos.mit.edu</span><br><span class="line">        master_kdc = kerberos.mit.edu</span><br><span class="line">    &#125;</span><br><span class="line">    EXAMPLE.COM = &#123;</span><br><span class="line">        kdc = kerberos.example.com</span><br><span class="line">        kdc = kerberos-1.example.com</span><br><span class="line">        admin_server = kerberos.example.com</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">[domain_realm]</span><br><span class="line">    mit.edu = ATHENA.MIT.EDU</span><br><span class="line"></span><br><span class="line">[capaths]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">           EXAMPLE.COM = .</span><br><span class="line">    &#125;</span><br><span class="line">    EXAMPLE.COM = &#123;</span><br><span class="line">           ATHENA.MIT.EDU = .</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-kdc-conf"><a href="#1-2-2-kdc-conf" class="headerlink" title="1.2.2 kdc.conf"></a>1.2.2 kdc.conf</h3><p>kdc.conf文件补充了通常仅在KDC上使用的程序的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>，例如<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>和 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>守护程序以及<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kdb5_util.html#kdb5-util-8">kdb5_util</a>程序。这里记录的关系也可以在krb5.conf中指定; 对于所提到的KDC程序，krb5.conf和kdc.conf将被合并到单个配置文件中。</p>
<p>通常，kdc.conf文件位于KDC状态目录 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR </a>* <code>/ krb5kdc中</code>。您可以通过设置环境变量<strong>KRB5_KDC_PROFILE</strong>来覆盖默认位置。</p>
<p>请注意，您需要重新启动KDC守护程序，以使任何配置更改生效。</p>
<h4 id="1-2-2-1-结构"><a href="#1-2-2-1-结构" class="headerlink" title="1.2.2.1 结构"></a>1.2.2.1 结构</h4><p>kdc.conf文件的设置格式与<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>文件相同 。</p>
<h4 id="1-2-2-2-部分"><a href="#1-2-2-2-部分" class="headerlink" title="1.2.2.2 部分"></a>1.2.2.2 部分</h4><p>kdc.conf文件可能包含以下部分：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdcdefaults">kdcdefaults</a></td>
<td>KDC行为的默认值</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-realms">realms</a></td>
<td>领域特定的数据库配置和设置</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#dbdefaults">dbdefaults</a></td>
<td>默认数据库设置</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#dbmodules">dbmodules</a></td>
<td>每数据库设置</td>
</tr>
<tr>
<td><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#logging">logging</a></td>
<td>控制Kerberos守护程序执行日志记录的方式</td>
</tr>
</tbody></table>
<h5 id="kdcdefaults"><a href="#kdcdefaults" class="headerlink" title="[kdcdefaults]"></a>[kdcdefaults]</h5><p>除了两个例外，[kdcdefaults]部分中的关系指定了领域变量的默认值，如果[realms]部分不包含标签的关系，则使用它们。有关这些关系的定义，请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-realms">领域</a> 部分。</p>
<ul>
<li><strong>host_based_services</strong></li>
<li><strong>kdc_listen</strong></li>
<li><strong>kdc_ports</strong></li>
<li><strong>kdc_tcp_listen</strong></li>
<li><strong>kdc_tcp_ports</strong></li>
<li><strong>no_host_referral</strong></li>
<li><strong>restrict_anonymous_to_tgt</strong></li>
</ul>
<ul>
<li><strong>kdc_max_dgram_reply_size</strong></li>
</ul>
<p>指定可以通过UDP发送的最大数据包大小。默认值为4096字节。</p>
<ul>
<li><strong>kdc_tcp_listen_backlog</strong></li>
</ul>
<p>（整数）设置KDC守护程序的侦听队列长度的大小。该值可能受到OS设置的限制。默认值为5。</p>
<h5 id="realms-1"><a href="#realms-1" class="headerlink" title="[realms]"></a>[realms]</h5><p>[realms]部分中的每个标签都是Kerberos领域的名称。标签的值是关系为该特定领域定义KDC参数的子部分。以下示例显示如何为ATHENA.MIT.EDU领域定义一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[realms]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        max_renewable_life = 7d 0h 0m 0s</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以下标签可能在[域}部分中指定：</p>
<ul>
<li><strong>acl_file</strong></li>
</ul>
<p>（String。）<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>用于确定允许哪些主体在Kerberos数据库中有哪些权限的访问控制列表文件的位置 。默认值为 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR </a>* <code>/krb5kdc/kadm5.acl</code>。有关Kerberos ACL文件的更多信息，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kadm5_acl.html#kadm5-acl-5">kadm5.acl</a>。</p>
<ul>
<li><strong>database_module</strong></li>
</ul>
<p>（String。）此关系指示可加载数据库使用的数据库特定参数的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#dbmodules">dbmodules</a>下的配置部分的名称。默认值是域名。如果此配置部分不存在，则将为所有数据库参数使用默认值。</p>
<ul>
<li><strong>database_name</strong></li>
</ul>
<p>（String，deprecated。）此关系指定了该领域的Kerberos数据库的位置，如果正在使用DB2模块，并且<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#dbmodules">dbmodules</a>配置部分未指定数据库名称。默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR </a>* <code>/krb5kdc/principal</code>。</p>
<ul>
<li><strong>default_principal_expiration</strong></li>
</ul>
<p>（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/date_format.html#abstime">绝对时间</a>字符串。）指定在此领域中创建的主体的默认有效期。默认值为0，表示没有到期日。</p>
<ul>
<li><strong>default_principal_flags</strong></li>
</ul>
<p>（标志字符串。）指定在此领域中创建的主体的默认属性。该字符串的格式是逗号分隔的标志列表，在应该被禁用的每个标志之前的每个标志之前使用’+’和’ - ‘。该<strong>postdateable</strong>，<strong>forwardable</strong>，<strong>tgt-based</strong>， <strong>renewable</strong>，<strong>proxiable</strong>，<strong>dup-skey</strong>，<strong>allow-tickets</strong>，和 <strong>service</strong> 标志默认为启用。</p>
<p>有几个可能的标志：</p>
<p>​    <strong>allow-tickets</strong></p>
<p>​    启用此标志表示KDC将颁发此委托人的门票。禁用此标志基本上禁用此领域内的主体。</p>
<p>​    <strong>dup-skey</strong></p>
<p>​    启用此标志允许主体获取另一个用户的会话密钥，允许该主体的用户到用户身份验证。</p>
<p>​    <strong>forwardable</strong></p>
<p>​    启用此标志允许校长获得可转发的门票。</p>
<p>​    <strong>hwauth</strong></p>
<p>​    如果启用此标志，则在接收任何票据之前，必须使用硬件设备对主体进行预认证。</p>
<p>​    <strong>no-auth-data-required</strong></p>
<p>​    启用此标志可防止将PAC或AD-SIGNEDPATH数据添加到主体的服务单。</p>
<p>​    <strong>ok-as-delegate</strong></p>
<p>​    如果此标志已启用，则会提示客户端在对服务进行身份验证时可以委任凭据。</p>
<p>​    <strong>ok-to-auth-as-delegate</strong></p>
<p>​    启用此标志允许校长使用S4USelf门票。</p>
<p>​    <strong>postdateable</strong></p>
<p>​    启用此标志允许校长获得可更新的门票。</p>
<p>​    <strong>preauth</strong></p>
<p>​    如果在客户机主体上启用了此标志，那么在接收任何票据之前，需要该主体对KDC进行预认证。在服务主体上，启用此标志意味着此主体的服务票据将仅发送给具有预验证位的TGT的客户端。</p>
<p>​    <strong>proxiable</strong></p>
<p>​    启用此标志允许主体获取代理机票。</p>
<p>​    <strong>pwchange</strong></p>
<p>​    启用此标志将强制更改此主体的密码。</p>
<p>​    <strong>pwservice</strong></p>
<p>​    如果启用此标志，则将该主体标记为密码更改服务。这只能在特殊情况下使用，例如，如果用户的密码已经过期，则用户必须通过正常密码认证才能获得该主体的票据，以便能够更改密码。</p>
<p>​    <strong>renewable</strong></p>
<p>​    启用此标志允许校长获得可更新的门票。</p>
<p>​    <strong>service</strong></p>
<p>​    启用此标志允许KDC颁发此主体的服务票证。</p>
<p>​    <strong>tgt-based</strong></p>
<p>​    启用此标志允许主体基于票证授予票而获取票据，而不是重复用于获取TGT的身份验证过程。</p>
<ul>
<li><strong>dict_file</strong></li>
</ul>
<p>（String。）包含不允许作为密码的字符串的字典文件的位置。该文件应该每行包含一个字符串，而不需要额外的空格。如果没有指定或者没有分配给主体的策略，则不会执行字典检查密码。</p>
<ul>
<li><strong>host_based_services</strong></li>
</ul>
<p>（空格或逗号分隔的列表。）列出即使服务器主体未被客户端标记为主机的服务，这些服务将获得基于主机的引用处理。</p>
<ul>
<li><strong>iprop_enable</strong></li>
</ul>
<p>（布尔值。）指定是否启用增量数据库传播。默认值为false。</p>
<ul>
<li><strong>iprop_master_ulogsize</strong></li>
</ul>
<p>（整数）指定要为增量传播保留的最大日志条目数。默认值为1000.在版本1.11之前，最大值为2500。</p>
<ul>
<li><strong>iprop_slave_poll</strong></li>
</ul>
<p>（Delta时间字符串。）指定从机KDC轮询主机的新更新的频率。默认值为<code>2m</code>（即两分钟）。</p>
<ul>
<li><strong>iprop_listen</strong></li>
</ul>
<p>（Whitespace-或逗号分隔的列表。）指定iprop RPC监听地址和/或端口的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind的</a>守护进程。每个条目可能是一个接口地址，一个端口号，或一个以冒号分隔的地址和端口号。如果地址包含冒号，请将其括在方括号中。如果没有指定地址，则使用通配符地址。如果kadmind无法绑定到任何指定的地址，它将无法启动。默认值（当<strong>iprop_enable</strong>为true时）将绑定到<strong>iprop_port中</strong>指定的端口上的通配符地址。新版本1.15。</p>
<ul>
<li><strong>iprop_port</strong></li>
</ul>
<p>（端口号。）指定用于增量传播的端口号。当<strong>iprop_enable</strong>为true时，从配置文件需要此关系，主配置文件中需要此关系或<strong>iprop_listen</strong>，因为没有默认端口号。<strong>iprop_listen</strong>条目中指定的端口号将覆盖<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>守护程序的此端口号。</p>
<ul>
<li><strong>iprop_resync_timeout</strong></li>
</ul>
<p>（Delta时间字符串。）指定等待完整传播完成的时间量。这在配置文件中是可选的，仅由从属KDC使用。默认值为5分钟（<code>5米</code>）。新版本1.11。</p>
<ul>
<li><strong>iprop_logfile</strong></li>
</ul>
<p>（文件名。）指定要存储领域数据库的更新日志文件的位置。默认是使用 <strong>数据库名称</strong>从KRB5配置文件的realms部分的条目，以<code>.ulog</code>追加。（注意：如果在“领域”部分中未指定<strong>database_name</strong>，可能是因为正在使用LDAP数据库后端，或者在[dbmodules]部分中指定了文件名，则会使用<strong>database_name</strong>的硬编码默认值 。的<strong>iprop_logfile</strong> 默认值不会使用[dbmodules]部分的值。）</p>
<ul>
<li><strong>kadmind_listen</strong></li>
</ul>
<p>（空格或逗号分隔的列表。）指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>守护程序的kadmin RPC侦听地址和/或端口。每个条目可能是一个接口地址，一个端口号，或一个以冒号分隔的地址和端口号。如果地址包含冒号，请将其括在方括号中。如果没有指定地址，则使用通配符地址。如果kadmind无法绑定到任何指定的地址，它将无法启动。默认值是绑定到<strong>kadmind_port</strong>或标准kadmin端口（749）中指定的端口上的通配符地址。新版本1.15。</p>
<ul>
<li><strong>kadmind_port</strong></li>
</ul>
<p>（端口号。）指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a> 守护程序侦听此域的端口。在<strong>kadmind_listen</strong>条目中指定的端口号 将覆盖此端口号。kadmind的分配端口是749，默认情况下使用。</p>
<ul>
<li><strong>key_stash_file</strong></li>
</ul>
<p>（String。）指定存储主密钥的位置（通过kdb5_util隐藏）。默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR</a><code>/ krb5kdc/.k5.REALM</code>，其中<em>REALM</em>是Kerberos <em>域</em>。</p>
<ul>
<li><strong>kdc_listen</strong></li>
</ul>
<p>（空格或逗号分隔的列表。）指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>守护程序的UDP侦听地址和/或端口。每个条目可能是一个接口地址，一个端口号，或一个以冒号分隔的地址和端口号。如果地址包含冒号，请将其括在方括号中。如果没有指定地址，则使用通配符地址。如果没有指定端口，则使用标准端口（88）。如果KDC守护程序无法绑定到任何指定的地址，将无法启动。默认是绑定到标准端口上的通配符地址。新版本1.15。</p>
<ul>
<li><strong>kdc_ports</strong></li>
</ul>
<p>（不推荐使用空格或逗号分隔的列表）。在释放1.15之前，此关系列出了<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>守护程序侦听UDP请求的端口 。在版本1.15及更高版本中， 如果没有定义该关系，它与<strong>kdc_listen</strong>具有相同的含义。</p>
<ul>
<li><strong>kdc_tcp_listen</strong></li>
</ul>
<p>（空格或逗号分隔的列表。）指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>守护程序的TCP侦听地址和/或端口。每个条目可能是一个接口地址，一个端口号，或一个以冒号分隔的地址和端口号。如果地址包含冒号，请将其括在方括号中。如果没有指定地址，则使用通配符地址。如果没有指定端口，则使用标准端口（88）。要禁用TCP侦听，请使用<code>kdc_tcp_listen = “”</code>将此关系设置为空字符串。如果KDC守护程序无法绑定到任何指定的地址，将无法启动。默认是绑定到标准端口上的通配符地址。新版本1.15。</p>
<ul>
<li><strong>kdc_tcp_ports</strong></li>
</ul>
<p>（不推荐使用空格或逗号分隔的列表）。在释放1.15之前，此关系列出了<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>守护程序侦听UDP请求的端口 。在版本1.15及更高版本中，如果没有定义该关系，则与<strong>kdc_tcp_listen</strong>具有相同的含义。</p>
<ul>
<li><strong>kpasswd_listen</strong></li>
</ul>
<p>（逗号分隔列表。）指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>守护程序的kpasswd侦听地址和/或端口。每个条目可能是一个接口地址，一个端口号，或一个以冒号分隔的地址和端口号。如果地址包含冒号，请将其括在方括号中。如果没有指定地址，则使用通配符地址。如果kadmind无法绑定到任何指定的地址，它将无法启动。默认值是绑定到<strong>kpasswd_port中</strong>指定的端口或标准kpasswd端口（464）上的通配符地址。新版本1.15。</p>
<ul>
<li><strong>kpasswd_port</strong></li>
</ul>
<p>（端口号。）指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a> 守护程序侦听此域的密码更改请求的端口。在<strong>kpasswd_listen</strong>条目中指定的端口号将覆盖此端口号。密码更改请求的分配端口为464，默认使用。</p>
<ul>
<li><strong>master_key_name</strong></li>
</ul>
<p>（String。）指定与主键相关联的主体的名称。默认值是<code>K/M</code>。</p>
<ul>
<li><strong>master_key_type</strong></li>
</ul>
<p>（键类型字符串）指定主键的键类型。其默认值为<code>aes256-cts-hmac-sha1-96</code>。有关所有可能值的列表，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#encryption-types">加密类型</a>。</p>
<ul>
<li><strong>max_life</strong></li>
</ul>
<p>（<a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/date_format.html#duration">持续时间</a>字符串）指定票证在该领域中有效的最长时间段。默认值为24小时。</p>
<ul>
<li><strong>max_renewable_life</strong></li>
</ul>
<p><a href="http://web.mit.edu/kerberos/krb5-latest/doc/basic/date_format.html#duration">持续时间</a>字符串）指定在此领域可以更新有效票证的最长时间段。默认值为0。</p>
<ul>
<li><strong>no_host_referral</strong></li>
</ul>
<p>（布尔值）。如果设置为true，则KDC将假定服务主体支持des-cbc-crc以进行会话密钥协商。如果<strong>allow_weak_crypto</strong>在<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#libdefaults">libdefaults</a>是假的，或者如果DES-CBC-CRC没有被允许的加密类型，则该变量没有效果。默认为true。新版本1.11。</p>
<ul>
<li><strong>reject_bad_transit</strong></li>
</ul>
<p>（布尔值）如果设置为true，KDC将根据从其<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html#krb5-conf-5">krb5.conf</a>文件的领域名称和capaths部分计算的传输路径，检查跨领域门票的转换范围 列表; 如果要颁发的票证中的路径包含不在计算路径中的任何领域，则不会发出票证，并将错误返回给客户端。如果这个值设置为false，那么这样的票据将会被发出，并且将被留给应用服务器来验证领域的传输路径。</p>
<p>如果在传入请求中设置了禁用转移检查标志，则完全不执行此检查。使用 <strong>reject_bad_transit</strong>选项将导致这样的票据请求总是被拒绝。</p>
<p>此传输路径检查和配置文件选项目前仅适用于TGS请求。</p>
<p>默认值为true。</p>
<ul>
<li><strong>restrict_anonymous_to_tgt</strong></li>
</ul>
<p>（布尔值）如果设置为true，则KDC将拒绝来自匿名主体的票单请求，而不是领域的票证授予服务。此选项允许启用匿名PKINIT以用作FAST装甲门票，而不允许对服务进行匿名身份验证。默认值为false。新版本1.9。</p>
<ul>
<li><strong>supported_enctypes</strong></li>
</ul>
<p>（<em>键</em>列表：<em>salt</em> strings。）指定此领域的主体的默认键/盐组合。通过<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmin_local.html#kadmin-1">kadmin</a>创建的任何主体将具有这些类型的键。该标签的默认值为<code>aes256-cts-hmac-sha1-96：normal aes128-cts-hmac-sha1-96：normal des3-cbc-sha1：normal arcfour-hmac-md5：normal</code>。有关可能值的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#keysalt-lists">列表</a>，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#keysalt-lists">Keysalt列表</a>。</p>
<h5 id="dbdefaults"><a href="#dbdefaults" class="headerlink" title="[dbdefaults]"></a>[dbdefaults]</h5><p>[dbdefaults]部分指定某些数据库参数的默认值，如果[dbmodules]子部分不包含该标记的关系，则使用该值。有关这些关系的定义，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#dbmodules">dbmodules</a>部分。</p>
<ul>
<li><strong>ldap_kerberos_container_dn</strong></li>
<li><strong>ldap_kdc_dn</strong></li>
<li><strong>ldap_kdc_sasl_authcid</strong></li>
<li><strong>ldap_kdc_sasl_authzid</strong></li>
<li><strong>ldap_kdc_sasl_mech</strong></li>
<li><strong>ldap_kdc_sasl_realm</strong></li>
<li><strong>ldap_kadmind_dn</strong></li>
<li><strong>ldap_kadmind_sasl_authcid</strong></li>
<li><strong>ldap_kadmind_sasl_authzid</strong></li>
<li><strong>ldap_kadmind_sasl_mech</strong></li>
<li><strong>ldap_kadmind_sasl_realm</strong></li>
<li><strong>ldap_service_password_file</strong></li>
<li><strong>ldap_servers</strong></li>
<li><strong>ldap_conns_per_server</strong></li>
</ul>
<h5 id="dbmodules"><a href="#dbmodules" class="headerlink" title="[dbmodules]"></a>[dbmodules]</h5><p>[dbmodules]部分包含KDC数据库和数据库模块使用的参数。[dbmodules]部分中的每个标签都是由领域的<strong>database_module</strong>参数指定的Kerberos领域或部分名称 。以下示例显示如何为ATHENA.MIT.EDU领域定义一个数据库参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dbmodules]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        disable_last_success = true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以在[dbmodules]子部分中指定以下标签：</p>
<ul>
<li><strong>database_name</strong></li>
</ul>
<p>此DB2特定标记指示数据库在文件系统中的位置。默认值为<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR </a>* <code>/krb5kdc/principal</code>。</p>
<ul>
<li><strong>db_library</strong></li>
</ul>
<p>此标记指示可加载数据库模块的名称。该值应为DB2模块的<code>db2</code>和LDAP模块的<code>kldap</code>值。</p>
<ul>
<li><strong>disable_last_success</strong></li>
</ul>
<p>如果设置为<code>true</code>，则将KDC更新抑制为需要进行身份验证的主要条目的“上次成功身份验证”字段。设置此标志可能会提高性能。（不需要预认证的主要条目从不更新“上一次成功认证”字段）。在1.9版中首先介绍。</p>
<ul>
<li><strong>disable_lockout</strong></li>
</ul>
<p>如果设置为<code>true</code>，请将KDC更新抑制为需要进行身份验证的主体条目的“最终验证失败”和“失败密码尝试”字段。设置此标志可能会提高性能，但也会禁用帐户锁定。在1.9版中首先介绍。</p>
<ul>
<li><strong>ldap_conns_per_server</strong></li>
</ul>
<p>此LDAP特定标记指示要为每个LDAP服务器维护的连接数。</p>
<ul>
<li><strong>ldap_kdc_dn</strong> and <strong>ldap_kadmind_dn</strong></li>
</ul>
<p>这些特定于LDAP的标签表示绑定到LDAP服务器的默认DN。该<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>守护进程使用<strong>ldap_kdc_dn</strong>，而<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind的</a>守护程序和其他行政程序使用<strong>ldap_kadmind_dn</strong>。kadmind DN必须具有读取和写入LDAP数据库中的Kerberos数据的权限。除非<strong>disable_lockout</strong>和<strong>disable_last_success</strong>为true ，否则KDC DN必须具有相同的权限， 在这种情况下，它只需要具有读取Kerberos数据的权限。如果使用<strong>ldap_kdc_sasl_mech</strong>或<strong>ldap_kadmind_sasl_mech</strong>设置SASL机制，则忽略这些标记 。</p>
<ul>
<li><strong>ldap_kdc_sasl_mech</strong> and <strong>ldap_kadmind_sasl_mech</strong></li>
</ul>
<p>这些特定于LDAP的标签指定在绑定到LDAP服务器时要使用的SASL机制（例如 <code>EXTERNAL</code>）。新版本1.13。</p>
<ul>
<li><strong>ldap_kdc_sasl_authcid</strong> and <strong>ldap_kadmind_sasl_authcid</strong></li>
</ul>
<p>这些特定于LDAP的标签指定绑定到LDAP服务器时要使用的SASL身份验证身份。并不是所有的SASL机制都需要身份认证。如果SASL机制需要秘密（例如<code>DIGEST-MD5</code>的密码），这些标签还会确定<strong>ldap_service_password_file</strong>中隐藏密码的名称 。新版本1.13。</p>
<ul>
<li><strong>ldap_kdc_sasl_authzid</strong> and <strong>ldap_kadmind_sasl_authzid</strong></li>
</ul>
<p>这些特定于LDAP的标签指定绑定到LDAP服务器时要使用的SASL授权标识。在大多数情况下，它们不需要指定。新版本1.13。</p>
<ul>
<li><strong>ldap_kdc_sasl_realm</strong> and <strong>ldap_kadmind_sasl_realm</strong></li>
</ul>
<p>这些特定于LDAP的标签指定绑定到LDAP服务器时要使用的SASL领域。在大多数情况下，他们不需要设置。新版本1.13。</p>
<ul>
<li><strong>ldap_kerberos_container_dn</strong></li>
</ul>
<p>此LDAP特定标记表示领域对象将位于的容器对象的DN。</p>
<ul>
<li><strong>ldap_servers</strong></li>
</ul>
<p>此LDAP特定标记指示Kerberos服务器可以连接到的LDAP服务器的列表。LDAP服务器的列表是空格分隔的。LDAP服务器由LDAP URI指定。建议使用<code>ldapi：</code>或<code>ldaps：</code> URL连接到LDAP服务器。</p>
<ul>
<li><strong>ldap_service_password_file</strong></li>
</ul>
<p>此LDAP特定标记指示包含<strong>ldap_kdc_dn</strong>和<strong>ldap_kadmind_dn</strong>对象的密码（由<code>kdb5_ldap_utilstashsrvpw</code>创建） 或SASL身份验证的 <strong>ldap_kdc_sasl_authcid</strong>或<strong>ldap_kadmind_sasl_authcid</strong>名称的文件。该文件必须保持安全。</p>
<ul>
<li><strong>unlockiter</strong></li>
</ul>
<p>如果设置为<code>true</code>，则此DB2特定标记会导致迭代操作在处理每个主体时释放数据库锁。将此标志设置为<code>true</code>可以防止在大型数据库转储过程中KDC或kadmin操作的扩展阻塞。首先介绍1.13版本。</p>
<p>可以在[dbmodules]部分中直接指定以下标签，以控制从哪个数据库模块加载：</p>
<ul>
<li><strong>db_module_dir</strong></li>
</ul>
<p>该标签控制插件系统查找数据库模块的位置。该值应该是绝对路径。</p>
<h5 id="logging"><a href="#logging" class="headerlink" title="[logging]"></a>[logging]</h5><p>[logging]部分指示<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>和 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>如何执行日志记录。它可能包含以下关系：</p>
<ul>
<li><strong>admin_server</strong></li>
</ul>
<p>指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>如何执行日志记录。</p>
<ul>
<li><strong>kdc</strong></li>
</ul>
<p>指定<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>如何执行日志记录。</p>
<ul>
<li><strong>default</strong></li>
</ul>
<p>指定守护进程如何在没有特定于守护进程的关系的情况下执行日志记录。</p>
<ul>
<li><strong>debug</strong></li>
</ul>
<p>（布尔值。）指定调试消息是否包含在SYSLOG以外的日志输出中。调试消息始终包含在系统日志输出中，因为syslog执行自己的优先级过滤。默认值为false。新版本1.15。</p>
<p>测井规格可能有以下形式：</p>
<ul>
<li>**FILE=**<em>filename</em> or **FILE:**<em>filename</em></li>
</ul>
<p>此值将导致守护程序的日志消息转到 <em>文件名</em>。如果使用<code>=</code>表单，文件将被覆盖。如果使用<code>：</code>表单，该文件将附加到。</p>
<ul>
<li><strong>STDERR</strong></li>
</ul>
<p>此值会导致守护程序的日志消息进入其标准错误流。</p>
<ul>
<li><strong>CONSOLE</strong></li>
</ul>
<p>此值会导致守护程序的日志消息进入控制台，如果系统支持该消息。</p>
<ul>
<li><strong>DEVICE=&lt;devicename&gt;</strong></li>
</ul>
<p>这将导致守护程序的日志消息进入指定的设备。</p>
<ul>
<li>**SYSLOG[:*severity[:<em>facility]</em>]</li>
</ul>
<p>这将导致守护程序的日志消息进入系统日志。</p>
<p>severity参数指定系统日志消息的默认严重性。这可能是syslog（3）调用支持的以下任何严重性，减去<code>LOG_</code>前缀：<strong>EMERG</strong>， <strong>ALERT</strong>，<strong>CRIT</strong>，<strong>ERR</strong>，<strong>WARNING</strong>，<strong>NOTICE</strong>，<strong>INFO</strong>和<strong>DEBUG</strong>。</p>
<p>facility参数指定记录消息的工具。这可能是syslog（3）调用减去LOG_前缀支持的以下任何设备：<strong>KERN</strong>， <strong>USER</strong>，<strong>MAIL</strong>，<strong>DAEMON</strong>，<strong>AUTH</strong>，<strong>LPR</strong>，<strong>NEWS</strong>， <strong>UUCP</strong>，<strong>CRON</strong>和<strong>LOCAL0</strong>到<strong>LOCAL7</strong>。</p>
<p>如果没有指定严重性，默认值为<strong>ERR</strong>。如果没有指定工具，默认值为<strong>AUTH</strong>。</p>
<p>在以下示例中，来自KDC的日志消息将转到控制台和设备LOG_DAEMON下的系统日志，默认严重性为LOG_INFO; 并且来自管理服务器的记录消息将附加到文件 <code>/var/adm/kadmin.log</code>并发送到设备<code>/dev/tty04</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[logging]</span><br><span class="line">    kdc = CONSOLE</span><br><span class="line">    kdc = SYSLOG:INFO:DAEMON</span><br><span class="line">    admin_server = FILE:/var/adm/kadmin.log</span><br><span class="line">    admin_server = DEVICE=/dev/tty04</span><br></pre></td></tr></table></figure>

<h5 id="otp"><a href="#otp" class="headerlink" title="[otp]"></a>[otp]</h5><p>[otp]的每个小节是OTP令牌类型的名称。小节内的标签定义了将一次性密码请求转发到RADIUS服务器所需的配置。</p>
<p>对于每个令牌类型，可以指定以下标签：</p>
<ul>
<li><strong>server</strong></li>
</ul>
<p>这是发送RADIUS请求的服务器。它可以是可选端口的主机名，可选端口的IP地址或Unix域套接字地址。默认值为 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR</a><code>/ krb5kdc/&lt;name&gt;.socket</code>。</p>
<ul>
<li><strong>secret</strong></li>
</ul>
<p>此标记表示包含用于加密RADIUS数据包的秘密的文件名（可能与<a href="http://web.mit.edu/kerberos/krb5-latest/doc/mitK5defaults.html#paths">LOCALSTATEDIR</a><code>/ krb5kdc有关</code>）。秘密应该自己出现在文件的第一行; 线上的前导和尾随空格将被删除。如果<strong>服务器的</strong>值为Unix域套接字地址，则此标记是可选的，如果未指定，则将使用空的秘密。否则，此标记是必需的。</p>
<ul>
<li><strong>timeout</strong></li>
</ul>
<p>一个整数，指定KDC应尝试联系RADIUS服务器的时间（以秒为单位）。此标记是所有重试的总时间，应小于OTP值保持有效的时间。默认值为5秒。</p>
<ul>
<li><strong>retries</strong></li>
</ul>
<p>此标签指定要对RADIUS服务器进行重试次数。默认是3次重试（4次尝试）。</p>
<ul>
<li><strong>strip_realm</strong></li>
</ul>
<p>如果此标记为<code>true</code>，则没有领域的主体将被传递到RADIUS服务器。否则，将包括这个领域。默认值为<code>true</code>。</p>
<ul>
<li><strong>indicator</strong></li>
</ul>
<p>如果使用该标记类型进行身份验证，则此标签指定要包含在故障单中的认证指示符。此选项可以多次指定。（新版本1.14。）</p>
<p>在以下示例中，请求通过UDP发送到远程服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[otp]</span><br><span class="line">    MyRemoteTokenType = &#123;</span><br><span class="line">        server = radius.mydomain.com:1812</span><br><span class="line">        secret = SEmfiajf42$</span><br><span class="line">        timeout = 15</span><br><span class="line">        retries = 5</span><br><span class="line">        strip_realm = true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>默认</code>值为<code>DEFAULT的</code>默认令牌类型是为每个主配置未指定令牌类型而定义的。其配置如下所示。您可以将此令牌类型覆盖适用于您的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[otp]</span><br><span class="line">    DEFAULT = &#123;</span><br><span class="line">        strip_realm = false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-3加密类型"><a href="#1-2-2-3加密类型" class="headerlink" title="1.2.2.3加密类型"></a>1.2.2.3加密类型</h4><p>需要加密类型列表的配置文件中的任何标签都可以设置为以下字符串的某种组合。标记为“弱”的加密类型可用于兼容性，但不推荐使用。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>des-cbc-crc</td>
<td>DES cbc模式与CRC-32（弱）</td>
</tr>
<tr>
<td>des-cbc-md4</td>
<td>DES cbc模式与RSA-MD4（弱）</td>
</tr>
<tr>
<td>des-cbc-md5</td>
<td>DES cbc模式与RSA-MD5（弱）</td>
</tr>
<tr>
<td>des-cbc-raw</td>
<td>DES cbc模式raw（weak）</td>
</tr>
<tr>
<td>des3-cbc-raw</td>
<td>三重DES cbc模式（弱）</td>
</tr>
<tr>
<td>des3-cbc-sha1 des3-hmac-sha1 des3-cbc-sha1-kd</td>
<td>三重DES cbc模式与HMAC / sha1</td>
</tr>
<tr>
<td>des-hmac-sha1</td>
<td>DES与HMAC / sha1（弱）</td>
</tr>
<tr>
<td>aes256-cts-hmac-sha1-96 aes256-cts aes256-sha1</td>
<td>具有96位SHA-1 HMAC的AES-256 CTS模式</td>
</tr>
<tr>
<td>aes128-cts-hmac-sha1-96 aes128-cts aes128-sha1</td>
<td>具有96位SHA-1 HMAC的AES-128 CTS模式</td>
</tr>
<tr>
<td>aes256-cts-hmac-sha384-192 aes256-sha2</td>
<td>具有192位SHA-384 HMAC的AES-256 CTS模式</td>
</tr>
<tr>
<td>aes128-cts-hmac-sha256-128 aes128-sha2</td>
<td>具有128位SHA-256 HMAC的AES-128 CTS模式</td>
</tr>
<tr>
<td>arcfour-hmac rc4-hmac arcfour-hmac-md5</td>
<td>RC4与HMAC / MD5</td>
</tr>
<tr>
<td>arcfour-hmac-exp rc4-hmac-exp arcfour-hmac-md5-exp</td>
<td>Exportable RC4 with HMAC/MD5 (weak)</td>
</tr>
<tr>
<td>camellia256-cts-cmac camellia256-cts</td>
<td>可导出的RC4与HMAC / MD5（弱）</td>
</tr>
<tr>
<td>camellia128-cts-cmac camellia128-cts</td>
<td>Camellia-128 CTS模式与CMAC</td>
</tr>
<tr>
<td>des</td>
<td>DES系列：des-cbc-crc，des-cbc-md5和des-cbc-md4（弱）</td>
</tr>
<tr>
<td>des3</td>
<td>三重DES系列：des3-cbc-sha1</td>
</tr>
<tr>
<td>aes</td>
<td>TAES系列：aes256-cts-hmac-sha1-96，aes128-cts-hmac-sha1-96，aes256-cts-hmac-sha384-192和aes128-cts-hmac-sha256-128</td>
</tr>
<tr>
<td>rc4</td>
<td>RC4系列：arcfour-hmac</td>
</tr>
<tr>
<td>camellia</td>
<td>Camellia 系列: camellia256-cts-cmac 和camellia128-cts-cmac</td>
</tr>
</tbody></table>
<p>字符串<strong>DEFAULT</strong>可用于引用所讨论变量的默认类型。可以从当前列表中删除类型或族，前缀为减号（“ - ”）。类型或家庭可以加上加号（“+”）作为对称性; 它具有与列出类型或家族相同的含义。例如，“ <code>DEFAULT-des</code> ”将是删除DES类型的默认加密类型集，“ <code>des3 DEFAULT</code> ”将是默认的三重DES类型的加密类型移动到前端。</p>
<p>虽然所有Kerberos操作都支持<strong>aes128-cts</strong>和<strong>aes256-cts</strong>，但是我们的GSSAPI实现（krb5-1.3.1及更早版本）的旧版本不支持它们。不支持AES支持的运行krb5版本的服务不得在KDC数据库中给出这些加密类型的密钥。</p>
<p>该<strong>AES128-SHA2</strong>和<strong>AES256-SHA2</strong>加密类型，脱模1.15新。不支持这些较新加密类型的krb5版本的服务不能在KDC数据库中给出这些加密类型的密钥。</p>
<h4 id="1-2-2-4-示例kdc-conf文件"><a href="#1-2-2-4-示例kdc-conf文件" class="headerlink" title="1.2.2.4 示例kdc.conf文件"></a>1.2.2.4 示例kdc.conf文件</h4><p>以下是kdc.conf文件的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kdcdefaults]</span><br><span class="line">    kdc_listen = 88</span><br><span class="line">    kdc_tcp_listen = 88</span><br><span class="line">[realms]</span><br><span class="line">    ATHENA.MIT.EDU = &#123;</span><br><span class="line">        kadmind_port = 749</span><br><span class="line">        max_life = 12h 0m 0s</span><br><span class="line">        max_renewable_life = 7d 0h 0m 0s</span><br><span class="line">        master_key_type = aes256-cts-hmac-sha1-96</span><br><span class="line">        supported_enctypes = aes256-cts-hmac-sha1-96:normal aes128-cts-hmac-sha1-96:normal</span><br><span class="line">        database_module = openldap_ldapconf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">    kdc = FILE:/usr/local/var/krb5kdc/kdc.log</span><br><span class="line">    admin_server = FILE:/usr/local/var/krb5kdc/kadmin.log</span><br><span class="line"></span><br><span class="line">[dbdefaults]</span><br><span class="line">    ldap_kerberos_container_dn = cn=krbcontainer,dc=mit,dc=edu</span><br><span class="line"></span><br><span class="line">[dbmodules]</span><br><span class="line">    openldap_ldapconf = &#123;</span><br><span class="line">        db_library = kldap</span><br><span class="line">        disable_last_success = true</span><br><span class="line">        ldap_kdc_dn = &quot;cn=krbadmin,dc=mit,dc=edu&quot;</span><br><span class="line">            # this object needs to have read rights on</span><br><span class="line">            # the realm container and principal subtrees</span><br><span class="line">        ldap_kadmind_dn = &quot;cn=krbadmin,dc=mit,dc=edu&quot;</span><br><span class="line">            # this object needs to have read and write rights on</span><br><span class="line">            # the realm container and principal subtrees</span><br><span class="line">        ldap_service_password_file = /etc/kerberos/service.keyfile</span><br><span class="line">        ldap_servers = ldaps://kerberos.mit.edu</span><br><span class="line">        ldap_conns_per_server = 5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-使用OpenLDAP后端配置Kerberos"><a href="#1-3-使用OpenLDAP后端配置Kerberos" class="headerlink" title="1.3 使用OpenLDAP后端配置Kerberos"></a>1.3 使用OpenLDAP后端配置Kerberos</h3><ol>
<li><p>在OpenLDAP服务器和客户端上设置SSL，以确保KDC服务和LDAP服务器位于不同机器上时的安全通信。 如果LDAP服务器和KDC服务在同一台机器上运行，则可以使用<code>ldapi：//</code>。</p>
<ul>
<li><p>在OpenLDAP服务器上设置SSL：</p>
<ul>
<li><p>使用OpenSSL工具获取CA证书</p>
</li>
<li><p>配置OpenLDAP服务器以使用SSL / TLS</p>
<p>对于后者，您需要在<em>slapd.conf</em>文件中指定CA证书位置的位置。</p>
<p>有关更多信息，请参阅以下链接：<a href="http://www.openldap.org/doc/admin23/tls.html">http</a> :<a href="http://www.openldap.org/doc/admin23/tls.html">//www.openldap.org/doc/admin23/tls.html</a></p>
</li>
</ul>
</li>
<li><p>在OpenLDAP客户端上设置SSL</p>
<ul>
<li>对于KDC和Admin Server，您需要在ldap.conf中进行客户端配置。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TLS_CACERT /etc/openldap/certs/cacert.pem</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过提供其存储位置，在LDAP服务器的配置文件（slapd.conf）中包含Kerberos模式文件（kerberos.schema）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /etc/openldap/schema/kerberos.schema</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>选择要将<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/krb5kdc.html#krb5kdc-8">krb5kdc</a>和<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kadmind.html#kadmind-8">kadmind</a>服务器绑定到LDAP服务器的DN ，并在必要时创建它们。这些DN将使用<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf中</a>的<strong>ldap_kdc_dn</strong>和<strong>ldap_kadmind_dn</strong> 指令进行<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">指定</a> ; 他们的密码可以用“ <code>kdb5_ldap_util stashsrvpw</code> ”和使用<strong>ldap_service_password_file</strong>指令指定的结果文件进行<strong>存储</strong>。</p>
</li>
<li><p>为全局Kerberos容器条目选择一个DN（但不要在此时创建该条目）。将使用<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf中</a>的<strong>ldap_kerberos_container_dn</strong>指令指定此DN 。将在此DN下创建领域容器条目。主体条目可能存在于领域容器（默认值）下方，也可能存在于从领域容器引用的单独树中。</p>
</li>
<li><p>配置LDAP服务器ACL以使KDC和kadmin服务器DN读取和写入Kerberos数据。如果在领域的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#dbmodules">dbmodules</a>子部分中<strong>disable_last_success</strong>和<strong>disable_lockout</strong>都设置为true ，则KDC DN仅需要对Kerberos数据的读取访问。</p>
<p>示例访问控制信息：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.base=&quot;&quot;</span><br><span class="line">    by * read</span><br><span class="line"></span><br><span class="line">access to dn.base=&quot;cn=Subschema&quot;</span><br><span class="line">    by * read</span><br><span class="line"></span><br><span class="line">access to attrs=userPassword,userPKCS12</span><br><span class="line">    by self write</span><br><span class="line">    by * auth</span><br><span class="line"></span><br><span class="line">access to attrs=shadowLastChange</span><br><span class="line">    by self write</span><br><span class="line">    by * read</span><br><span class="line"></span><br><span class="line"># 提供对领域容器的访问</span><br><span class="line">access to dn.subtree= &quot;cn=EXAMPLE.COM,cn=krbcontainer,dc=example,dc=com&quot;</span><br><span class="line">    by dn.exact=&quot;cn=kdc-service,dc=example,dc=com&quot; write</span><br><span class="line">    by dn.exact=&quot;cn=adm-service,dc=example,dc=com&quot; write</span><br><span class="line">    by * none</span><br><span class="line"></span><br><span class="line"># 提供对主体的访问，如果不在领域容器下</span><br><span class="line">access to dn.subtree= &quot;ou=users,dc=example,dc=com&quot;</span><br><span class="line">    by dn.exact=&quot;cn=kdc-service,dc=example,dc=com&quot; write</span><br><span class="line">    by dn.exact=&quot;cn=adm-service,dc=example,dc=com&quot; write</span><br><span class="line">    by * none</span><br><span class="line"></span><br><span class="line">access to *</span><br><span class="line">    by * read</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>启动LDAP服务器，如下所示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">slapd -h <span class="string">&quot;ldapi:/// ldaps:///&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>修改<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf</a>文件以包括下列LDAP特定项目：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realms</span><br><span class="line">    database_module</span><br><span class="line"></span><br><span class="line">dbmodules</span><br><span class="line">    db_library</span><br><span class="line">    db_module_dir</span><br><span class="line">    ldap_kdc_dn</span><br><span class="line">    ldap_kadmind_dn</span><br><span class="line">    ldap_service_password_file</span><br><span class="line">    ldap_servers</span><br><span class="line">    ldap_conns_per_server</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>使用<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kdb5_ldap_util.html#kdb5-ldap-util-8">kdb5_ldap_util</a>创建领域（请参阅 <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#ldap-create-realm">创建Kerberos领域</a>）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kdb5_ldap_util -D cn=admin,dc=example,dc=com create -subtrees ou=users,dc=example,dc=com -r EXAMPLE.COM -s</span><br></pre></td></tr></table></figure>

<p>如果主体将存在于与领域容器的单独子树中，则使用**-subtrees<strong>选项。在执行命令之前，请确保存在上述的子树 <code>（ou = users，dc = example，dc = com）</code>。如果主体将存在于领域容器下方，请忽略</strong>-subtrees**选项，而不用担心创建主体子树。</p>
<p>有关详细信息，请参阅<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#ops-on-ldap">LDAP数据库上的操作</a>一节。</p>
<p>在配置文件中指定的<strong>ldap_kerberos_container_dn</strong>下创建域对象 。此操作也将创建Kerberos容器，如果不存在的话。这将用于存储与所有领域相关的信息。</p>
<ol start="9">
<li>使用<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/admin_commands/kdb5_ldap_util.html#kdb5-ldap-util-8">kdb5_ldap_util</a> <strong>stashsrvpw</strong>命令将KDC和管理服务使用的<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#stash-ldap">服务对象的密码保存</a>为绑定到LDAP服务器 （请参阅“ <a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/database.html#stash-ldap">冻结服务对象的密码”</a>）。对象DN应与<a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/kdc_conf.html#kdc-conf-5">kdc.conf</a>文件中指定的<strong>ldap_kdc_dn</strong>和<strong>ldap_kadmind_dn</strong>值 相同 ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kdb5_ldap_util -D cn=admin,dc=example,dc=com stashsrvpw -f /etc/kerberos/service.keyfile cn=krbadmin,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>将<code>krbPrincipalName</code>添加到slapd.conf中的索引，以加快访问速度。</li>
</ol>
<p>使用LDAP后端可以提供主体条目的别名。目前，我们不提供用于创建别名的机制，因此必须通过直接操作LDAP条目来完成。</p>
<p>具有别名的条目包含<em>krbPrincipalName</em>属性的多个值 。由于LDAP属性值未排序，因此必须使用<em>krbCanonicalName</em>属性指定哪个主体名称是规范的。因此，要为条目创建别名，首先将该条目的<em>krbCanonicalName</em>属性设置为规范主体名称（该名称应与预先存在的<em>krbPrincipalName</em>值相同），然后为别名添加其他 <em>krbPrincipalName</em>属性。</p>
<p>当客户端请求规范化时，主体别名仅由KDC返回。通常要求服务主体规范化; 对于客户主体，通常需要显式标志（例如，<code>kinit -C</code>），并且仅对初始票据请求执行规范化。</p>
<p><strong>也可以看看</strong></p>
<p><a href="http://web.mit.edu/kerberos/krb5-latest/doc/admin/advanced/ldapbackend.html#ldap-be-ubuntu">Ubuntu 10.4上的LDAP后端（lucid）</a></p>
]]></content>
      <categories>
        <category>Documents</category>
      </categories>
      <tags>
        <tag>kerberos</tag>
      </tags>
  </entry>
  <entry>
    <title>API 设计指南</title>
    <url>/2020/08/21/api-design/api_style_guide/</url>
    <content><![CDATA[<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p>在当前微服务大环境之下，越来越多的项目使用 RESTful HTTP接口方位资源 。为了团队开发的友好体验，开发人员尽可能遵循一致的 REST API 设计原则就显得至关重要。</p>
<p>API 设计指南旨在提供一套基础规范，便于团队设计和开发出一致的 RESTful 接口。</p>
<span id="more"></span>

<h2 id="2-目录"><a href="#2-目录" class="headerlink" title="2. 目录"></a>2. 目录</h2><p>[TOC]</p>
<h2 id="3-引言"><a href="#3-引言" class="headerlink" title="3. 引言"></a>3. 引言</h2><p>在各个子系统间，开发人员基本都是通过 HTTP 接口访问。尽管服务使用不同语言开发，但最终都是 HTTP 请求。为了能开发出来的产品能够支持更广泛的客户端和服务，并且不会依赖特定开发框架或者环境，就需要在 API 上有良好的设计。这些规范的目的就是尽可能让所有 HTTP 客户端能轻松、一致地使用 REST API。</p>
<p>在吸取了社区中大量成熟的经验后，制定出了此规范。主要参考规范如下：</p>
<ul>
<li><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md">微软 REST API 规范</a></li>
<li><a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">PayPal REST API 规范</a></li>
</ul>
<h3 id="3-1-推荐阅读"><a href="#3-1-推荐阅读" class="headerlink" title="3.1 推荐阅读"></a>3.1 推荐阅读</h3><p>为了开发良好 HTTP 服务，建议理解 REST 体系结构风格的原理。如果您不熟悉 RESTful 设计，可以参考一下资源：</p>
<p><a href="http://en.wikipedia.org/wiki/Representational_state_transfer">Wikipedia 上的 REST</a> - REST 背后的常见定义和核心思想概述。</p>
<p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">REST论文</a> —— Roy Fielding 论文中有关 REST 的一章，即“架构风格和基于网络的软件架构设计” 。</p>
<p><a href="https://tools.ietf.org/html/rfc7231">RFC 7231</a> —— HTTP/1.1 规范。</p>
<p><a href="http://www.amazon.com/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829/">REST 实践</a> —— 关于 REST 基础的书籍。</p>
<h2 id="4-名词释义"><a href="#4-名词释义" class="headerlink" title="4. 名词释义"></a>4. 名词释义</h2><p>本节内容主要阐述文档中的特殊关键词的含义，界定其范围和使用场景，避免因对关键词理解偏差而造成使用不当。</p>
<h3 id="4-1-资源"><a href="#4-1-资源" class="headerlink" title="4.1 资源"></a>4.1 资源</h3><p>资源是 REST 中信息的关键抽象。根据 <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2">Fielding 的论文 5.2 节</a>，可以命名的任何信息都可以是资源，如：文档或图像，临时服务（例如“洛杉矶今天的天气”），其他资源的集合，非虚拟对象（例如一个人），等等。资源是到一组实体的概念性映射，而不是在任何特定时间点与该映射相对应的实体。更准确地说，资源 <code>R</code> 是随时间变化的隶属函数 <code>MR(t)</code> ，用于将时间 <code>t</code> 映射到等效的一组实体或值。集合中的值可以是资源表示和 <code>/</code> 或资源标识符。</p>
<p>资源也可以映射到空集，从而允许在存在任何概念之前就对该概念进行引用。</p>
<h3 id="4-2-资源标识符"><a href="#4-2-资源标识符" class="headerlink" title="4.2 资源标识符"></a>4.2 资源标识符</h3><p>REST 使用资源标识符来标识组件之间交互中涉及的特定资源实例。命名机构（例如提供 API 的组织）分配了资源标识符以使其有可能引用资源，它负责维护映射随时间的语义有效性（确保成员资格函数不变）。- <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2">菲尔丁的论文第 5.2 节</a></p>
<h3 id="4-3-域"><a href="#4-3-域" class="headerlink" title="4.3 域"></a>4.3 域</h3><p>根据 Wikipedia 定义，<a href="https://en.wikipedia.org/wiki/Domain_model">领域模型</a>是一个抽象系统，描述了知识，影响或活动领域的选定方面。这些概念包括业务中涉及的数据，以及业务针对该数据使用的规则。例如， PayPal 域模型包括诸如支付，风险，合规性，身份，客户支持等域。</p>
<h3 id="4-4-功能"><a href="#4-4-功能" class="headerlink" title="4.4 功能"></a>4.4 功能</h3><p>功能是面向业务和面向客户所组织的业务逻辑视图。功能可用于将 API 打包组合为系统的稳定的、业务驱动的视图，供客户和体验使用。功能的例子包括：合规性，信用，身份，零售和风险等。</p>
<p>功能驱动接口，而域粒度更粗，更接近代码和组织的结构。从服务的角度来看，功能和领域被视为正交的关注点。</p>
<h3 id="4-5-命名空间"><a href="#4-5-命名空间" class="headerlink" title="4.5 命名空间"></a>4.5 命名空间</h3><p>功能驱动 API 组合中的服务建模和名称空间问题。名称空间是业务功能模型的一部分。名称空间的例子有:合规性、设备、传输、信用、限制等。。</p>
<p>命名空间应反映逻辑上将一组业务功能分组的域。域定义应反映客户对平台功能组织方式的看法。请注意，这些可能不一定反映公司的层次结构，组织或（现有）代码结构。在某些情况下，从定义上可以反映目标，面向客户的平台组织模型的意义上说，领域定义是理想的。底层服务实现和组织结构可能需要迁移以反映这些边界。</p>
<h3 id="4-6-服务"><a href="#4-6-服务" class="headerlink" title="4.6 服务"></a>4.6 服务</h3><p>服务是访问和操作资源值集的通用 API ，而不管成员功能是如何定义的，也不管处理请求的软件类型是什么。服务是软件的通用部分，可以执行任意数量的功能。因此，考虑存在的不同类型的服务是有益的。</p>
<p>从逻辑上讲，我们可以将公开的服务和 API 分为两类：</p>
<ol>
<li><strong>功能 API</strong> 是实现通用，可重用业务功能的服务所公开的公共API。</li>
<li><strong>特定场景的 API</strong> 建立在功能 API 之上，并公开可能针对特定问题的功能，或针对通用功能的特定于上下文而专门优化的功能。上下文信息可能和时间，位置，设备，通道，身份，用户，角色，授权级别等有关。</li>
</ol>
<h4 id="4-6-1-基于功能的服务和-API"><a href="#4-6-1-基于功能的服务和-API" class="headerlink" title="4.6.1 基于功能的服务和 API"></a>4.6.1 基于功能的服务和 API</h4><p>功能 API 是可重用业务功能的公共接口。<em>公开</em> 指这些 API 仅限于供前端使用，外部使用者或来自不同域的内部使用者使用的接口。</p>
<h4 id="4-6-2-特定场景的服务和-API"><a href="#4-6-2-特定场景的服务和-API" class="headerlink" title="4.6.2 特定场景的服务和 API"></a>4.6.2 特定场景的服务和 API</h4><p>特定场景的服务在核心功能上提供了最少的附加业务逻辑，并且主要提供了转换和轻量编排，以根据特定场景，渠道或设备的需求量身定制交互。它们的输入/输出仅限于服务调用。</p>
<h3 id="4-7-客户端，API-客户端，API-使用者"><a href="#4-7-客户端，API-客户端，API-使用者" class="headerlink" title="4.7 客户端，API 客户端，API 使用者"></a>4.7 客户端，API 客户端，API 使用者</h3><p>调用 API 请求并使用 API 响应的实体。</p>
<h3 id="4-8-幂等-Idempotency"><a href="#4-8-幂等-Idempotency" class="headerlink" title="4.8 幂等(Idempotency)"></a>4.8 幂等(Idempotency)</h3><p>幂等性是构建容错 API 的一个重要方面。幂等 API 使客户机能够安全地重试操作，而不必担心操作可能造成的副作用。例如，在请求由于网络连接错误而失败的情况下，客户机可以安全地重试幂等请求。</p>
<p>根据 <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2">HTTP 规范</a>，如果一个以上相同请求的副作用与单个请求的副作用相同，则该方法是幂等的。方法 <code>GET</code>， <code>HEAD</code> ， <code>PUT</code> 和 <code>DELETE</code> （另外， <code>TRACE</code> 和 <code>OPTIONS</code> ）是幂等的。</p>
<p>根据定义， <code>POST</code> 操作既不安全也不幂等。</p>
<p>所有服务实现都必须确保根据 HTTP 规范实现 HTTP 方法的安全和幂等行为。<code>POST</code> 操作需要幂等的服务必须按照以下准则实施。</p>
<h4 id="4-8-1-POST请求的幂等性"><a href="#4-8-1-POST请求的幂等性" class="headerlink" title="4.8.1 POST请求的幂等性"></a>4.8.1 POST请求的幂等性</h4><p>根据定义， <code>POST</code> 操作不是幂等的，这意味着使用相同的输入多次执行 <code>POST</code> 操作会创建相同数量的资源。为了避免创建重复的资源， API 应该实现下面一节中定义的协议。这保证了为相同的输入内容只创建一条记录。</p>
<p>对于那些需要 <code>POST</code> 请求具有幂等性的用例，创建重复记录是一个严重的问题。例如，不允许在账户上创建或执行重复的付款记录。</p>
<p>为了跟踪幂等请求，在每个请求中发送唯一的<strong>幂等密钥</strong>。定义 Header ，并将其值用作每个请求的<strong>幂等密钥</strong>。</p>
<p><strong>例子：</strong></p>
<p>客户端：</p>
<p>API 客户端发送带有 <code>Foo-Request-Id</code> 标头的 <code>POST</code> 请求，该标头包含<strong>幂等密钥</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /v1/payments/referenced-payouts-items HTTP/1.1</span><br><span class="line">Host: api.foo.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Bearer oauth2_token</span><br><span class="line">Foo-Request-Id: 123e4567-e89b-12d3-a456-426655440000</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;referenceIdd&quot;: &quot;4766687568468&quot;,</span><br><span class="line">    &quot;referenceType&quot;: &quot;egflf465vbk7468mvnb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端：</p>
<p>如果调用成功并创建资源，则服务必须返回 <code>201</code> 响应，表示成功和状态改变。</p>
<p>响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 201 CREATED</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;itemId&quot;: &quot;CDZEC5MJ8R5HY&quot;,</span><br><span class="line">  &quot;links&quot;: [&#123;</span><br><span class="line">      &quot;href&quot;: &quot;https://api.foo.com/v1/payments/referenced-payouts-items/CDZEC5MJ8R5HY&quot;,</span><br><span class="line">      &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务的响应中包含带有<strong>幂等密钥</strong>的 <code>Foo-Request-Id</code> 。</p>
<p><strong>对于来自客户端的具有相同输入有效内容的后续请求：</strong></p>
<p>客户端：</p>
<p>API 客户端发送的 <code>POST</code> 请求具有与以前相同的<strong>幂等密钥</strong>和请求体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /v1/payments/referenced-payouts-items HTTP/1.1</span><br><span class="line">Host: api.foo.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Bearer oauth2_token</span><br><span class="line">Foo-Request-Id: 123e4567-e89b-12d3-a456-426655440000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;reference_id&quot;: &quot;4766687568468&quot;,</span><br><span class="line">    &quot;reference_type&quot;: &quot;egflf465vbk7468mvnb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器在确认调用与第一次执行相同后，必须返回 <code>200</code> 响应，并带有资源信息，以表明请求已被成功处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;item_id&quot;: &quot;CDZEC5MJ8R5HY&quot;,</span><br><span class="line">    &quot;processing_state&quot;: &#123;</span><br><span class="line">        &quot;status&quot;: &quot;PROCESSING&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;reference_id&quot;: &quot;4766687568468&quot;,</span><br><span class="line">    &quot;reference_type&quot;: &quot;egflf465vbk7468mvnb&quot;,</span><br><span class="line">    &quot;payout_amount&quot;: &#123;</span><br><span class="line">        &quot;currency_code&quot;: &quot;USD&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;2.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;payout_destination&quot;: &quot;9C8SEAESMWFKA&quot;,</span><br><span class="line">    &quot;payout_transaction_id&quot;: &quot;35257aef-54f7-43cf-a258-3b45caf3293&quot;,</span><br><span class="line">    &quot;links&quot;: [&#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/payments/referenced-payouts-items/CDZEC5MJ8R5HY&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-2-幂等键的唯一性"><a href="#4-8-2-幂等键的唯一性" class="headerlink" title="4.8.2 幂等键的唯一性"></a>4.8.2 幂等键的唯一性</h4><p>作为每个 <code>POST</code> 请求的一部分提供的<strong>幂等密钥</strong>必须是惟一的，不能在具有不同请求体的其他请求中重用。请参阅下面描述的错误场景，以了解在使用重复<strong>幂等密钥</strong>的请求下，服务器的行为。</p>
<p>如何使密钥唯一取决于客户机以及它与服务器达成的协议。建议使用 <code>UUID</code> 或类似的随机标识符作为<strong>幂等密钥</strong>。还建议服务器实现基于时间的幂等键，从而能够在密钥到期时清除或删除它。</p>
<p>错误场景：</p>
<ul>
<li>如果幂等请求缺少 <code>Foo-Request-Id</code> 标头，则该服务必须返回 <code>400</code> 错误，并带有指向有关此模式的公共文档的链接。</li>
<li>如果试图用其他请求有效数据重用幂等密钥，则该服务必须返回 <code>422</code> 错误，并带有指向有关此模式的公共文档的链接。</li>
<li>对于其他错误，服务必须返回适当的错误消息。</li>
</ul>
<h2 id="5-设计原则"><a href="#5-设计原则" class="headerlink" title="5. 设计原则"></a>5. 设计原则</h2><p>本节阐述服务设计的原则，这些服务是向内部和外部开发人员，部门间，合作伙伴和关联公司公开 API 。服务是指与特定场景有关的功能，以 API 形式公开。</p>
<p>以下是服务的核心设计原则。</p>
<h3 id="5-1-松耦合"><a href="#5-1-松耦合" class="headerlink" title="5.1 松耦合"></a>5.1 松耦合</h3><p><strong>服务和消费者必须彼此松散耦合。</strong></p>
<p>耦合是指两件事之间的联系或关系。耦合程度相当于依赖的级别。该原则提倡服务契约的设计，并始终强调减少（<strong>松散</strong>）服务契约、与其实施和服务使用者之间的依赖性。</p>
<p>松散耦合的原则促进了服务逻辑和实现的独立设计和发展，同时仍然强调了与已经依赖该服务功能的消费者之间的基本互操作性。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务契约不应公开实施细节</li>
<li>服务契约可以演化而不会影响现有消费者</li>
<li>特定域中的服务可以独立于其他域演化</li>
</ul>
<h3 id="5-2-封装形式"><a href="#5-2-封装形式" class="headerlink" title="5.2 封装形式"></a>5.2 封装形式</h3><p><strong>域服务只能通过其他服务契约访问其没有的数据和功能。</strong></p>
<p>服务公开其拥有和实现的功能和数据，以及不依赖于它的功能和数据。该原则主张，任何服务所依赖且不属于它的功能或数据都必须仅通过服务契约来访问。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务具有明确的隔离边界</li>
<li>在功能和数据方面明确的所有权范围</li>
<li>服务不能直接公开它不拥有的数据</li>
</ul>
<h3 id="5-3-稳定性"><a href="#5-3-稳定性" class="headerlink" title="5.3 稳定性"></a>5.3 稳定性</h3><p><strong>服务契约必须稳定。</strong></p>
<p>服务的设计方式必须让它暴露的契约对现有客户仍然有效。如果服务契约需要以与消费者不兼容的方式发展，则应清楚地传达这一点。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>现有的客户服务必须在记录的时间内得到支持</li>
<li>必须以不影响现有消费者的方式引入其他功能</li>
<li>必须清楚地说明弃用和迁移政策，让消费者有心里预期</li>
</ul>
<h3 id="5-4-可重用"><a href="#5-4-可重用" class="headerlink" title="5.4 可重用"></a>5.4 可重用</h3><p><strong>服务必须开发为可在多个上下文中被多个使用者重用。</strong></p>
<p>API 平台的主要目标是通过使用和组合服务来使应用程序能够快速，经济高效地开发。只有在为多个用例和多个消费者灵活开发服务契约时，这才可能实现。该原则主张服务的开发方式应使其能够被多个消费者和在多种环境中使用，其中某些环境可能会随着时间而发展。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务契约不仅应针对当前环境而设计，还应具有支持和/或可扩展，以供多个消费者在不同环境中使用</li>
<li>服务契约可能需要随着时间的推移逐步发展以支持多种环境和消费者</li>
</ul>
<h3 id="5-5-基于契约"><a href="#5-5-基于契约" class="headerlink" title="5.5 基于契约"></a>5.5 基于契约</h3><p><strong>功能和数据只能通过标准化服务契约公开。</strong></p>
<p>服务通过服务契约公开其用途和功能。服务契约包括功能方面，非功能方面（例如可用性，响应时间）和业务方面（例如每次通话费用，条款和条件）。<em>标准化</em> 意味着服务契约必须符合契约设计标准。</p>
<p>该原则主张所有功能和数据都只能通过标准化服务契约公开。因此，服务的消费者只能通过服务契约来理解和访问功能和数据。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>在服务契约之外无法理解或访问功能和数据</li>
<li>每条数据（例如在数据存储中管理的数据）只属于一个服务</li>
</ul>
<h3 id="5-6-一致性"><a href="#5-6-一致性" class="headerlink" title="5.6 一致性"></a>5.6 一致性</h3><p><strong>服务必须遵循一组通用的规则，交互方式，词汇和共享类型。</strong></p>
<p>通过一组规则，可以定义一致的公开服务。通过减少使用者对新服务的学习曲线，来提高了 API 平台的易用性。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>为服务规定了一套标准</li>
<li>服务应使用通用和共享词典中的词汇</li>
<li>兼容的交互方式，服务粒度和共享类型是实现完全互操作性和简化服务组合的关键</li>
</ul>
<h3 id="5-7-使用方便"><a href="#5-7-使用方便" class="headerlink" title="5.7 使用方便"></a>5.7 使用方便</h3><p><strong>服务必须易于使用并在使用者（和应用程序）中组成。</strong></p>
<p>难用且耗时的服务会让消费者寻找其他机制来访问相同功能，这会降低微服务所带来的收益。可组合性意味着可以轻松组合服务，因为服务契约和访问协议是一致的，并且不必对每个服务契约有不同的理解。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务契约易于发现和理解</li>
<li>服务契约和协议在所有方面都是一致的，例如，标识和认证机制，错误语义，通用类型用法，分页等。</li>
<li>服务具有明确的所有权，因此消费者提供者可以就 SLA ，要求和问题与服务所有者联系</li>
<li>服务商可以轻松集成，测试和部署使用</li>
<li>服务商可以轻松地监视服务的非功能性指标</li>
</ul>
<h3 id="5-8-可外部化"><a href="#5-8-可外部化" class="headerlink" title="5.8 可外部化"></a>5.8 可外部化</h3><p><strong>服务的设计必须使其提供的功能易于外部化。</strong></p>
<p>服务是为来自另一个领域或团队、另一个业务单元或另一个公司的消费者开发的。在所有这些情况下，暴露的功能是相同的；更改的是访问机制或服务执行的策略，如身份验证、授权和速率限制。由于公开的功能是相同的，因此服务应该设计一次，然后根据业务需要通过适当的策略进行外部化。</p>
<p>该原则意味着以下几点：</p>
<ul>
<li>服务接口必须从域模型及它支持的用例中得出</li>
<li>支持的服务契约和访问（绑定）协议必须满足消费者的需求</li>
<li>服务的外部化不得要求重新实现或更改服务契约</li>
</ul>
<h2 id="6-HTTP-规范"><a href="#6-HTTP-规范" class="headerlink" title="6. HTTP 规范"></a>6. HTTP 规范</h2><p>本节阐述 HTTP 规范，并根据通用规范做出部分限定条件，以达到风格统一。</p>
<h3 id="６-1-URL"><a href="#６-1-URL" class="headerlink" title="６.1 URL"></a>６.1 URL</h3><h4 id="6-1-1-URL-结构"><a href="#6-1-1-URL-结构" class="headerlink" title="6.1.1 URL 结构"></a>6.1.1 URL 结构</h4><p>设计的 URL 应该简单和阅读理解，而不是让人感到困惑或者造成理解错误。在没有较好的客户端库支持的情况下，设计良好的 URL 有助于在多平台上使用。</p>
<p>设计良好的 URL ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox</span><br></pre></td></tr></table></figure>

<p>设计不好 URL ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/EWS/OData/Users(<span class="string">&#x27;jdoe@microsoft.com&#x27;</span>)/Folders(<span class="string">&#x27;AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 URL 作为参数值是常见的情况。例如，这种形式是可以接受的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-URL长度"><a href="#6-1-2-URL长度" class="headerlink" title="6.1.2 URL长度"></a>6.1.2 URL长度</h4><p>在 RFC 7230 的 <a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">3.1.1</a> 节中定义的 HTTP 1.1 消息格式在请求行上没有长度限制，该长度包括目标URL。</p>
<blockquote>
<p>HTTP 并未对请求行的长度设置预定义的限制。[…]当接收到比期望的 URL 长度更长的时候，服务器必须以 414（URI太长）状态码作为响应。</p>
</blockquote>
<p>当服务的 URL 长度超过 2083 个字符的时候 ，就需要考虑虑客户端使用是否方便。可以参考如下讨论：</p>
<ul>
<li><code>http://stackoverflow.com/a/417184</code></li>
<li><code>https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/</code></li>
</ul>
<p>还要注意，在设计服务的时候，应兼顾技术栈的在 URL 上的限制。</p>
<h3 id="6-2-HTTP-方法"><a href="#6-2-HTTP-方法" class="headerlink" title="6.2 HTTP 方法"></a>6.2 HTTP 方法</h3><p>HTTP 定义了一组请求方法, 以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作. 虽然他们也可以是名词, 但这些请求方法有时被称为 HTTP 动词. 每一个请求方法都实现了不同的语义, 但会有一些共同的特征。例如一个请求方法可以是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe">安全</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E5%B9%82%E7%AD%89">幂等</a>, 或 <a href="https://developer.mozilla.org/en-US/docs/Glossary/cacheable">可缓存</a>.</p>
<p>安全的 HTTP 方法是指这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。<code>GET</code>， <code>HEAD</code> 和 <code>OPTIONS</code> 都是安全的 HTTP 方法。所有安全的方法都是幂等的，而 <code>PUT</code> 和 <code>DELETE</code> 则是不安全的。</p>
<p>幂等值的是一个 HTTP 请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。</p>
<p>可缓存响应是一个可以被缓存的HTTP响应，它被存储起来以供以后检索和使用，并将一个新的请求保存到服务器。不是所有的HTTP响应都可以被缓存，以下是要缓存的HTTP响应的约束:</p>
<ul>
<li>请求中使用的方法本身是可缓存的，即 <code>GET</code> 或 <code>HEAD</code> 方法。</li>
<li>应用程序缓存响应的状态码，并且将其视为可缓存的。下面的状态代码可缓存：<code>200</code>，<code>203</code> ， <code>204</code> ， <code>206</code> ， <code>300</code> ， <code>301</code> ， <code>404</code> ， <code>405</code> ， <code>410</code> ， <code>414</code> ，和 <code>501</code> 。</li>
<li>响应中有特定的标头，例如 <code>Cache-Control</code> ，可以控制缓存。</li>
</ul>
<p>并非所有资源都支持这些方法，但是使用以下方法的所有资源必须符合其用法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否有请求主体</th>
<th>成功响应是否有主体</th>
<th>是否安全</th>
<th>是否幂等</th>
<th>是否可缓存</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET">GET</a></td>
<td>请求指定的资源。使用 GET 的请求应该只用于获取数据。</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">POST</a></td>
<td>根据提供的数据创建新对象，或提交命令 。</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>只在有新数据是</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT">PUT</a></td>
<td>使用请求中的数据创建或者替换目标资源。</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE">DELETE</a></td>
<td>用于删除指定的资源。</td>
<td>可以有</td>
<td>可以有</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD">HEAD</a></td>
<td>请求资源的 Header 信息, 且 Header 与 GET 请求返回的一致，只是没有响应体。</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH">PATCH</a></td>
<td>用于对资源进行部分修改。</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS">OPTIONS</a></td>
<td>用于获取目的资源所支持的通信选项。</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="6-2-1-POST"><a href="#6-2-1-POST" class="headerlink" title="6.2.1 POST"></a>6.2.1 POST</h4><p><code>POST</code> 方法不是幂等的，多次调用，会执行多次结果。如果调用创建资源的接口，多次调用会创建多个资源</p>
<ul>
<li><code>POST</code> 方法应该用于创建一个资源<ul>
<li>例： <code>POST https://api.foo.com/v1/users</code></li>
</ul>
</li>
<li><code>POST</code> 方法应用于创建一个子资源，并建立其与主资源间的关系<ul>
<li>例： <code>POST https://api.foo.com/v1/payments/12345/refund</code></li>
</ul>
</li>
<li><code>POST</code> 方法也可以根据名称用于复合操作</li>
</ul>
<p>如果应用于建资源。操作成功，返回 <code>201 Created</code> 状态码。其他处理成功返回 <code>200 OK</code> 状态码</p>
<h4 id="6-2-2-PUT"><a href="#6-2-2-PUT" class="headerlink" title="6.2.2 PUT"></a>6.2.2 PUT</h4><p><code>PUT</code> 使用请求中的数据创建或者替换目标资源。其是幂等的，即调用一次与连续调用多次是等价的。</p>
<p>处理成功返回 <code>204 No Content</code> 状态码。</p>
<h4 id="6-2-3-DELETE"><a href="#6-2-3-DELETE" class="headerlink" title="6.2.3 DELETE"></a>6.2.3 DELETE</h4><p>如果 <code>DELETE</code> 方法成功执行，那么可能会有以下几种状态码：</p>
<ul>
<li><code>200 OK</code> ：表示操作已执行，并且响应中提供了相关状态的描述信息。</li>
<li><code>202 Accepted</code> ：表示请求的操作可能会成功执行，但是尚未开始执行。</li>
<li><code>204 No Content</code>：表示操作已执行，但是无进一步的相关信息。</li>
</ul>
<h4 id="6-2-4-PATCH"><a href="#6-2-4-PATCH" class="headerlink" title="6.2.4 PATCH"></a>6.2.4 PATCH</h4><p>IETF 已将 <code>PATCH</code> 定义为用于增量更新现有对象的方法（请参阅 <a href="http://tools.ietf.org/html/rfc5789">RFC 5789</a>）。符合 REST API 准则的 API 应该支持 <code>PATCH</code> 。</p>
<p>不同于 <code>PUT</code> 方法，而与 <code>POST</code> 方法类似，<code>PATCH</code> 方法不是幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p>
<h4 id="6-2-5-OPTIONS"><a href="#6-2-5-OPTIONS" class="headerlink" title="6.2.5 OPTIONS"></a>6.2.5 OPTIONS</h4><p><code>OPTIONS</code> 用于获取目的资源所支持的通信选项。</p>
<p>通过 <code>OPTIONS</code> 返回响应头中 <code>Access-Control-Request-Method</code> 值来获悉该 URL 支持那些 HTTP 方法。</p>
<h3 id="6-3-Header"><a href="#6-3-Header" class="headerlink" title="6.3 Header"></a>6.3 Header</h3><p>HTTP 消息头允许客户端和服务器通过请求和响应传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“:”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。</p>
<p>自定专用消息头可通过 <code>X-</code> 前缀来添加；但是这种用法被 IETF 在 2012 年 6 月发布的 <a href="https://tools.ietf.org/html/rfc6648">RFC5548</a> 中明确弃用，原因是其会在非标准字段成为标准时造成不便；其他的消息头在 <a href="http://www.iana.org/assignments/message-headers/perm-headers.html">IANA 注册表</a>中列出, 其原始内容在 <a href="http://tools.ietf.org/html/rfc4229">RFC 4229</a> 中定义。此外， IANA 还维护着<a href="http://www.iana.org/assignments/message-headers/prov-headers.html">被提议的新 HTTP 消息头注册表</a>。</p>
<p>根据不同上下文，可将消息头分为：</p>
<ul>
<li>General headers: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li>
<li>Request headers: 包含更多有关要获取的资源或客户端本身信息的消息头。</li>
<li>Response headers: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li>
<li>Entity headers: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li>
</ul>
<!-- markdownlint-disable MD033 -->

<table>
<thead>
<tr>
<th>Header</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Authorization</code></td>
<td>字符串</td>
<td>请求的授权请求头</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>Date</td>
<td>基于客户端时钟的请求日期和时间格式 <a href="https://tools.ietf.org/html/rfc5322#section-3.3">RFC 5322</a> 。服务器不应对客户端时间做任何假设。提供此请求头时，必须将格林威治标准时间（GMT）用作该标头的时区参考。例如：<code>Wed, 24 Aug 2016 18:41:30 GMT</code>。请注意，GMT完全等于UTC（世界标准时间）。</td>
</tr>
<tr>
<td><code>Accept</code></td>
<td>用户期望的 MIME 类型列表</td>
<td>请求的响应内容类型，例如：<br/><ul><li> <code>application/xml</code> </li><li> <code>text/xml</code> </li><li> <code>application/json</code> </li><li> <code>text/javascript (for JSONP)</code> </li></ul><br/> 根据 HTTP 准则，这只是一个提示，响应可能具有不同的内容类型，例如 blob 提取，其中成功的响应将只是 blob 流作为有效负载。对于遵循 OData 的服务，应遵循 OData 中指定的优先顺序。</td>
</tr>
<tr>
<td><code>Accept-Encoding</code></td>
<td>Gzip, deflate</td>
<td>如果适用，REST 端点应该支持 GZIP 和 DEFLATE 编码。对于非常大的资源，服务可以忽略并返回未压缩的数据。</td>
</tr>
<tr>
<td><code>Accept-Language</code></td>
<td><code>en</code> ， <code>zh</code> ， 等。</td>
<td>指定响应的首选语言。服务器可能不支持此功能，但是如果服务支持本地化，则必须通过 Accept-Language 请求头来实现。</td>
</tr>
<tr>
<td><code>Accept-Charset</code></td>
<td>字符集类型，例如 <code>UTF-8</code></td>
<td>默认值为 <code>UTF-8</code> ，但是服务应该能够处理 <code>ISO-8859-1</code> 。</td>
</tr>
<tr>
<td><code>Content-Type</code></td>
<td>内容类型</td>
<td>请求主体的 MIME 类型（PUT / POST / PATCH）</td>
</tr>
<tr>
<td><code>Prefer</code></td>
<td><code>return=minimal</code>，<code>return=representation</code></td>
<td>如果指定首选项 <code>return=minimal</code> ，则服务应响应成功的插入或更新而返回空主体。如果指定了<code>return=representation</code>，则服务应在响应中返回创建或更新的资源。如果客户端有时需要响应内容，但有时需要避免带宽太大的影响，则服务必须支持此请求头</td>
</tr>
<tr>
<td><code>If-Match</code>, <code>If-None-Match</code> , <code>If-Range</code></td>
<td>字符串</td>
<td>支持使用乐观并发控制更新资源的服务必须支持 <code>If-Match 标头</code>。服务也可以使用其他与 ETag 相关的标头，只要它们遵循 HTTP 规范即可。</td>
</tr>
</tbody></table>
<!-- markdownlint-restore -->
<h3 id="6-4-响应格式"><a href="#6-4-响应格式" class="headerlink" title="6.4 响应格式"></a>6.4 响应格式</h3><p>基于 Web 的通信，尤其是在涉及移动或其他低带宽客户端时，由于多种原因，已朝 JSON 方向快速发展，包括其轻量的趋势以及与基于 JavaScript 的客户端的易用性。</p>
<p>JSON 属性名称应为驼峰式。</p>
<p>服务应提供 JSON 作为默认编码，即请求头默认为 <code>Accept=application/json</code> 。</p>
<h3 id="6-5-状态码"><a href="#6-5-状态码" class="headerlink" title="6.5 状态码"></a>6.5 状态码</h3><p>HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应( <code>100</code> – <code>199</code> )，成功响应( <code>200</code> – <code>299</code> )，重定向( <code>300</code>–<code>399</code> )，客户端错误( <code>400</code> – <code>499</code> )和服务器错误 ( <code>500</code> – <code>599</code> )。状态代码由 <a href="https://tools.ietf.org/html/rfc2616#section-10">section 10 of RFC 2616</a> 定义</p>
<p>RESTful 服务使用 HTTP 状态代码来指定 HTTP 方法执行的结果。 HTTP 协议使用整数和消息指定请求执行的结果。该数字称为<strong>状态码</strong>，该消息称为<strong>原因短语</strong>。原因短语是人类可读的消息，用于阐明响应的结果。 HTTP 协议将范围内的状态代码分类。</p>
<h4 id="6-5-1-状态码范围"><a href="#6-5-1-状态码范围" class="headerlink" title="6.5.1 状态码范围"></a>6.5.1 状态码范围</h4><p>响应 API 请求时，必须使用以下状态代码范围。</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>2xx</code></td>
<td>成功执行。方法执行有可能以多种方式成功执行。此状态代码指定成功的方式。</td>
</tr>
<tr>
<td><code>4xx</code></td>
<td>通常，这些问题包括请求，请求中的数据，无效的身份验证或授权等。在大多数情况下，客户端可以修改其请求并重新提交。</td>
</tr>
<tr>
<td><code>5xx</code></td>
<td>服务器错误：由于站点中断或软件缺陷，服务器无法执行该方法。5xx 范围状态代码不应用于验证或逻辑错误处理。</td>
</tr>
</tbody></table>
<h4 id="6-5-2-允许的状态代码列表"><a href="#6-5-2-允许的状态代码列表" class="headerlink" title="6.5.2 允许的状态代码列表"></a>6.5.2 允许的状态代码列表</h4><ul>
<li>API 绝不能返回此表中未定义的状态代码。</li>
<li>API 只能返回此表中定义的某些状态代码。</li>
</ul>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>200 OK</code></td>
<td>请求成功。</td>
</tr>
<tr>
<td><code>201 Created</code></td>
<td>用作对 <code>POST</code> 方法执行的响应，以指示成功创建资源。如果已经创建了资源（例如，通过先前执行同一方法），则服务器应返回状态代码 <code>200 OK</code> 。通常是在POST请求，或是某些PUT请求之后返回的响应。</td>
</tr>
<tr>
<td><code>202 Accepted</code></td>
<td>用于异步方法执行，以指定服务器已接受该请求并将在以后执行。有关更多详细信息，请参阅“<a href="https://github.com/paypal/api-standards/blob/master/patterns.md#asynchronous-operations">异步操作”</a>。</td>
</tr>
<tr>
<td><code>204 No Content</code></td>
<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于 <code>204</code> 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td><code>400 Bad Request</code></td>
<td>服务器无法理解该请求。使用此状态代码来指定：请求数据有误（请求的数据不能转换为基础数据类型、数据不是预期的数据格式、必填字段不可用、简单数据验证类型的错误）。</td>
</tr>
<tr>
<td><code>401 Unauthorized</code></td>
<td>该请求需要身份验证，但未提供任何身份。请注意此与之间的区别 <code>403 Forbidden</code> 。</td>
</tr>
<tr>
<td><code>403 Forbidden</code></td>
<td>服务器已经理解请求，但是拒绝执行它。客户端无权访问资源，尽管它可能具有有效的凭据。如果业务级别授权失败， API 可以使用此代码。例如，持有者的资金不足。</td>
</tr>
<tr>
<td><code>404 Not Found</code></td>
<td>服务器未找到与请求 URI 匹配的任何内容。这意味着 URI 不正确或资源不可用。例如，可能是该键处的数据库中没有数据。</td>
</tr>
<tr>
<td><code>405 Method Not Allowed</code></td>
<td>服务器尚未实现请求的 HTTP 方法。这通常是 API 框架的默认行为。</td>
</tr>
<tr>
<td><code>406 Not Acceptable</code></td>
<td>当请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。例如，如果客户端发送了 <code>Accept: application/xml</code> 标头，而 API 只能返回 <code>application/json</code> ，则服务器必须返回 <code>406</code> 。</td>
</tr>
<tr>
<td><code>415 Unsupported Media Type</code></td>
<td>当请求的有效负载的媒体类型无法处理时，服务器必须返回此状态代码。例如，如果客户端发送 <code>Content-Type: application/xml</code> 标头，但 API 仅接受 <code>application/json</code> ，则服务器必须返回<code>415</code>。</td>
</tr>
<tr>
<td><code>422 Unprocessable Entity</code></td>
<td>请求的操作无法执行，可能需要与当前请求之外的 API 或进程进行交互。这与 500 响应不同，因为没有系统性的问题限制 API 执行请求。</td>
</tr>
<tr>
<td><code>429 Too Many Requests</code></td>
<td>如果用户，应用程序或令牌的速率限制已超过预定义的值，则服务器必须返回此状态代码。在其他 HTTP 状态代码 <a href="https://tools.ietf.org/html/rfc6585">RFC 6585中</a> 定义。</td>
</tr>
<tr>
<td><code>500 Internal Server Error</code></td>
<td>这可能是系统错误，也可能是应用程序错误，通常表明尽管客户端似乎提供了正确的请求，但服务器上出现了意外情况。一个 <code>500</code> 响应指示服务器端软件缺陷或网站停止。 <code>500</code> 不应用于客户端验证或逻辑错误处理。</td>
</tr>
<tr>
<td><code>503 Service Unavailable</code></td>
<td>由于临时维护，服务器无法处理服务请求。常见原因是服务器因维护或重载而停机。</td>
</tr>
</tbody></table>
<h2 id="7-命名规范"><a href="#7-命名规范" class="headerlink" title="7. 命名规范"></a>7. 命名规范</h2><p>本节阐述在命名上的规范。</p>
<h3 id="7-1-URI-规范"><a href="#7-1-URI-规范" class="headerlink" title="7.1 URI 规范"></a>7.1 URI 规范</h3><h4 id="7-1-1-URI-组成"><a href="#7-1-1-URI-组成" class="headerlink" title="7.1.1 URI 组成"></a>7.1.1 URI 组成</h4><p>URI遵循 <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a> 规范。该规范简化了 REST API 服务的开发和使用。本节中的准则遵循 RFC 3986 约束来管理 URI 结构和语义。</p>
<p>根据 RFC 3986，通用 URI 语法由组件的层次结构序列组成，称为协议，权限，路径，查询字符串和锚点，如下面的示例所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://example.com:8042/over/there?name=ferret#nose</span><br><span class="line">\___/   \_______________/\_________/\_________/\__/</span><br><span class="line">  |           |            |            |        |</span><br><span class="line">scheme     authority      path        query   fragment</span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-URI-命名约定"><a href="#7-1-2-URI-命名约定" class="headerlink" title="7.1.2 URI 命名约定"></a>7.1.2 URI 命名约定</h4><p>以下是对API的 URI 特定命名约定准则的简要说明。本规范使用括号“()”进行分组，星号 “*” 指定零个或多个出现，括号“[]”表示可选字段。</p>
<ul>
<li>URI 必须以字母开头，并且只能使用小写字母。</li>
<li>URI 路径中的文字或表达式应使用连字符（<code>-</code>）分隔。</li>
<li>URI 路径和查询字符串必须将数据编码成 <a href="https://en.wikipedia.org/wiki/Percent-encoding">UTF-8 八位字节</a>。</li>
<li>URI 中应该使用名词复数来标识数据资源的集合。<ul>
<li><code>/invoices</code></li>
<li><code>/statements</code></li>
</ul>
</li>
<li>资源集合中的单个资源可以直接存在于集合 URI 的后面。<ul>
<li><code>/invoices/&#123;invoice_id&#125;</code></li>
</ul>
</li>
<li>子资源集合可以直接存在于单个资源之下。这应该传达与另一个资源集合的关系（在此示例中为发票项目）。<ul>
<li><code>/invoices/&#123;invoice_id&#125;/items</code></li>
</ul>
</li>
<li>子资源的单个资源可以存在，但应避免使用顶级资源。<ul>
<li><code>/invoices/&#123;invoice_id&#125;/items/&#123;item_id&#125;</code></li>
<li><code>/invoice-items/&#123;invoice_item_id&#125;</code></li>
</ul>
</li>
<li>资源标识符应遵循后续部分中描述的<a href="#7-2-%E8%B5%84%E6%BA%90%E5%90%8D%E7%A7%B0">建议</a>。</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><code>https://api.foo.com/v1/vault/credit-cards</code></li>
<li><code>https://api.foo.com/v1/vault/credit-cards/CARD-7LT50814996943336KESEVWA</code></li>
<li><code>https://api.foo.com/v1/payments/billing-agreements/I-V8SSE9WLJGY6/re-activate</code></li>
</ul>
<p><strong>正式定义：</strong></p>
<table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>URI</td>
<td>[end-point] ‘<strong>/</strong>‘ resource-path [‘<strong>?</strong>‘query’]</td>
</tr>
<tr>
<td>end-point</td>
<td>[scheme “<strong>://</strong>“ ][host [‘<strong>:</strong>‘ port]]</td>
</tr>
<tr>
<td>schema</td>
<td>“<strong>http</strong>“或”<strong>https</strong> “</td>
</tr>
<tr>
<td>资源路径(resource-path)</td>
<td>“<strong>/v</strong>“ 版本 ‘<strong>/</strong>‘ 名称空间名称 ‘<strong>/</strong>‘ 资源（’<strong>/</strong>‘ 资源）</td>
</tr>
<tr>
<td>资源(resource)</td>
<td>资源名称 [‘<strong>/</strong>‘ 资源ID]</td>
</tr>
<tr>
<td>资源名称(resource-name)</td>
<td>Alpha(Alpha |数字|’-‘)*</td>
</tr>
<tr>
<td>资源编号(resource-id)</td>
<td>value</td>
</tr>
<tr>
<td>query</td>
<td>name ‘<strong>=</strong>‘ value (‘<strong>＆</strong>‘ name=value）*</td>
</tr>
<tr>
<td>name</td>
<td>Alpha（Alpha |数字|’_’）*</td>
</tr>
<tr>
<td>value</td>
<td>URI编码值</td>
</tr>
</tbody></table>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;   用单引号括住特殊字符</span><br><span class="line">&quot;   用双引号引起来的字符串</span><br><span class="line">()  使用括号进行分组</span><br><span class="line">[]  使用方括号指定可选表达式</span><br><span class="line">*   一个表达式可以重复零次或多次</span><br></pre></td></tr></table></figure>

<h3 id="7-2-资源名称"><a href="#7-2-资源名称" class="headerlink" title="7.2 资源名称"></a>7.2 资源名称</h3><p>将服务建模为一组资源时，开发人员必须遵循以下原则：</p>
<ul>
<li>必须使用名词，而不是动词。</li>
<li>单个资源名称必须为单数；集合的名称必须为复数。<ul>
<li>用户帐户上自动付款配置的说明。<ul>
<li><code>GET /autopay</code> 返回完整的表示形式。</li>
</ul>
</li>
<li>假设费用的集合：<ul>
<li><code>GET /charges</code> 返回已收取的费用清单。</li>
<li><code>POST /charges</code> 创建一个新的费用资源， <code>/charges/1234</code> 。</li>
<li><code>GET /charges/1234</code> 返回一次费用的完整表示。</li>
</ul>
</li>
</ul>
</li>
<li>资源名称必须为小写字母，并且只能使用字母数字字符和连字符。</li>
<li>连字符（-）必须用作 URI 路径文字中的单词分隔符。<strong>请注意</strong>，这是连字符用作单词分隔符的唯一位置。其他情况下，必须使用小驼峰式。</li>
</ul>
<h3 id="7-3-查询参数名称"><a href="#7-3-查询参数名称" class="headerlink" title="7.3 查询参数名称"></a>7.3 查询参数名称</h3><ul>
<li>查询字符串中的文字/表达式应使用小驼峰式。</li>
<li>查询参数值必须进行编码。</li>
<li>查询参数必须以字母开头，只能使用字母字符，数字。</li>
<li>查询参数应该是可选的。</li>
</ul>
<h3 id="7-4-字段名称"><a href="#7-4-字段名称" class="headerlink" title="7.4 字段名称"></a>7.4 字段名称</h3><p>数据模型必须符合 <a href="http://json.org/">JSON</a> 。这些值本身可以是对象，字符串，数字，布尔值或对象数组。</p>
<ul>
<li>关键字名称必须为小写单词，并用小驼峰式。<ul>
<li><code>foo</code></li>
<li><code>barBaz</code></li>
</ul>
</li>
<li>前缀 <code>is</code> 或 <code>has</code> 的字段不应是布尔类型的 key。</li>
<li>代表数组的字段应使用复数名词来命名（例如， <code>authenticators</code> ：包含一个或多个 Authenticator， <code>products</code> ：包含一个或多个产品）。</li>
</ul>
<h2 id="8-异常"><a href="#8-异常" class="headerlink" title="8. 异常"></a>8. 异常</h2><p>根据 HTTP 规范，可以使用整数和消息指定请求执行的结果。该数字称为<strong>状态码</strong>，该消息称为<strong>原因短语</strong>。原因短语是一种人类可读的消息，用于阐明响应的结果。 <code>4xx</code>  范围内的HTTP状态代码指示客户端错误（验证或逻辑错误），而  <code>5xx</code>  范围内的 HTTP 状态代码指示服务器端错误（通常是缺陷或中断）。但是，这些状态码和人类可读的原因短语不足以以机器可读的方式传达足够的错误信息。要解决错误，非人类的 RESTful API 使用者需要其他帮助。</p>
<p>异常字段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;some error code&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;error detail message&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2020-10-22T06:49:18.131+0000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-超媒体"><a href="#9-超媒体" class="headerlink" title="9. 超媒体"></a>9. 超媒体</h2><h3 id="9-1-HATEOAS"><a href="#9-1-HATEOAS" class="headerlink" title="9.1 HATEOAS"></a>9.1 HATEOAS</h3><p>超媒体是<a href="https://en.wikipedia.org/wiki/Hypertext">超文本</a>一词的扩展，是一种非线性的信息介质，根据 <a href="https://en.wikipedia.org/wiki/Hypermedia">Wikipedia 的规定</a>，它包括图形，音频，视频，纯文本和超链接。超媒体作为应用程序状态的引擎 <code>HATEOAS</code> 是 Roy Fielding 在其<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">论文中</a>描述的 REST 应用程序体系结构的约束。</p>
<p>在 RESTful API 的上下文中，客户端可以完全通过服务动态提供的超媒体与服务交互。超媒体驱动的服务通过在响应中包括超媒体链接，向其客户端提供资源表示，以动态导航 API 。这不同于 SOA 的其他形式，在 SOA 中，服务器和客户端基于 Web 上某个位置定义的或基于带外交换的，基于 WSD L的规范进行交互。</p>
<h3 id="9-2-符合超媒体的-API"><a href="#9-2-符合超媒体的-API" class="headerlink" title="9.2 符合超媒体的 API"></a>9.2 符合超媒体的 API</h3><p>符合超媒体的 API 公开了服务的有限状态机。在这里，要求如 <code>DELETE</code> ， <code>PATCH</code> ， <code>POST</code> 和 <code>PUT</code> 通常在启动状态的转变，而响应指示状态的变化。让我们以一个 API 为例，该 API 公开一组操作来管理用户帐户生命周期并实现HATEOAS接口约束。</p>
<p>客户端通过固定的URI开始与服务进行交互 <code>/users</code> 。此 URI 支持 <code>GET</code> 和 <code>POST</code> 操作。客户端执行一项 <code>POST</code> 操作以在系统中创建用户。</p>
<p><strong>要求</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://api.foo.com/v1/customer/users</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;given_name&quot;: &quot;James&quot;,</span><br><span class="line">    &quot;surname&quot; : &quot;Greenwood&quot;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>响应：</strong></p>
<p>API 从输入中创建一个新用户，并在响应中将以下链接返回到客户端。</p>
<ul>
<li>检索用户完整表示的 <code>self</code> 链接（<code>GET</code>）。</li>
<li>更新用户的链接（<code>PUT</code>）。</li>
<li>部分更新用户的链接（<code>PATCH</code>）。</li>
<li>删除用户的链接（<code>DELETE</code>）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">HTTP/1.1 201 CREATED</span><br><span class="line">Content-Type: application/json</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&quot;links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;replace&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">        &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以将这些链接存储在其数据库中以供以后使用。</p>
<p>然后，在管理员决定删除其中一个用户之前，客户端可能希望显示一组用户及其详细信息。因此，客户端对相同的 URI <code>/users</code> 执行 <code>GET</code> 操作。</p>
<p><strong>请求</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.foo.com/v1/customer/users</span><br></pre></td></tr></table></figure>

<p>该API通过相应的 <code>self</code> 链接返回系统中的所有用户。</p>
<p><strong>响应：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;total_items&quot;: &quot;166&quot;,</span><br><span class="line">    &quot;total_pages&quot;: &quot;83&quot;,</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;given_name&quot;: &quot;James&quot;,</span><br><span class="line">        &quot;surname&quot;: &quot;Greenwood&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;links&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">                &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;given_name&quot;: &quot;David&quot;,</span><br><span class="line">        &quot;surname&quot;: &quot;Brown&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;links&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-MDFSKFGIFJ86DSF&quot;,</span><br><span class="line">                &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以跟随 <code>self</code> 用户的链接并找出它可以在用户资源上执行的所有可能的操作。</p>
<p><strong>请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI</span><br></pre></td></tr></table></figure>

<p><strong>响应：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;given_name&quot;: &quot;James&quot;,</span><br><span class="line">        &quot;surname&quot;: &quot;Greenwood&quot;,</span><br><span class="line">        ...</span><br><span class="line">        &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;replace&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了删除用户，客户端从其数据存储中检索 <code>delete</code> 链接的 URI 并对该 URI 执行删除操作。</p>
<p><strong>请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI</span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<ul>
<li>客户端可以导航到 API 的入口点，以便访问所有其他资源。</li>
<li>客户端无需构建组成 URI 的逻辑来执行不同的请求或通过查看可能与 URI 和状态更改相关的响应详细信息（在后面的部分中进行更详细的描述）来编码任何种类的业务规则。 。</li>
<li>客户端承认创建 URI 的过程属于服务器这一事实。</li>
<li>客户端将 URI 视为不透明标识符。</li>
<li>在表示中使用超媒体的 API 可以无缝扩展。随着新方法的引入，可以通过相关的 HATEOAS 链接扩展响应。这样，客户可以增量方式利用该功能。例如，如果 API 开始支持新 <code>PATCH</code> 操作，则客户端可以使用它进行部分更新。</li>
</ul>
<p>仅仅是链接的存在并不能使客户端从需要了解数据来请求转换和所有相关的链接语义中解脱出来，特别是对 <code>POST</code> 、 <code>PUT</code> 、 <code>PATCH</code> 操作。 API 必须提供文档，以清楚地描述每个 URI 的所有链接，链接关系类型和请求响应格式。</p>
<p>后续部分提供有关链接结构以及不同关系类型的含义的更多详细信息。</p>
<h4 id="9-2-1-链接描述对象"><a href="#9-2-1-链接描述对象" class="headerlink" title="9.2.1 链接描述对象"></a>9.2.1 链接描述对象</h4><p>必须使用<a href="http://json-schema.org/latest/json-schema-hypermedia.html#anchor17">链接描述对象（LDO）</a>模式描述链接。LDO 在 links 数组中描述了单个链接关系。以下是链接描述对象的属性的简要描述。</p>
<ul>
<li><code>href</code>：<ul>
<li><code>href</code>必须提供属性的值。</li>
<li><code>href</code>属性的值必须是 <a href="https://tools.ietf.org/html/rfc6570">URI 模板</a>，用于确定相关资源的目标 URI。应根据 <a href="https://tools.ietf.org/html/rfc6570">RFC 6570</a> 将其解析为 URI 模板。</li>
<li>仅将绝对 URI 用作<code>href</code>属性值。客户端通常将表示形式的链接关系类型的绝对 URI 标记为书签，以便以后发出 API 请求。开发人员必须使用 <a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#uri-component-names">URI 组件命名约定</a>来构造绝对 URI 。传入 <code>Host</code> 请求头（例如 api.foo.com ）中的值必须用作 <code>host</code> 绝对 URI 的字段。</li>
</ul>
</li>
<li><code>rel</code>：<ul>
<li><code>rel</code> 代表“链接关系类型”中定义的关系</li>
<li>该<code>rel</code>属性的值指示与目标资源的关系的名称。</li>
<li><code>rel</code>必须提供属性的值。</li>
</ul>
</li>
<li><code>method</code>：<ul>
<li>该 <code>method</code> 属性标识必须用于向链接目标发出请求的 HTTP 动词。如果忽略该 <code>method</code> 属性，则默认值为 <code>GET</code> 。</li>
</ul>
</li>
<li><code>title</code>：<ul>
<li>该 <code>title</code> 属性提供了链接的标题，并且是一个有用的文档工具，可帮助最终客户理解。此属性不是必要的。</li>
</ul>
</li>
</ul>
<h5 id="不为-LDO-使用-HTTP-请求头"><a href="#不为-LDO-使用-HTTP-请求头" class="headerlink" title="不为 LDO 使用 HTTP 请求头"></a>不为 LDO 使用 HTTP 请求头</h5><p>请注意，这些 API 准则不建议使用 HTTP <code>Location</code> 标头来提供链接。另外，他们也不建议使用 <a href="https://java.net/projects/jax-rs-spec/pages/Hypermedia">JAX-RS 中</a> <code>Link</code> 描述的标头。HTTP 请求头的范围仅限于客户端和服务之间的点对点交互。由于响应可能被传递到客户端上的其他层和组件，这些层和组件可能与服务不直接交互，因此请求头中存储的任何信息都可能不可用。</p>
<h4 id="9-2-1-链接数组"><a href="#9-2-1-链接数组" class="headerlink" title="9.2.1 链接数组"></a>9.2.1 链接数组</h4><p><code>links</code> 模式的 array 属性用于将链接描述对象与 [JSON hyper-schema draft-04] <a href="http://json-schema.org/draft-04/hyper-schema#">3</a> 实例相关联。</p>
<ul>
<li>此属性必须是一个数组。</li>
<li>数组中的项目必须为链接描述对象类型。</li>
</ul>
<h5 id="指定链接数组"><a href="#指定链接数组" class="headerlink" title="指定链接数组"></a>指定链接数组</h5><p>这是一个如何描述架构中的链接的示例。</p>
<ul>
<li>必须在 API 资源模式定义的一部分中提供与下面的示例 JSON 模式中定义的链接数组相似的链接数组。请注意， links 数组需要在 <code>properties</code> 对象的关键字内声明。这是代码生成器为所生成的对象中的 links 数组添加 setter 、 getter 方法所必需的。</li>
<li>必须使用 URI 模板在响应模式中声明 API 作为响应的一部分返回的所有可能的链接。 URI 模板的 links 数组必须在 <code>properties</code> 关键字之外声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">    &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/hyper-schema#&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;A sample resource representing a customer name.&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Unique ID to identify a customer.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;first_name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Customer&#x27;s first name.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;last_name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Customer&#x27;s last name.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;links&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;array&quot;,</span><br><span class="line">            &quot;items&quot;: &#123;</span><br><span class="line">                &quot;$ref&quot;: &quot;http://json-schema.org/draft-04/hyper-schema#definitions/linkDescription&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;replace&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/&#123;id&#125;&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是符合上述架构的示例响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;last_name&quot;: &quot;Doe&quot;,</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/cusommer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;self&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;https://api.foo.com/v1/customer/users/ALT-JFWXHGUV7VI&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;PATCH&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-链接关系类型"><a href="#9-3-链接关系类型" class="headerlink" title="9.3 链接关系类型"></a>9.3 链接关系类型</h3><p><code>Link Relation Type</code> 用作链接的标识符。 API 必须分配有意义的链接关系类型，该类型必须明确描述链接的语义。客户端使用相关的链接关系类型，以便从表示形式中识别要使用的链接。</p>
<p>当 [IANA 的标准链接关系列表] <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">5</a> 中定义的链接关系类型的语义与您要定义的语义匹配时，则必须使用它。下表描述了一些常用的链接关系类型。它还列出了这些准则定义的一些其他lin关系类型。</p>
<table>
<thead>
<tr>
<th>链接关系类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>self</code></td>
<td>传达链接上下文的标识符。通常是指向资源本身的链接。</td>
</tr>
<tr>
<td><code>create</code></td>
<td>指可用于创建新资源的链接。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td>指编辑（或部分更新）链接标识的表示形式。使用它来表示<code>PATCH</code>操作链接。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>指删除链接标识的资源。使用它<code>Extended link relation type</code>来表示<code>DELETE</code>操作链接。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td>指完全更新（或替换）链接标识的表示形式。使用它<code>Extended link relation type</code>来表示<code>PUT</code>操作链接。</td>
</tr>
<tr>
<td><code>first</code></td>
<td>指结果列表的第一页。</td>
</tr>
<tr>
<td><code>last</code></td>
<td>指提供的结果列表的最后一页<code>total_required</code>指定为查询参数。</td>
</tr>
<tr>
<td><code>next</code></td>
<td>指结果列表的下一页。</td>
</tr>
<tr>
<td><code>prev</code></td>
<td>指结果列表的前一页。</td>
</tr>
<tr>
<td><code>collection</code></td>
<td>引用集合资源（例如/ v1 / users）。</td>
</tr>
<tr>
<td><code>latest-version</code></td>
<td>指向包含最新（例如当前）版本的资源。</td>
</tr>
<tr>
<td><code>search</code></td>
<td>指可用于搜索链接上下文和相关资源的资源。</td>
</tr>
<tr>
<td><code>up</code></td>
<td>指资源层次结构中的父资源。</td>
</tr>
</tbody></table>
<p>对于所有 <a href="https://github.com/paypal/api-standards/blob/master/patterns.md#controller-resource"><code>controller</code></a> 款式复杂的操作，控制器 <code>action</code> 名称必须使用中的链接关系类型（例如<code>activate</code>，<code>cancel</code>，<code>refund</code>）。</p>
<h2 id="10-CORS"><a href="#10-CORS" class="headerlink" title="10. CORS"></a>10. CORS</h2><p>跨源资源共享标准新增了一组 HTTP 头，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p>
<p>符合 REST API 准则的服务必须支持 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">CORS（跨源资源共享）</a>。</p>
<p>服务应支持信任的 CORS 来源，并通过有效的 OAuth 令牌强制执行授权。服务不应通过来源验证支持用户凭据。特殊情况可能会有例外。</p>
<h3 id="10-1-指导说明"><a href="#10-1-指导说明" class="headerlink" title="10.1 指导说明"></a>10.1 指导说明</h3><p>Web 开发人员通常不需要做任何特殊的事情就可以利用 CORS 。所有步骤都应该有框架或者库自动执行。</p>
<h4 id="10-1-1-避免预检"><a href="#10-1-1-避免预检" class="headerlink" title="10.1.1 避免预检"></a>10.1.1 避免预检</h4><p>由于 CORS 协议可以触发预检请求，这些预检请求会增加与服务器的交互，因此对性能要求较高的应用可能会希望避免这种情况。CORS 可以对简单的请求不要求预检，但对于其他请求一定要预检。</p>
<p><strong>简单请求：</strong></p>
<p>必须满足如下所有条件的请求才能定义为简单请求</p>
<ul>
<li>使用下列方法之一<ul>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>POST</code></li>
</ul>
</li>
<li>除了被用户代理自动设置的标头字段（例如 Connection ，User-Agent）和在 Fetch 规范中定义为禁用标头名称外的其他标头，允许人为设置的字段为 Fetch 规范定义的对 CORS 安全的首部字段集合。该集合为：<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
</li>
<li><code>Content-Type</code> 的值仅限于下列三者之一：<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
</li>
</ul>
<h3 id="10-2-服务指南"><a href="#10-2-服务指南" class="headerlink" title="10.2 服务指南"></a>10.2 服务指南</h3><ul>
<li>了解浏览器在跨域请求中发送的 <code>Origin</code> 请求头，以及在检查访问的预检 <code>OPTIONS</code> 请求中发送的 <code>Access-Control-Request-Method</code> 请求标头。</li>
<li>如果请求中存在 <code>Origin</code> 头：<ul>
<li>如果请求使用 <code>OPTIONS</code> 方法并包含 <code>Access-Control-Request-Method</code> 标头，则它是预检请求，旨在在实际请求之前探测访问。否则，这是一个正常的请求。对于预检请求，除了执行以下添加标头的步骤之外，服务务必不要执行任何其他处理，并且必须返回 <code>200 OK</code> 。对于非预检请求，除了请求的常规处理之外，还会添加以下头。</li>
<li>将 <code>Access-Control-Allow-Origin</code> 头添加到响应中，该头包含与 <code>Origin</code> 头相同的值。请注意，这需要服务动态生成请求头值。不需要 <code>cookie</code> 或任何其他形式的<a href="http://www.w3.org/TR/access-control/#user-credentials">用户凭证的资源</a>可以用通配符星号（*）代替。请注意，通配符仅在此处可接受，不适用于以下所述的任何其他头。</li>
<li>如果调用方需要访问不在<a href="http://www.w3.org/TR/access-control/#simple-hader">简单响应标头</a>列表中的响应标头（ <code>Cache-Control</code> ， <code>Content-Language</code> ， <code>Content-Type</code> ， <code>Expires</code> ， <code>Last-Modified</code> ， <code>Pragma</code> ），则应将客户端有权访问的其他响应头名称添加到 <code>Access-Control-Expose-Headers</code> 标头中。</li>
<li>如果请求需要 cookie ，则添加一个 <code>Access-Control-Allow-Credentials</code> 标头设置为 <code>true</code>。</li>
<li>如果该请求是预检请求（请参阅第一个项目符号），则该服务必须：<ul>
<li>添加一个 <code>Access-Control-Allow-Headers</code> 响应标头，其中包含允许客户端使用的请求标头名称的列表。该列表仅需要包含不在<a href="http://www.w3.org/TR/access-control/#simple-header">简单请求标头</a>集中的<a href="http://www.w3.org/TR/access-control/#simple-header">标头</a>（ <code>Accept</code> ， <code>Accept-Language</code> ， <code>Content-Language</code> ）。如果服务接受的头没有任何限制，则该服务可以简单地返回与客户端发送的 <code>Access-Control-Request-Headers</code> 头相同的值。</li>
<li>添加一个 <code>Access-Control-Allow-Methods</code> 响应标头，其中包含允许调用方使用的 HTTP 方法的列表。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>添加一个 <code>Access-Control-Max-Age</code> 响应标头，其中包含该响应有效的时间（因此可以在随后的实际请求之前避免使用）。请注意，虽然习惯使用较大的值，例如 2592000（30天），但许多浏览器会自行施加一个较低的限制（例如5分钟）。</p>
<p>由于浏览器的预检响应缓存非常差，因此预检响应带来的额外请求次数会影响性能。性能至关重要的交互式 Web 客户端使用的服务时应避免导致预检请求的模式</p>
<ul>
<li>对于 GET 和 HEAD 调用，请避免要求不属于上述简单请求标头。允许将它们作为查询参数提供。<ul>
<li><code>Authorization</code> 标头不是简单请求头的一部分，因此对于需要身份验证的资源，必须通过 <code>access_token</code> 查询参数发送身份验证令牌。请注意，不建议在 URL 中传递身份验证令牌，因为它可能导致令牌记录在服务器日志中并暴露给有权访问这些日志的任何人。通过URL接受身份验证令牌的服务必须采取措施来减轻安全风险，例如使用短暂的身份验证令牌，禁止身份验证令牌被记录以及控制对服务器日志的访问。</li>
</ul>
</li>
<li>避免要求 Cookie 。如果设置了 <code>withCredentials</code> 属性，则 XmlHttpRequest 仅在跨域请求上发送 cookie 。这也会导致预检请求。<ul>
<li><del>需要基于 Cookie 的身份验证的服务务必使用 “Dynamic Canary” 来保护所有接受 Cookie 的 API 。</del></li>
</ul>
</li>
<li>对于 POST 调用，请在适用的情况下使用简单的 <code>Content-Type</code> （<code>aplication/x-www-form-urlencoded</code> ，<code>multipart/form-data</code> ， <code>text/plain</code> ）。任何其他 <code>Content-Type</code> 都会引发预检请求。<ul>
<li>服务不得以避免 CORS 预检请求的名义违反其他 API 建议。特别是，根据建议，使用 <code>Content-Type</code> 的大多数 POST 请求实际上都需要进行预检请求。</li>
<li>如果必须取消预检，那么服务应支持替代的数据传输机制，但是必须也支持推荐的方法。</li>
</ul>
</li>
</ul>
<p>另外，在某些时候，可以支持 JSONP 模式，以进行简单的，仅限 GET 的跨域访问。在 JSONP 中，服务采用指示格式（<code>$format=json</code>）的参数和指示回调（<code>$callback=someFunc</code>）的参数，并返回 <code>text/ javascript</code> 文档，该文档包含包装在具有指定名称的函数调用中的 JSON 响应。 Wikipedia 上有关 JSONP 的更多信息：<a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>。</p>
<h2 id="11-JSON"><a href="#11-JSON" class="headerlink" title="11. JSON"></a>11. JSON</h2><h3 id="11-1-JSON-类型"><a href="#11-1-JSON-类型" class="headerlink" title="11.1  JSON 类型"></a>11.1  JSON 类型</h3><p>本节提供了与 JSON 基本类型的用法有关的准则，以及地址，名称，货币，货币，国家，电话等常用的 JSON 类型。</p>
<h4 id="11-1-1-JSON-基本类型"><a href="#11-1-1-JSON-基本类型" class="headerlink" title="11.1.1 JSON 基本类型"></a>11.1.1 JSON 基本类型</h4><p>JSON Schema <a href="http://tools.ietf.org/html/draft-zyp-json-schema-04">draft-04</a>应该用于定义 API 中的所有字段。因此，应注意以下有关 JSON Schema 原语类型的注释。以下是指导使用 JSON 基本类型表示形式的准则。</p>
<h5 id="11-1-1-1-字符串"><a href="#11-1-1-1-字符串" class="headerlink" title="11.1.1.1 字符串"></a>11.1.1.1 字符串</h5><p><code>strings</code> 应始终明确定义 <code>minLength</code> 和 <code>maxLength</code> 。</p>
<p>这样做有几个原因。</p>
<ol>
<li>没有最大长度，就不可能可靠地定义数据库列来存储给定的字符串。</li>
<li>没有最大值和最小值，也无法预测长度的变化是否会破坏与现有客户端的向后兼容性。</li>
<li>最后，没有最小长度，客户端通常有可能在不允许发送空字符串的情况下发送空字符串。</li>
</ol>
<p>API 可能避免定义 <code>minLength</code> 和 <code>maxLength</code> 仅如果字符串值是从已经拒绝提供这些值的任何信息的另一上游系统。该决定必须记录在架构中。</p>
<p>API 的作者在定义时应考虑实际限制 <code>maxLength</code> 。例如，当使用 VARCHAR2 类型时，现代版本的 Oracle 可以安全地存储不超过 1,000 个字符的 Unicode 字符串。（大小限制为<a href="https://docs.oracle.com/cd/B28359_01/server.111/b28320/limits001.htm">4,000</a>个字节，每个 Unicode 字符最多可能需要四个字节来存储）。</p>
<p><code>string</code> 应该<code>pattern</code>适当地利用该属性，尤其是在定义枚举值或数字时。但是，建议不要在没有充分技术理由的情况下过度约束字段。</p>
<h5 id="11-1-1-2-枚举"><a href="#11-1-1-2-枚举" class="headerlink" title="11.1.1.2 枚举"></a>11.1.1.2 枚举</h5><p>JSON Schema <code>enum</code> 关键字很难安全使用。<code>enum</code> 在不破坏向后兼容性的情况下，无法在描述服务响应的架构中向中添加新值。在这种情况下，客户端通常会拒绝其值不在所提出的模式的较早副本中的响应。这通常不是所需的行为。客户端通常应该更轻松地处理未知值，但是由于您无法控制或验证其行为，因此添加新的枚举值并不安全。</p>
<p>由于上述原因，架构作者在使用 <code>enum</code> JSON类型的时必须遵守以下准则 <code>string</code> 。</p>
<ul>
<li>关键字 <code>enum</code> 应该仅在固定的一组值时使用，以后再也不会更改。</li>
<li>如果您预计 <code>enum</code> 将来会向数组添加新值，请避免使用关键字 <code>enum</code> 。您应该改用一种 <code>string</code> 类型，并为记录所有可接受的值 <code>string</code> 。当使用 <code>string</code> 类型表示枚举值时，应通过字段强制执行<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md#enum-names">命名约定</a><code>pattern</code>。</li>
<li>如果没有技术上的理由（例如，一个较小的现有数据库列） <code>maxLength</code> 应设置为 255 。<code>minLength</code> 应设置为1以防止客户端发送空字符串。</li>
<li><code>enum</code> 在文档中应精确定义字段的所有可能值。如果 <code>description</code> 字段中没有足够的空间来执行此操作，则应使用API的用户指南进行定义。</li>
</ul>
<p>下面给出的是用于强制命名约定和长度约束的JSON代码段。</p>
<h5 id="11-1-1-3-数值"><a href="#11-1-1-3-数值" class="headerlink" title="11.1.1.3 数值"></a>11.1.1.3 数值</h5><p><code>number</code>JSON中的类型有很多问题。</p>
<p>JSON 本身定义了一个非常简单的值 <code>number</code> ：它是一个无界的定点值。这是由铁路图所示以及用于<code>number</code>在<a href="http://json.org/">JSON</a>。<code>number</code>JSON中只有一种类型；没有单独的<code>integer</code>类型。</p>
<p>JSON模式与JSON不同，并定义了两种数字类型： <code>number</code>和<code>integer</code> 。纯粹是为了方便模式验证。 JSON 数字类型用于实现两者。就像 JSON 中一样，除非模式作者提供显式 <code>minimum</code> 和 <code>maximum</code> 值，否则这两种类型都是不受限制的。</p>
<p>许多编程语言不能安全地处理 JSON 中的无界值。 JavaScript 是一个很好的例子。JSON 解析器是 <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript</a> 规范的一部分。但是，它要求将所有 JSON 数字反序列化为JavaScript 支持的唯一类型 -64 位浮点数 <code>number</code>。这意味着在 JavaScript 客户端中尝试反序列化大于约 2^53 的任何 JSON 数字将导致异常。</p>
<p>为了确保最大程度的跨客户端兼容性，模式作者应：</p>
<ul>
<li>切勿使用JSON模式 <code>number</code> 类型。某些语言可能会将其解释为定点值，而某些语言可能会将其解释为浮点数。始终用于 <code>string</code> 表示十进制值。</li>
<li>仅定义 <code>integer</code> 可以用32位带符号整数表示的值的类型，即（ <code>(2^31) - 1) and -(2^31</code> ）之间的值。这样可以确保在多种编程语言和环境中的兼容性。例如，JavaScript中的数组索引是带符号的32位整数。</li>
<li>使用<code>integer</code>类型时，请始终提供明确的最小值和最大值。这不仅可以检测到向后不兼容的更改，还可以确保所有值都可以容纳在32位带符号整数中。如果没有其他技术原因，则将 <code>maximum</code> 和 <code>minimum</code> 分别定义为 <code>2147483647 (((2^31) - 1))</code> 和 <code>-2147483648 (-(2^31))</code> 或 <code>0</code> 。应该使用常识来确定是否允许使用负值。通常不应使用将来可能发生变化的业务逻辑来确定界限；业务规则可以轻松更改并破坏向后兼容性。</li>
</ul>
<p>如果现在或将来有可能无法用带符号的 32 位整数表示该值，请不要使用 JSON 模式 <code>integer</code> 类型。请 <code>string</code> 改用。</p>
<p><strong>例子</strong>:</p>
<p>此 <code>integer</code> 类型可能用于定义数组索引或页数，或者可能定义了开设帐户的月数。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;maximum&quot;</span>: <span class="number">2147483647</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>string</code> 类型表示数字时，作者必须使用 <code>minLength</code> 和提供字号边界 <code>maxLength</code>，并限制字符串的定义以仅使用数字表示数字 <code>pattern</code> 。</p>
<p>例如，此定义仅允许正整数和零，最大值为999999：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span>: <span class="string">&quot;^[0-9]+$&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minLength&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;maxLength&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下定义允许以正数或负数表示定点十进制值，最大长度为32，并且对比例没有要求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pattern&quot;</span>: <span class="string">&quot;^(-?[0-9]+|-?([0-9]+)?[.][0-9]+)$&quot;</span></span><br><span class="line">    <span class="string">&quot;maxLength&quot;</span>: <span class="number">32</span>,</span><br><span class="line">    <span class="attr">&quot;minLength&quot;</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-1-1-4-数组"><a href="#11-1-1-4-数组" class="headerlink" title="11.1.1.4 数组"></a>11.1.1.4 数组</h5><p>JSON 定义 <code>array</code> 为无界。</p>
<p>尽管由于内存限制，实际的限制通常要低得多，但是许多编程语言的确对数组的大小设置了最大的理论限制。例如， ECMA-262 规范将 JavaScript 限制为 32位 无符号整数的长度。 Java 被<a href="https://stackoverflow.com/questions/3038392/do-java-arrays-have-a-maximum-size#3039805">限制为 <code>Integer.MAX_VALUE - 8</code></a>。</p>
<p>为了确保跨语言的最大兼容性并鼓励使用分页的 API ，<code>maxItems</code> 应始终由架构作者定义。 <code>maxItems</code> 不应具有大于 16 位有符号整数（ <code>32767</code> 即或）可以表示的值 <code>(2^15) - 1)</code> 。</p>
<p>注意，开发人员可以选择设置较小的值。 当没有更好的选择可用时， <code>32767</code> 该值是默认选择。但是，开发人员应该设计 API 时应兼顾未来数据的增长。例如，尽管现在分页的 API 最多每页最多只能支持 100 个结果，但是性能改进可以使开发人员在明年将其提高到 1,000 个结果。因此， <code>maxItems</code> 不应用于是最大页面大小。</p>
<p><code>minItems</code> 可以定义。在大多数情况下，其值为<code>0</code>或<code>1</code>。</p>
<h5 id="11-1-1-5-空值"><a href="#11-1-1-5-空值" class="headerlink" title="11.1.1.5 空值"></a>11.1.1.5 空值</h5><p>API 不得生成或使用 <code>null</code> 值。</p>
<p><code>null</code> 是JSON中的原始类型。当根据 JSON Schema 验证 JSON 文档时，只有在模式明确允许的情况下，使用 <code>type</code> 关键字(例如 <code>&#123;&quot;type&quot;: &quot;null&quot;&#125;</code> )，属性的值才能为 <code>null</code> 。由于在 API  中， <code>type</code> 将始终用来定义其他值，例如 <code>object</code> 或 <code>string</code> ，并且这些标准禁止使用架构组合关键字（例如 <code>anyOf</code> 或 <code>oneOf</code> ，它允许多种类型），如果 API 产生或出现空值，则根据 API 本身的架构，这实际上不太可能是有效数据。</p>
<p>另外，在 JSON 中，对象不应有被定义为 <code>undefined</code> 的属性；这在概念上与用 <code>null</code> 值定义的属性是分离的，但是许多编程语言都难以区分这种区别。</p>
<p>例如，被定义为 <code>&#123;&quot;type&quot;: &quot;null&quot;&#125;</code> 的属性 <code>myProperty</code> 可以表示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;myProperty&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果属性被定义为 <code>undefined</code> 则不会出现在对象中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>在大多数强类型化语言（例如Java）中，没有 <code>undefined</code> 类型的概念，这意味着对于JSON对象中所有未定义的字段，反序列化器将返回此类类型的值，如 <code>null</code> 您尝试检索它们的值。同样， <code>null</code> 即使基于序列化程序无法确定用于该属性的 Java 对象的作者是使用值定义 <code>null</code> 还是简单地定义，某些基于 Java 的 JSON 序列化程序默认将字段序列化为 JSON 。例如，在 Jackson 中，通过使用<a href="https://fasterxml.github.io/jackson-annotations/javadoc/2.8/com/fasterxml/jackson/annotation/JsonInclude.html"><code>JsonInclude</code></a>注释来缓和这种行为。另一方面， org.json 库定义了一个名为 <a href="https://stleary.github.io/JSON-java/org/json/JSONObject.html#NULL">NULL</a> 的对象以区分 <code>null</code> 和 <code>undefined</code> 。</p>
<p>完全避免使用 JSON null 可以帮助避免许多这些细微的跨语言兼容性陷阱。</p>
<h5 id="11-1-1-6-其他"><a href="#11-1-1-6-其他" class="headerlink" title="11.1.1.6 其他"></a>11.1.1.6 其他</h5><p>在模式对象中设置 <a href="http://json-schema.org/latest/json-schema-validation.html#anchor134"><code>additionalProperties</code></a>为 <code>false</code> 会破坏那些使用 API 的 JSON 模式（由其合同定义）来验证 API请求和响应的客户端的向后兼容性。出于相同的原因，模式创建者务必不得将明确设置 <code>additionalProperties</code> 为 <code>false</code> 。</p>
<p>相反， API 实现应通过在运行时根据已定义的API合同对请求和响应进行严格验证来强制要求和对API合同的响应。</p>
<h4 id="11-1-2-常见类型"><a href="#11-1-2-常见类型" class="headerlink" title="11.1.2 常见类型"></a>11.1.2 常见类型</h4><p>API中的资源表示必须在可能的情况下重用<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04">公共数据类型</a>定义。以下各节提供了有关其中一些常见类型的一些详细信息。有关更多详细信息，请参考<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04/README.md"><code>README</code></a>和<a href="https://github.com/paypal/api-standards/blob/master/v1/schema/json/draft-04">模式</a>。</p>
<h5 id="11-1-2-1-日期，时间和时区"><a href="#11-1-2-1-日期，时间和时区" class="headerlink" title="11.1.2.1 日期，时间和时区"></a>11.1.2.1 日期，时间和时区</h5><p>处理日期和时间时，所有 API 都必须遵守以下准则。</p>
<ul>
<li>日期和时间字符串必须符合 <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC3339</a> <code>5.6</code> 节中定义 <code>date-time</code> 的格式。在用例中，您仅需要 RFC3339 格式的字段的子集（例如 <code>full-date</code> 或 <code>full-time</code> ）。</li>
<li>所有 API 必须在响应只使用 <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a> 时间（也叫 <a href="https://en.wikipedia.org/wiki/List_of_military_time_zones">名祖鲁时间</a> 或 <a href="https://en.wikipedia.org/wiki/Greenwich_Mean_Time">GMT</a> ）。</li>
<li>处理请求时， API 应该接受 <code>date-time</code> 或包含 UTC 偏移量的时间字段。例如， <code>2016-09-28T18:30:41.000+05:00</code> 应该接受与等效 <code>2016-09-28T13:30:41.000Z</code> 。这有助于确保与在发送请求之前可能无法将值归一化为 UTC 的第三方的兼容性。在这种情况下，偏移量应仅用于计算等效的 UTC 时间，然后再将其保留在系统中（由于已知的平台/语言/数据库互操作性问题）。 UTC 偏移不得衍生其他任何内容。</li>
<li>如果业务逻辑要求表达事件的时区，建议您使用单独的请求/响应字段来显式获取时区。您不应该使用 offset 来获取时区信息。仅靠偏移量不足以将存储的 UTC 时间准确地转换回以后的本地时间。原因是许多地区的 UTC 偏移量可能相同，并且根据一年中的时间，可能还有其他因素，例如夏令时。例如，偏移量 <code>UTC-05:00</code> 代表冬季的东部标准时间，夏季的中部夏令时间，以及巴拿马，哥伦比亚和秘鲁的全年偏移量。</li>
<li>时区字符串务必是每个 <a href="https://www.iana.org/time-zones">IANA 时区数据库</a>（又名 <strong>Olson</strong> 数据库， <strong>tzdata</strong> 或 <strong>zoneinfo</strong> 数据库），例如，太平洋时间的 <code>America/ Los_Angeles</code> ，中欧的 <code>Europe/Berlin</code> 时间。</li>
<li>当在请求或响应中表达与特定时区（例如用户的出生日期，到期日期，发布日期等）无关的<a href="https://www.w3.org/International/wiki/FloatingTime">浮点时间</a>值时， API 不应将其与时区相关联。原因是 UTC 偏移会更改浮动时间值的含义。例如，所有时区在本初子午线以西的国家都将浮点时间值视为前一天。</li>
</ul>
<h2 id="12-版本化"><a href="#12-版本化" class="headerlink" title="12. 版本化"></a>12. 版本化</h2><p>API 的版本控制必须遵循一下原则：</p>
<ul>
<li>API 规范必须遵循版本控制方案，在版本号 <code>v1.2</code> 中，第一个数字是主版本号，第二个数字是次版本号</li>
<li>每当对 API 进行增量更改时，无论是否向后兼容，都必须对 API 规范进行版本控制。这允许对变更进行标记、记录、评审、讨论、发布和交流。</li>
<li>API 地址只能反映主要版本。</li>
<li>API 版本反映了接口更改，可以与服务版本控制方案分开。</li>
<li>次要 API 版本必须保持与同一主要版本中所有以前的次要版本的向后兼容性。</li>
<li>主要的API版本可以保持与先前主要版本的向后兼容性。</li>
</ul>
<h3 id="12-1-向后兼容"><a href="#12-1-向后兼容" class="headerlink" title="12.1 向后兼容"></a>12.1 向后兼容</h3><p>API 应该以向前和可扩展的方式进行设计，以保持兼容性并避免资源，功能和过多版本控制的重复。</p>
<p>API必须遵循以下原则才能被认为是向后兼容的：</p>
<ul>
<li>所有修改都必须包含</li>
<li>所有修改都必须是可选的</li>
<li>语义一定不能改变</li>
<li>查询参数和请求主题参数必须无序</li>
<li>必须为现有资源实现其他功能<ul>
<li>作为可选扩展，或</li>
<li>作为对新子资源的操作，或</li>
<li>如果不能合理扩展现有操作（例如：创建资源），则通过更改请求主题，同时仍然可以接受先前所有存在的请求变化</li>
</ul>
</li>
</ul>
<h2 id="13-异步处理"><a href="#13-异步处理" class="headerlink" title="13. 异步处理"></a>13. 异步处理</h2><h3 id="13-1-上下文问题"><a href="#13-1-上下文问题" class="headerlink" title="13.1 上下文问题"></a>13.1 上下文问题</h3><p>在现代应用程序开发中，客户端应用程序（通常在 Web 客户端（浏览器）中运行的代码）依赖远程 API 来提供业务逻辑和组合功能是很正常的。这些API可能与应用程序直接相关，也可能是第三方提供的共享服务。通常，这些API调用通过HTTP（S）协议进行，并遵循REST语义。</p>
<p>在大多数情况下，客户端应用程序的API被设计为可快速响应，数量级为100毫秒或更短。许多因素都会影响响应延迟，包括：</p>
<ul>
<li>应用程序的托管堆栈。</li>
<li>安全组件。</li>
<li>调用者和后端的相对地理位置。</li>
<li>网络基础设施。</li>
<li>当前负载。</li>
<li>请求有效负载的大小。</li>
<li>处理队列长度。</li>
<li>后端处理请求的时间。</li>
</ul>
<p>这些因素中的任何一个都会增加响应的延迟。通过扩展后端可以缓解某些问题。其他诸如网络基础结构之类的应用程序在很大程度上不受应用程序开发人员的控制。大多数API可以足够迅速地做出响应，以使响应可以通过同一连接返回。应用程序代码可以以非阻塞方式进行同步API调用，从而呈现出异步处理的外观，建议对I / O绑定操作进行异步处理。</p>
<p>但是，在某些情况下，后端完成的工作可能会耗时数秒，或者可能是在几分钟甚至几小时内执行的后台进程。在这种情况下，在响应请求之前等待工作完成是不可行的。对于任何同步请求-应答模式，这种情况都是潜在的问题。</p>
<p>一些体系结构通过使用消息代理来分隔请求和响应阶段来解决此问题。通常通过使用<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling">基于队列的负载均衡模式</a>来实现这种分离。这种分离可以允许客户端进程和后端API独立扩展。但是，当客户端需要成功通知时，这种分离也会带来额外的复杂性，因为此步骤需要变得异步。</p>
<p>针对客户端应用程序讨论的许多相同考虑因素，也适用于分布式系统（例如，微服务体系结构）中的服务器到服务器REST API调用。</p>
<h3 id="13-2-解决方法"><a href="#13-2-解决方法" class="headerlink" title="13.2 解决方法"></a>13.2 解决方法</h3><p>解决此问题的一种方法是使用HTTP轮询。轮询对客户端代码很有用，因为很难提供回调端点或使用长时间运行的连接。即使可能进行回调，有时所需的额外库和服务也会增加过多的额外复杂性。</p>
<ul>
<li><p>客户端应用程序对API进行同步调用，从而在后端触发长时间运行的操作。</p>
</li>
<li><p>API尽可能快地同步响应。它返回HTTP 202（已接受）状态码，确认已接收到请求进行处理。</p>
</li>
<li><p>该响应包含指向客户端可以轮询以检查长期运行结果的端点的位置引用。</p>
</li>
<li><p>API将处理工作转移到另一个组件，例如消息队列。</p>
</li>
<li><p>在工作仍处于待处理状态时，状态端点将返回HTTP202。完成工作后，状态端点可以返回指示完成的资源，或重定向到另一个资源URL。例如，如果异步操作创建了新资源，则状态端点将重定向到该资源的URL。</p>
</li>
</ul>
<p><img src="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/async-request.png" alt="异步HTTP请求的请求和响应流"></p>
<ol>
<li>客户端发送请求并接收HTTP 202（已接受）响应。</li>
<li>客户端将HTTP GET请求发送到状态端点。工作仍在进行中，因此此调用还返回HTTP 202。</li>
<li>在某个时候，工作完成，状态端点返回302（已找到），重定向到资源。</li>
<li>客户端通过指定的URL获取资源。</li>
</ol>
<p>您应该公开一个返回异步请求状态的终结点，以便客户端可以通过轮询状态终结点来监视状态。在202响应的Location标头中包含状态终结点的URI。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line">Location: /api/status/12345</span><br></pre></td></tr></table></figure>

<p>如果客户端向该端点发送GET请求，则响应应包含请求的当前状态。可选地，它还可以包括估计的完成时间或取消操作的链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;:&quot;In progress&quot;,</span><br><span class="line">    &quot;link&quot;: &#123; &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;:&quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果异步操作创建了新资源，则在操作完成后，状态端点应返回状态代码303（请参阅其他）。在303响应中，包含一个Location标头，该标头给出了新资源的URI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">Location: /api/orders/12345</span><br></pre></td></tr></table></figure>

<h2 id="14-Webhooks"><a href="#14-Webhooks" class="headerlink" title="14. Webhooks"></a>14. Webhooks</h2><h3 id="14-1-范围"><a href="#14-1-范围" class="headerlink" title="14.1 范围"></a>14.1 范围</h3><p>服务可以通过网络挂钩实现推送通知。本节介绍以下关键方案：</p>
<blockquote>
<p>通过HTTP回调（通常称为Web挂钩）将通知推送到可公开寻址的服务器。</p>
</blockquote>
<p>选择该方法的原因是它的简单性，广泛的适用性以及服务订户进入的门槛低。它仅作为最低要求，也是其他功能的起点。</p>
<h3 id="14-2原则"><a href="#14-2原则" class="headerlink" title="14.2原则"></a>14.2原则</h3><p>支持Web挂钩的服务的核心原则是：</p>
<ol>
<li>服务必须至少实现戳/拉模型。在戳/拉模型中，将通知发送给客户端，然后客户端发送请求以获取当前状态或自上次通知以来的更改记录。这种方法避免了消息排序，遗漏消息和变更集的复杂性。服务可以添加更多数据以提供丰富的通知。</li>
<li>服务必须实现用于配置回调URL的质询/响应协议。</li>
<li>服务应有一个建议的过期期限，并应根据情况灵活调整服务。</li>
<li>服务应该允许发出成功通知的订阅永久存在，并且应该容忍合理的中断时间。</li>
<li>Firehose订阅必须仅通过HTTPS交付。服务应该要求其他订阅类型为HTTPS。有关更多详细信息，请参见“安全性”部分。</li>
</ol>
<h3 id="14-3订阅类型"><a href="#14-3订阅类型" class="headerlink" title="14.3订阅类型"></a>14.3订阅类型</h3><p>订阅有两种类型，服务可以既实现又不实现。支持的订阅类型为：</p>
<ol>
<li>Firehose订阅–通常在应用程序注册门户中为订阅应用程序手动创建订阅。任何用户已同意接收应用程序的活动通知将发送到此单个订阅。</li>
<li>每个资源的订阅–订阅应用程序使用代码在运行时以编程方式为某些特定于用户的实体创建订阅。</li>
</ol>
<p>同时支持两种订阅类型的服务应为两种类型提供差异化的开发人员体验：</p>
<ol>
<li>Firehose –服务必须不要求开发人员创建代码，除非直接验证并响应通知。服务必须提供用于订阅管理的管理UI。服务不应假设最终用户知道订阅，而只能假设订阅应用程序的功能。</li>
<li>每用户–服务必须为开发人员提供一个API，以作为其应用程序的一部分来创建和管理订阅以及验证和响应通知。服务可能希望最终用户意识到订阅，并且必须允许最终用户撤销在直接响应用户操作而创建的订阅。</li>
</ol>
<h3 id="14-4调用顺序"><a href="#14-4调用顺序" class="headerlink" title="14.4调用顺序"></a>14.4调用顺序</h3><p>订阅 firehose 的调用顺序必须遵循下图。它显示了应用程序和订阅的手动注册，然后是最终用户使用服务的API之一。在流程的这一部分，必须存储两件事：</p>
<ol>
<li>服务必须存储最终用户同意从该特定应用程序接收通知的行为（通常是后台使用OAUTH范围）。</li>
<li>订阅应用程序必须存储最终用户的令牌，以便在收到更改通知后回调详细信息。</li>
</ol>
<p>序列的最后一部分是通知流本身。</p>
<p>非规范实施指南：服务中的资源发生更改，并且该服务需要运行以下逻辑：</p>
<ol>
<li>确定有权访问资源的用户集合，从而可以期望应用程序代表他们接收有关资源的通知。</li>
<li>查看哪些用户已同意接收通知，以及从哪些应用程序。</li>
<li>查看哪些应用程序已注册firehose订阅。</li>
<li>加入1、2、3以产生必须发送到应用程序的具体通知集。</li>
</ol>
<p>应该注意的是，用户同意的行为和建立firehose订阅的行为可以以任何顺序到达。服务应发送通知，并以两种顺序处理设置。</p>
<p><a href="https://camo.githubusercontent.com/df0495791d84a25a2285a6cc1071cafba58efcef/687474703a2f2f7777772e77656273657175656e63656469616772616d732e636f6d2f6367692d62696e2f63647261773f6c7a3d626d39305a534276646d56794945526c646d56736233426c63697767515856306232316864476c76626977675158427749464e6c636e5a6c636a6f67436941674943416751573441454155414a776b6762476c725a53424e62335a705a55316861325679414341475632467564484d6764473867615735305a5764795958526c494864706447676763484a70625746796553427a5a584a3261574e6c4144634752484a7663474a766541706c626d5167626d39305a516f416751774c5169425162334a3059577773494552434149454a42564a6c5a326c7a6448494167526b4852454967546d393061575a70597743424c41567a414345476458526f4143734655774267426a6f675647686c414630654149465f436b4e736157567564414174426d56755a4342316332567963796367596e4a7664334e6c6369427663694270626e4e30595778735a5751675958427743674342495177416769516741494641425143424953384167516f4749446f6754574675645746734149467a45516f4b4367434441676f384c53302d4149497143694136494578765a326c7549476c7564473841676a384a41494931454342565743414b41436f4b4c5434674b77434357424d364149514742553568625755675a58526a4c6743444651344147784a446232356d61584a74414945424345466a5932567a637942556232746c62676f4b41494d33457941745069417441494e6b4351426e426b6c454149454d43774342565155416851494d41495233436d4e7663476c6c63774172434143434948414168484d4d41494d4b44774344414267364948646c596d6876623273676367434365673441676e55534149565144546f41685859485a584941677767474149635442674245435656535443776755324e7663475541687a49475355514b54674347505177416868774e4941434442683441486845416778455062674342616777416778774e41494d61446941416778304d6257463549474e7663486b414c5245416856747141495a484230463164476876636d6c36414959374277434758516374506941724149457544564a6c6358566c63335167595143464f515a306279424551694277636d39305a574e305a5751676157356d62334941696951474367434442517374506941744149637443564a6c5a476c795a574e30414459484147774e494756755a4842766157353041496f57426d45414477317941485947414945514441434a564163415377746c5a41415948674349434167414d4163416341344168476f474145304641494564466d4a6859327367644738416846384e6158526f49474e765a47554167686f61615143426167634167546f484144304a4149492d42334d4150677341676c4548414573464149497a4467434258773041676e3847644739725a57357a414363534149305f42584a705a3268304947396d4149747044554e685932686c4948526f5958516764476870637942566332567949456c454948427962335a705a47566b41494e4e437743495a676f416767634a41494e3744334e776232357a4149305f427743454367597349484a6c5a6e4a6c63326773494746755a43424a524143424841634167514d5041495941445143424441634167555547596e6b416a466b4649456c454149516b47335231636d34416846344d4948527649474d416a523846414977526167434a5677314762473933414959714351434d61516741676d6f4b614746755a3255416a3359464149465842575268644745674c534230655842705932467349485a70595143514467567959574e306157356e414a41504267434a51517432615745416a6e7348436743504e676f67414968444541434b5a7730416b464d4641496b424477434444415541676b59574b77424e437743485741706a4149457942514348526730416857554859574e6f414951654441434566775668626d5167496e4e70626d4e6c49674346455159416b53514f414952334367434e66776341684851464149705145414342556773416846416341494938425746755a4342755a58634159525141684655544f6942566347526864475567633352686448554167536b47414946444251417845776f4b436726733d6d736367656e"><img src="https://camo.githubusercontent.com/df0495791d84a25a2285a6cc1071cafba58efcef/687474703a2f2f7777772e77656273657175656e63656469616772616d732e636f6d2f6367692d62696e2f63647261773f6c7a3d626d39305a534276646d56794945526c646d56736233426c63697767515856306232316864476c76626977675158427749464e6c636e5a6c636a6f67436941674943416751573441454155414a776b6762476c725a53424e62335a705a55316861325679414341475632467564484d6764473867615735305a5764795958526c494864706447676763484a70625746796553427a5a584a3261574e6c4144634752484a7663474a766541706c626d5167626d39305a516f416751774c5169425162334a3059577773494552434149454a42564a6c5a326c7a6448494167526b4852454967546d393061575a70597743424c41567a414345476458526f4143734655774267426a6f675647686c414630654149465f436b4e736157567564414174426d56755a4342316332567963796367596e4a7664334e6c6369427663694270626e4e30595778735a5751675958427743674342495177416769516741494641425143424953384167516f4749446f6754574675645746734149467a45516f4b4367434441676f384c53302d4149497143694136494578765a326c7549476c7564473841676a384a41494931454342565743414b41436f4b4c5434674b77434357424d364149514742553568625755675a58526a4c6743444651344147784a446232356d61584a74414945424345466a5932567a637942556232746c62676f4b41494d33457941745069417441494e6b4351426e426b6c454149454d43774342565155416851494d41495233436d4e7663476c6c63774172434143434948414168484d4d41494d4b44774344414267364948646c596d6876623273676367434365673441676e55534149565144546f41685859485a584941677767474149635442674245435656535443776755324e7663475541687a49475355514b54674347505177416868774e4941434442683441486845416778455062674342616777416778774e41494d61446941416778304d6257463549474e7663486b414c5245416856747141495a484230463164476876636d6c36414959374277434758516374506941724149457544564a6c6358566c63335167595143464f515a306279424551694277636d39305a574e305a5751676157356d62334941696951474367434442517374506941744149637443564a6c5a476c795a574e30414459484147774e494756755a4842766157353041496f57426d45414477317941485947414945514441434a564163415377746c5a41415948674349434167414d4163416341344168476f474145304641494564466d4a6859327367644738416846384e6158526f49474e765a47554167686f61615143426167634167546f484144304a4149492d42334d4150677341676c4548414573464149497a4467434258773041676e3847644739725a57357a414363534149305f42584a705a3268304947396d4149747044554e685932686c4948526f5958516764476870637942566332567949456c454948427962335a705a47566b41494e4e437743495a676f416767634a41494e3744334e776232357a4149305f427743454367597349484a6c5a6e4a6c63326773494746755a43424a524143424841634167514d5041495941445143424441634167555547596e6b416a466b4649456c454149516b47335231636d34416846344d4948527649474d416a523846414977526167434a5677314762473933414959714351434d61516741676d6f4b614746755a3255416a3359464149465842575268644745674c534230655842705932467349485a70595143514467567959574e306157356e414a41504267434a51517432615745416a6e7348436743504e676f67414968444541434b5a7730416b464d4641496b424477434444415541676b59574b77424e437743485741706a4149457942514348526730416857554859574e6f414951654441434566775668626d5167496e4e70626d4e6c49674346455159416b53514f414952334367434e66776341684851464149705145414342556773416846416341494938425746755a4342755a58634159525141684655544f6942566347526864475567633352686448554167536b47414946444251417845776f4b436726733d6d736367656e" alt="Firehose订阅设置"></a></p>
<p>对于每个用户的订阅，应用程序注册可以手动或自动进行。每个用户订阅的调用流程必须遵循下图。它显示了最终用户使用服务的API之一，并且同样，必须存储相同的两件事：</p>
<ol>
<li>服务必须存储最终用户同意从该特定应用程序接收通知的行为（通常是后台使用OAUTH范围）。</li>
<li>订阅应用程序必须存储最终用户的令牌，以便在收到更改通知后回调详细信息。</li>
</ol>
<p>在这种情况下，使用来自订阅应用程序的最终用户令牌以编程方式设置订阅。应用程序必须将注册订阅的ID与用户令牌一起存储。</p>
<p>非规范性实施指南：在序列的最后部分，当服务中的数据项发生更改并且服务需要运行以下逻辑时：</p>
<ol>
<li>查找通过资源与已更改数据相对应的一组预订。</li>
<li>对于使用app + user令牌创建的订阅，请使用订阅创建者的订阅ID和用户ID向每个订阅发送通知给应用。</li>
</ol>
<ul>
<li><p>对于使用仅应用令牌创建的订阅，请检查已更改数据的所有者或具有已更改数据可见性的任何用户均已同意向该应用发送通知，如果是，则按用户ID向该应用发送一组通知带有订阅ID的订阅。</p>
<p><a href="https://camo.githubusercontent.com/de3129ed4573bcc492e23ba013ba4c370d00facf/687474703a2f2f7777772e77656273657175656e63656469616772616d732e636f6d2f6367692d62696e2f63647261773f6c7a3d626d39305a534276646d56794945526c646d56736233426c63697767515856306232316864476c76626977675158427749464e6c636e5a6c636a6f67436941674943416751573441454155414a776b6762476c725a53424e62335a705a55316861325679414341475632467564484d6764473867615735305a5764795958526c494864706447676763484a70625746796553427a5a584a3261574e6c4144634752484a7663474a766541706c626d5167626d39305a516f416751774c5169425162334a3059577773494552434149454a42564a6c5a326c7a6448494167526b4852454967546d393061575a70597743424c41567a414345476458526f4143734655774267426a6f675647686c414630654149465f436b4e736157567564414174426d56755a4342316332567963796367596e4a7664334e6c6369427663694270626e4e30595778735a5751675958427743674342495177416769516741494641425143424953384167516f4749446f416757775243677068624851416779554941494548426942794142514d494341416778734c50433074506743445477733649454e76626d5a705a3356795a516f6749414344614173674c5434674b77434357424d4165675a4f5957316c49475630597934416841674641494d61445141664567426442584a744149515f4255466a5932567a637942556232746c41494554426743444f7849674c5434674c5143424667784263484167535551416848774959334a6c644143424778417450674346466773674f69424662574a6c5a41416b46475673633255675457467564574673414949454a41434562516b674f69424d6232647062694270626e527641495542435143424b52465657414347474155414c516f416768386d4149495a4b77434243416341676a6f4e41494973484143474c776b41676a38494149455344674345434159416831454c41496446436d4e7663476c6c63774175434756755a41434565476f4168575148515856306147397961586f4168563848414956364279302d494373416732414e556d56786457567a6443426841495256426e527649455243494842796233526c5933526c5a434270626d5a766367434a5151594b414951614379302d49433041686b6f4a556d566b61584a6c593351414e676341624130675a57356b63473970626e514169544d475951415044584941646759416752414d414968784277424c4332566b414267654149526a43414177423045416351785657416f415351674167527757596d466a617942306277434664417741696c77465932396b5a5143434752707041494670427743424f51634150516b41676a30486377412d437743435541634153775541676a494f414946654451434366675a306232746c626e4d414a7849416a467346636d6c6e61485167623259416977554e5132466a61475567644768686443423061476c7a4946567a5a5849675355516763484a76646d6c6b5a5751416730774c41495536427743434241774167336f5063334276626e4d416a4673484149514a42697767636d566d636d567a614377675957356b49456c454149456342774342417738416944454e4149454d4277434252515a696551434c645155675355514168434d62644856796267434558517767644738675977434d4f77554b4367434c4c326f416a58554d41497754447743504e516f74506973416a6877514f67434f5251646c6367434d56775941673359495a574a6f62323972494656535443776755324e76634755416b414547535551416a776f4f41493572445341416932554b41494e464251434c5977304148424541677a554f4f6942754149453244414267434143444342316f5a5143426151354a52414344597755416168494167684234526d78766477434a4d776b416a45304941495630436d6868626d646c414a4963425143455951566b595852684943306764486c7761574e6862434232615745416b6a5146636d466a64476c755a7743534e5159416a56384c646d6c68414a456842776f416b56774b4941434e666841416841734e414a4a35425143435751384168685946414956514669734154517341696d454b597743424d675541696b384e414968764232466a614143484b41774169416b465957356b49434a7a6157356a5a53494169427347414a4e4b4467434941516f4168423063414946534377434857687741676a77465957356b4947356c647742684641434858784d36494656775a4746305a53427a64474630645143424b51594167554d464144455443676f4b26733d6d736367656e"><img src="https://camo.githubusercontent.com/de3129ed4573bcc492e23ba013ba4c370d00facf/687474703a2f2f7777772e77656273657175656e63656469616772616d732e636f6d2f6367692d62696e2f63647261773f6c7a3d626d39305a534276646d56794945526c646d56736233426c63697767515856306232316864476c76626977675158427749464e6c636e5a6c636a6f67436941674943416751573441454155414a776b6762476c725a53424e62335a705a55316861325679414341475632467564484d6764473867615735305a5764795958526c494864706447676763484a70625746796553427a5a584a3261574e6c4144634752484a7663474a766541706c626d5167626d39305a516f416751774c5169425162334a3059577773494552434149454a42564a6c5a326c7a6448494167526b4852454967546d393061575a70597743424c41567a414345476458526f4143734655774267426a6f675647686c414630654149465f436b4e736157567564414174426d56755a4342316332567963796367596e4a7664334e6c6369427663694270626e4e30595778735a5751675958427743674342495177416769516741494641425143424953384167516f4749446f416757775243677068624851416779554941494548426942794142514d494341416778734c50433074506743445477733649454e76626d5a705a3356795a516f6749414344614173674c5434674b77434357424d4165675a4f5957316c49475630597934416841674641494d61445141664567426442584a744149515f4255466a5932567a637942556232746c41494554426743444f7849674c5434674c5143424667784263484167535551416848774959334a6c644143424778417450674346466773674f69424662574a6c5a41416b46475673633255675457467564574673414949454a41434562516b674f69424d6232647062694270626e527641495542435143424b52465657414347474155414c516f416768386d4149495a4b77434243416341676a6f4e41494973484143474c776b41676a38494149455344674345434159416831454c41496446436d4e7663476c6c63774175434756755a41434565476f4168575148515856306147397961586f4168563848414956364279302d494373416732414e556d56786457567a6443426841495256426e527649455243494842796233526c5933526c5a434270626d5a766367434a5151594b414951614379302d49433041686b6f4a556d566b61584a6c593351414e676341624130675a57356b63473970626e514169544d475951415044584941646759416752414d414968784277424c4332566b414267654149526a43414177423045416351785657416f415351674167527757596d466a617942306277434664417741696c77465932396b5a5143434752707041494670427743424f51634150516b41676a30486377412d437743435541634153775541676a494f414946654451434366675a306232746c626e4d414a7849416a467346636d6c6e61485167623259416977554e5132466a61475567644768686443423061476c7a4946567a5a5849675355516763484a76646d6c6b5a5751416730774c41495536427743434241774167336f5063334276626e4d416a4673484149514a42697767636d566d636d567a614377675957356b49456c454149456342774342417738416944454e4149454d4277434252515a696551434c645155675355514168434d62644856796267434558517767644738675977434d4f77554b4367434c4c326f416a58554d41497754447743504e516f74506973416a6877514f67434f5251646c6367434d56775941673359495a574a6f62323972494656535443776755324e76634755416b414547535551416a776f4f41493572445341416932554b41494e464251434c5977304148424541677a554f4f6942754149453244414267434143444342316f5a5143426151354a52414344597755416168494167684234526d78766477434a4d776b416a45304941495630436d6868626d646c414a4963425143455951566b595852684943306764486c7761574e6862434232615745416b6a5146636d466a64476c755a7743534e5159416a56384c646d6c68414a456842776f416b56774b4941434e666841416841734e414a4a35425143435751384168685946414956514669734154517341696d454b597743424d675541696b384e414968764232466a614143484b41774169416b465957356b49434a7a6157356a5a53494169427347414a4e4b4467434941516f4168423063414946534377434857687741676a77465957356b4947356c647742684641434858784d36494656775a4746305a53427a64474630645143424b51594167554d464144455443676f4b26733d6d736367656e" alt="用户订阅设置"></a></p>
</li>
</ul>
<h3 id="14-5验证订阅"><a href="#14-5验证订阅" class="headerlink" title="14.5验证订阅"></a>14.5验证订阅</h3><p>当订阅以编程方式更改或响应通过管理UI门户的更改时，需要保护订阅服务免受恶意或意外调用的干扰，因为这些服务可能会导致大量通知流量。</p>
<p>对于所有订阅，无论是firehose还是按用户，服务都必须在发送任何其他通知之前，通过门户网站UI或API请求发送验证请求，作为创建或修改的一部分。</p>
<p>验证请求的格式必须为订阅的<em>notificationUrl</em>的HTTP / HTTPS POST格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://&#123;notificationUrl&#125;?validationToken=&#123;randomString&#125;</span><br><span class="line">ClientState: clientOriginatedOpaqueToken (if provided by client on subscription-creation)</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p>对于要建立的订阅，应用程序必须对该请求做出200 OK的响应，并且<em>validationToken</em>值为唯一的实体主体。请注意，如果<em>notificationUrl</em>包含查询参数，则<em>validationToken</em>参数必须附加一个<code>&amp;</code>。</p>
<p>如果任何质询请求在发送请求后的5秒钟内未收到规定的响应，则该服务务必返回错误，不得创建订阅，并且不得将其他请求或通知发送给<em>notificationUrl</em>。</p>
<p>服务可以对URL所有权执行其他验证。</p>
<h3 id="14-6接收通知"><a href="#14-6接收通知" class="headerlink" title="14.6接收通知"></a>14.6接收通知</h3><p>服务应该发送通知以响应服务数据的更改，这些更改不包括更改本身的详细信息，但应包含足够的信息，以便订阅应用程序可以适当地响应以下过程：</p>
<ol>
<li>应用程序必须标识正确的缓存OAuth令牌以用于回调</li>
<li>应用程序可以查找任何先前的delta令牌以获取相关的更改范围</li>
<li>应用程序必须确定要调用的URL，以对服务的新状态执行相关查询，该查询可以是增量查询。</li>
</ol>
<p>提供通知的服务将被中继给最终用户，可以选择在通知包中添加更多细节，以减少其服务上的传入调用负载。此类服务必须明确指出，不能保证一定会发送通知，并且通知可能有损或乱序。</p>
<p>通知可以汇总并分批发送。应用程序必须准备好在单个推送通知中接收多个事件。</p>
<p>该服务务必将所有Web Hook数据通知作为POST请求发送。</p>
<p>服务必须允许30秒钟的通知超时时间。如果发生超时或应用程序以5xx响应进行响应，则服务应使用指数退避重试通知。所有其他响应将被忽略。</p>
<p>服务不得遵循301/302重定向请求。</p>
<h4 id="14-6-1通知有效负载"><a href="#14-6-1通知有效负载" class="headerlink" title="14.6.1通知有效负载"></a>14.6.1通知有效负载</h4><p>通知有效负载的基本格式是事件列表，每个事件包含订阅的ID（已更改），该订阅的参考资源已更改，更改的类型，应消耗的资源来标识更改的确切详细信息以及足够的标识信息以供查看调用该资源所需的令牌。</p>
<p>对于firehose订阅，具体示例如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;value&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;subscriptionId&quot;</span>: <span class="string">&quot;32b8cbd6174ab18b&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;https://api.contoso.com/v1.0/users/user@contoso.com/files?$delta&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;userId&quot;</span> : <span class="string">&quot;&lt;User GUID&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tenantId&quot;</span> : <span class="string">&quot;&lt;Tenant Id&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个用户的订阅，其具体示例如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;value&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;subscriptionId&quot;</span>: <span class="string">&quot;32b8cbd6174ab183&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;clientState&quot;</span>: <span class="string">&quot;clientOriginatedOpaqueToken&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;expirationDateTime&quot;</span>: <span class="string">&quot;2016-02-04T11:23Z&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;https://api.contoso.com/v1.0/users/user@contoso.com/files/$delta&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;userId&quot;</span> : <span class="string">&quot;&lt;User GUID&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tenantId&quot;</span> : <span class="string">&quot;&lt;Tenant Id&gt;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;subscriptionId&quot;</span>: <span class="string">&quot;97b391179fa22&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;clientState &quot;</span>: <span class="string">&quot;clientOriginatedOpaqueToken&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;expirationDateTime&quot;</span>: <span class="string">&quot;2016-02-04T11:23Z&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;https://api.contoso.com/v1.0/users/user@contoso.com/files/$delta&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;userId&quot;</span> : <span class="string">&quot;&lt;User GUID&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tenantId&quot;</span> : <span class="string">&quot;&lt;Tenant Id&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是JSON有效负载的详细说明。</p>
<p>通知项包含一个顶层对象，该对象包含一系列事件，每个事件都标识了由于发送此通知而导致的订阅。</p>
<table>
<thead>
<tr>
<th>领域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>自上次通知以来在订阅范围内引发的事件数组。</td>
</tr>
</tbody></table>
<p>事件数组的每一项都包含以下属性：</p>
<table>
<thead>
<tr>
<th>领域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>subscriptionId</td>
<td>已发送此通知的订阅的ID。 服务必须提供<em>subscriptionId</em>字段。</td>
</tr>
<tr>
<td>clientState</td>
<td>如果在创建订阅时提供了<em>clientState</em>字段，则服务必须提供<em>clientState</em>字段。</td>
</tr>
<tr>
<td>expirationDateTime</td>
<td>如果订阅有一个，则服务必须提供<em>expirationDateTime</em>字段。</td>
</tr>
<tr>
<td>resource</td>
<td>服务必须提供资源字段。订阅应用程序必须将该URL视为不透明。在更丰富的通知的情况下，它可以包含在消息内容中，该消息内容隐式包含资源URL，以避免重复。 如果服务将此数据作为更详细的数据包的一部分提供，则无需复制。</td>
</tr>
<tr>
<td>userId</td>
<td>服务必须为用户范围的资源提供此字段。对于用户范围的资源，应使用用户的唯一标识符。 在一组特定用户之间共享资源的情况下，必须发送多个通知，并传递每个用户的唯一标识符。 对于租户范围内的资源，应使用预订的用户ID。</td>
</tr>
<tr>
<td>tenantId</td>
<td>希望支持跨租户请求的服务应提供此字段。提供有关租户范围数据的通知的服务必须发送此字段。</td>
</tr>
</tbody></table>
<h3 id="14-7以编程方式管理订阅"><a href="#14-7以编程方式管理订阅" class="headerlink" title="14.7以编程方式管理订阅"></a>14.7以编程方式管理订阅</h3><p>对于每个用户的订阅，必须提供一个API以创建和管理订阅。API必须至少支持此处描述的操作。</p>
<h4 id="14-7-1创建订阅"><a href="#14-7-1创建订阅" class="headerlink" title="14.7.1创建订阅"></a>14.7.1创建订阅</h4><p>客户端通过对订阅资源发出POST请求来创建订阅。订阅名称空间是通过POST操作由客户端定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.contoso.com/apiVersion/$subscriptions</span><br></pre></td></tr></table></figure>

<p>POST请求包含一个要创建的订阅对象。该订阅对象具有以下属性：</p>
<table>
<thead>
<tr>
<th>物业名称</th>
<th>需要</th>
<th>笔记</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>是</td>
<td>要观看的资源路径。</td>
</tr>
<tr>
<td>notificationUrl</td>
<td>是</td>
<td>目标Web挂钩URL。</td>
</tr>
<tr>
<td>clientState</td>
<td>否</td>
<td>不透明字符串在所有通知上传递回客户端。调用者可以选择使用它来提供标记机制。</td>
</tr>
</tbody></table>
<p>如果成功创建了订阅，则服务必须使用状态代码201 CREATED和至少包含以下属性的主体进行响应：</p>
<table>
<thead>
<tr>
<th>物业名称</th>
<th>需要</th>
<th>笔记</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>是</td>
<td>新订阅的唯一ID，以后可用于更新/删除订阅。</td>
</tr>
<tr>
<td>expirationDateTime</td>
<td>否</td>
<td>使用现有的Microsoft REST API准则定义的时间格式。</td>
</tr>
</tbody></table>
<p>订阅的创建应该是幂等的。范围限定于auth令牌的属性的组合提供了唯一性约束。</p>
<p>以下是使用用户+应用程序主体订阅文件通知的示例请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1</span><br><span class="line">Authorization: Bearer &#123;UserPrincipalBearerToken&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;resource&quot;: &quot;http://api.service.com/v1.0/files/file1.txt&quot;,</span><br><span class="line">  &quot;notificationUrl&quot;: &quot;https://contoso.com/myCallbacks&quot;,</span><br><span class="line">  &quot;clientState&quot;: &quot;clientOriginatedOpaqueToken&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务应该以最小的响应格式响应这样的消息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;32b8cbd6174ab18b&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expirationDateTime&quot;</span>: <span class="string">&quot;2016-02-04T11:23Z&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用仅应用程序主体的示例，其中应用程序正在监视其授权的所有文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1</span><br><span class="line">Authorization: Bearer &#123;ApplicationPrincipalBearerToken&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;resource&quot;: &quot;All.Files&quot;,</span><br><span class="line">  &quot;notificationUrl&quot;: &quot;https://contoso.com/myCallbacks&quot;,</span><br><span class="line">  &quot;clientState&quot;: &quot;clientOriginatedOpaqueToken&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务应该以最小的响应格式响应这样的消息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;8cbd6174abb391179&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expirationDateTime&quot;</span>: <span class="string">&quot;2016-02-04T11:23Z&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-7-2更新订阅"><a href="#14-7-2更新订阅" class="headerlink" title="14.7.2更新订阅"></a>14.7.2更新订阅</h4><p>服务可以支持修改订阅。为了更新现有订阅的属性，客户端使用PATCH请求来提供ID和需要更改的属性。忽略的属性将保留其值。要删除属性，请为其分配JSON null值。</p>
<p>与创建一样，订阅是单独管理的。</p>
<p>以下请求更改现有订阅的通知URL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATCH https://api.contoso.com/files/v1.0/$subscriptions/&#123;id&#125; HTTP 1.1</span><br><span class="line">Authorization: Bearer &#123;UserPrincipalBearerToken&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;notificationUrl&quot;: &quot;https://contoso.com/myNewCallback&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果PATCH请求包含一个新的<em>notificationUrl</em>，则服务器必须如上所述对其进行验证。如果新的URL验证失败，则该服务务必使PATCH请求失败，并使订阅保持其先前状态。</p>
<p>服务必须返回一个空的主体并<code>204 No Content</code>指示补丁成功。</p>
<p>如果补丁失败，服务必须返回错误体和状态码。</p>
<p>该操作必须成功完成或失败。</p>
<h4 id="14-7-3删除订阅"><a href="#14-7-3删除订阅" class="headerlink" title="14.7.3删除订阅"></a>14.7.3删除订阅</h4><p>服务必须支持删除订阅。可以通过对订阅资源发出DELETE请求来删除现有订阅：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE https://api.contoso.com/files/v1.0/$subscriptions/&#123;id&#125; HTTP 1.1</span><br><span class="line">Authorization: Bearer &#123;UserPrincipalBearerToken&#125;</span><br></pre></td></tr></table></figure>

<p>与更新一样，服务必须返回<code>204 No Content</code>以成功删除，或者返回错误体和状态码以指示失败。</p>
<h4 id="14-7-4-枚举订阅"><a href="#14-7-4-枚举订阅" class="headerlink" title="14.7.4 枚举订阅"></a>14.7.4 枚举订阅</h4><p>为了获取活动订阅的列表，客户端使用用户+应用程序或仅应用程序承载令牌对订阅资源发出GET请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1</span><br><span class="line">Authorization: Bearer &#123;UserPrincipalBearerToken&#125;</span><br></pre></td></tr></table></figure>

<p>服务必须使用用户+应用程序主体承载令牌返回以下格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;value&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;32b8cbd6174ab18b&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot; http://api.contoso.com/v1.0/files/file1.txt&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;notificationUrl&quot;</span>: <span class="string">&quot;https://contoso.com/myCallbacks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;clientState&quot;</span>: <span class="string">&quot;clientOriginatedOpaqueToken&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;expirationDateTime&quot;</span>: <span class="string">&quot;2016-02-04T11:23Z&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用仅应用程序主体承载令牌返回的示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;value&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;6174ab18bfa22&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;All.Files &quot;</span>,</span><br><span class="line">      <span class="attr">&quot;notificationUrl&quot;</span>: <span class="string">&quot;https://contoso.com/myCallbacks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;clientState&quot;</span>: <span class="string">&quot;clientOriginatedOpaqueToken&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;expirationDateTime&quot;</span>: <span class="string">&quot;2016-02-04T11:23Z&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-8-安全性"><a href="#14-8-安全性" class="headerlink" title="14.8 安全性"></a>14.8 安全性</h3><p>所有服务 URL 必须为 HTTPS（也就是说，所有入站调用必须为 HTTPS ）。处理 Web Hooks 的服务必须接受 HTTPS 。</p>
<p>我们建议允许客户端定义的 Web Hook 回调 URL 的服务不应通过 HTTP 传输数据。这是因为信息可能会通过客户端，网络，服务器日志和其他机制无意间公开。</p>
<p>但是，在某些情况下，由于客户端端点或软件限制，无法遵循上述建议。因此，服务可以允许 Web 钩 URL 为 HTTP 。</p>
<p>此外，允许客户端定义的 HTTP Web 挂钩回调 URL 的服务应符合工程领导指定的隐私策略。这通常包括建议客户端选择SSL连接并遵守特殊的预防措施，以确保正确处理日志和其他服务数据收集。</p>
<p>例如，服务可能不希望要求开发人员在机上生成证书。服务可能仅在测试帐户上启用此功能</p>
]]></content>
      <tags>
        <tag>api-desig</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenLDAP Software 2.4 Administrator&#39;s Guide</title>
    <url>/2017/11/20/documents/openldap_administrators_guide/</url>
    <content><![CDATA[<p>由于在使用 Openldap 苦于直接看以英文文档太麻烦，反正也是要阅读就边看边做笔记，于是有了次文档。记录内容呢也只是根据自己需要选择性翻译。<br>文章内容直接由 google 翻译软件翻译，可能存在不通顺之处，还望大家多多指出。在 markdown 转换到 html 过程中可能有部分尖括号引用内容，<br>导致丢失或者显示有误，请大家参照官方文档对比。</p>
<span id="more"></span>

<p>后期我会不定期优化文档，补全文档。</p>
<p>The OpenLDAP Project &lt;<a href="http://www.openldap.org/">http://www.openldap.org/</a>&gt; </p>
<h2 id="2-快速入门指南"><a href="#2-快速入门指南" class="headerlink" title="2 快速入门指南"></a>2 快速入门指南</h2><p>以下是OpenLDAP软件2.4的快速入门指南，包括独立版 LDAP守护进程，<em>slapd</em>（8）。</p>
<p>这意味着让您了解安装和配置<a href="http://www.openldap.org/software/">OpenLDAP软件</a>所需的基本步骤。应与本文档的其他章节，手册页以及发行版提供的其他材料（如<code>INSTALL</code>文档）或<a href="http://www.openldap.org/">OpenLDAP</a>网站（<a href="http://www.openldap.org/">http://www.OpenLDAP.org</a>）一起使用OpenLDAP软件常问问题（<a href="http://www.openldap.org/faq/?file=2">http://www.OpenLDAP.org/faq/?file=2</a>）。</p>
<p>如果您打算认真运行OpenLDAP软件，那么在尝试安装软件之前，您应该查看所有这些文档。</p>
<p><strong>注意：</strong>此快速入门指南不使用强身份验证，也不使用任何完整性或机密保护服务。这些服务在OpenLDAP管理员指南的其他章节中介绍。</p>
<h3 id="2-1-获取软件"><a href="#2-1-获取软件" class="headerlink" title="2.1 获取软件"></a>2.1 获取软件</h3><p>您可以按照OpenLDAP软件下载页面（<a href="http://www.openldap.org/software/download/">http://www.openldap.org/software/download/</a>）上的说明<strong>获取软件</strong>副本。建议新用户从最新<em>版本</em>开始。 </p>
<h3 id="2-2-打开分发包打开"><a href="#2-2-打开分发包打开" class="headerlink" title="2.2 打开分发包打开"></a>2.2 打开分发包打开</h3><p>源目录，将目录更改到那里，然后使用以下命令解压缩分发：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip -c openldap-VERSION.tgz | tar xvfB -</span><br></pre></td></tr></table></figure>

<p>然后重新定位到分发目录中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd openldap-VERSION</span><br></pre></td></tr></table></figure>

<p>您必须使用版本名称替换<code>VERSION</code>。 </p>
<h3 id="2-3-审查文件"><a href="#2-3-审查文件" class="headerlink" title="2.3 审查文件"></a>2.3 审查文件</h3><p>您现在应该查看发行版<code>随附</code>的<code>版权</code>，<code>许可证</code>，<code>自述</code>文件和<code>INSTALL</code>文档。该<code>版权</code>和<code>许可</code>提供可接受的使用，复制和OpenLDAP软件的保修期限制信息。 </p>
<p>您还应该查看本文档的其他章节。特别是，本文档的“ <a href="http://www.openldap.org/doc/admin24/install.html">构建和安装OpenLDAP软件”</a>一章提供了有关必备软件和安装步骤的详细信息。 </p>
<h3 id="2-4-运行配置"><a href="#2-4-运行配置" class="headerlink" title="2.4 运行配置"></a>2.4 运行配置</h3><p>您将需要运行提供的<code>配置</code>脚本来<em>配置</em>在系统上构建的分发。该<code>配置</code>脚本接受许多命令行选项启用或禁用可选的软件功能。通常默认值是可以的，但是您可能想要更改它们。要获取<code>配置</code>接受的选项的完整列表，请使用<code>--help</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --help</span><br></pre></td></tr></table></figure>

<p>但是，考虑到您正在使用本指南，我们假设您是勇敢的，只需让<code>配置</code>确定什么是最好的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>

<p>假设<code>configure</code>不会不喜欢你的系统，你可以继续构建软件。如果<code>configure</code>没有抱怨，那么您可能需要去软件常见问题解答<em>安装</em> 部分（<a href="http://www.openldap.org/faq/?file=8">http://www.openldap.org/faq/?file=8</a>）和/或实际阅读“ <a href="http://www.openldap.org/doc/admin24/install.html">构建和安装OpenLDAP软件”</a>一章的文件。 </p>
<h3 id="2-5-构建软件"><a href="#2-5-构建软件" class="headerlink" title="2.5 构建软件"></a>2.5 构建软件</h3><p>下一步是构建软件。这一步有两个部分，首先我们构建依赖关系，然后编译软件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make depend</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>两个都应该完成没有错误。 </p>
<p>2.6 测试构建</p>
<p>为了确保正确的构建，您应该运行测试套件（只需要几分钟）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make test</span><br></pre></td></tr></table></figure>

<p>适用于您的配置的测试将运行，它们应该通过。可能会跳过某些测试，如复制测试。 </p>
<h3 id="2-7-安装软件"><a href="#2-7-安装软件" class="headerlink" title="2.7 安装软件"></a>2.7 安装软件</h3><p>您现在可以安装该软件了; 这通常需要<em>超级用户</em>权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root -c &#x27;make install&#x27;</span><br></pre></td></tr></table></figure>

<p>现在应该将所有内容安装在<code>/ usr / local下</code>（或者<code>configure</code>使用的任何安装前缀）。 </p>
<h3 id="2-8-编辑配置文件"><a href="#2-8-编辑配置文件" class="headerlink" title="2.8 编辑配置文件"></a>2.8 编辑配置文件</h3><p>使用您喜欢的编辑器编辑提供的<em>slapd.ldif</em>示例（通常安装为<code>/usr/local/etc/openldap/slapd.ldif</code>）以包含MDB数据库定义的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: olcDatabase=mdb,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcMdbConfig</span><br><span class="line">olcDatabase: mdb</span><br><span class="line">OlcDbMaxSize: 1073741824</span><br><span class="line">olcSuffix: dc=&lt;MY-DOMAIN&gt;,dc=&lt;COM&gt;</span><br><span class="line">olcRootDN: cn=Manager,dc=&lt;MY-DOMAIN&gt;,dc=&lt;COM&gt;</span><br><span class="line">olcRootPW: secret</span><br><span class="line">olcDbDirectory: /usr/local/var/openldap-data</span><br><span class="line">olcDbIndex: objectClass eq</span><br></pre></td></tr></table></figure>

<p>请务必使用您域名的相应网域组件替换<code>&lt;MY-DOMAIN&gt;</code>和<code>&lt;COM&gt;</code>。例如，对于<code>example.com</code>，请使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: olcDatabase=mdb,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcMdbConfig</span><br><span class="line">olcDatabase: mdb</span><br><span class="line">OlcDbMaxSize: 1073741824</span><br><span class="line">olcSuffix: dc=example,dc=com</span><br><span class="line">olcRootDN: cn=Manager,dc=example,dc=com</span><br><span class="line">olcRootPW: secret</span><br><span class="line">olcDbDirectory: /usr/local/var/openldap-data</span><br><span class="line">olcDbIndex: objectClass eq</span><br></pre></td></tr></table></figure>

<p>如果您的域包含其他组件，例如<code>eng.uni.edu.eu</code>，请使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: olcDatabase=mdb,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcMdbConfig</span><br><span class="line">olcDatabase: mdb</span><br><span class="line">OlcDbMaxSize: 1073741824</span><br><span class="line">olcSuffix: dc=eng,dc=uni,dc=edu,dc=eu</span><br><span class="line">olcRootDN: cn=Manager,dc=eng,dc=uni,dc=edu,dc=eu</span><br><span class="line">olcRootPW: secret</span><br><span class="line">olcDbDirectory: /usr/local/var/openldap-data</span><br><span class="line">olcDbIndex: objectClass eq</span><br></pre></td></tr></table></figure>

<h3 id="2-9-导入配置数据库"><a href="#2-9-导入配置数据库" class="headerlink" title="2.9 导入配置数据库"></a>2.9 导入配置数据库</h3><p>现在，您可以通过运行以下命令来导入您的配置数据库供<em>slapd</em>（8）使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root -c /usr/local/sbin/slapadd -n 0 -F /usr/local/etc/slapd.d -l /usr/local/etc/openldap/slapd.ldif</span><br></pre></td></tr></table></figure>

<h3 id="2-10-启动SLAPD"><a href="#2-10-启动SLAPD" class="headerlink" title="2.10 启动SLAPD"></a>2.10 启动SLAPD</h3><p>您现在可以通过运行以下命令启动独立LDAP守护程序<em>slapd</em>（8）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root -c /usr/local/libexec/slapd -F /usr/local/etc/slapd.d</span><br></pre></td></tr></table></figure>

<p>要检查服务器是否正在运行和配置，您可以使用<em>ldapsearch</em>（1）运行搜索。默认情况下，<em>ldapsearch</em>安装为<code>/usr/local/bin/ldapsearch</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -b &#x27;&#x27; -s base &#x27;(objectclass=*)&#x27; namingContexts</span><br></pre></td></tr></table></figure>

<p>请注意在命令参数周围使用单引号来防止shell解释特殊字符。这应该返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn:</span><br><span class="line">namingContexts: dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>有关运行<em>slapd</em>（8）的详细信息，请参见<em>slapd</em>（8）手册页和本文档的<a href="http://www.openldap.org/doc/admin24/runningslapd.html">Running slapd</a>章节。 </p>
<h3 id="2-11-将初始条目添加到您的目录"><a href="#2-11-将初始条目添加到您的目录" class="headerlink" title="2.11 将初始条目添加到您的目录"></a>2.11 将初始条目添加到您的目录</h3><p>您可以使用<em>ldapadd</em>（1）向LDAP目录添加条目。<em>ldapadd</em>希望输入LDIF形成。我们将分两步进行：</p>
<ol>
<li>创建一个LDIF文件</li>
<li>运行ldapadd</li>
</ol>
<p>使用您喜欢的编辑器并创建一个包含以下内容的LDIF文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: dc=&lt;MY-DOMAIN&gt;,dc=&lt;COM&gt;</span><br><span class="line">objectclass: dcObject</span><br><span class="line">objectclass: organization</span><br><span class="line">o: &lt;MY ORGANIZATION&gt;</span><br><span class="line">dc: &lt;MY-DOMAIN&gt;</span><br><span class="line"></span><br><span class="line">dn: cn=Manager,dc=&lt;MY-DOMAIN&gt;,dc=&lt;COM&gt;</span><br><span class="line">objectclass: organizationalRole</span><br><span class="line">cn: Manager</span><br></pre></td></tr></table></figure>

<p>请务必使用您域名的相应网域组件替换<code>&lt;MY-DOMAIN&gt;</code>和<code>&lt;COM&gt;</code>。 应以组织名称替换<code>&lt;我的组织&gt;</code>。剪切和粘贴时，请确保从示例中修剪任何前导和尾随空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: dc=example,dc=com</span><br><span class="line">objectclass: dcObject</span><br><span class="line">objectclass: organization</span><br><span class="line">o: Example Company</span><br><span class="line">dc: example</span><br><span class="line"></span><br><span class="line">dn: cn=Manager,dc=example,dc=com</span><br><span class="line">objectclass: organizationalRole</span><br><span class="line">cn: Manager</span><br></pre></td></tr></table></figure>

<p>现在，您可以运行<em>ldapadd</em>（1）将这些条目插入到目录中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapadd -x -D &quot;cn=Manager,dc=&lt;MY-DOMAIN&gt;,dc=&lt;COM&gt;&quot; -W -f example.ldif</span><br></pre></td></tr></table></figure>

<p>请务必使用您域名的相应网域组件替换<code>&lt;MY-DOMAIN&gt;</code>和<code>&lt;COM&gt;</code>。系统将提示您输入<code>slapd.conf中</code>指定的“ <code>secret</code> ” 。例如，对于<code>example.com</code>，请使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapadd -x -D &quot;cn=Manager,dc=example,dc=com&quot; -W -f example.ldif</span><br></pre></td></tr></table></figure>

<p>其中<code>example.ldif</code>是您上面创建的文件。</p>
<p>有关目录创建的其他信息，请参见本文档的“ <a href="http://www.openldap.org/doc/admin24/dbtools.html">数据库创建和维护工具”</a>一章。 </p>
<h3 id="2-12-看看它是否工作"><a href="#2-12-看看它是否工作" class="headerlink" title="2.12 看看它是否工作"></a>2.12 看看它是否工作</h3><p>现在我们准备好验证添加的条目在您的目录中。您可以使用任何LDAP客户端来执行此操作，但我们的示例使用<em>ldapsearch</em>（1）工具。请记住将<code>dc=example,dc=com</code>替换为您网站的正确值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -b &#x27;dc=example,dc=com&#x27; &#x27;(objectclass=*)&#x27;</span><br></pre></td></tr></table></figure>

<p>此命令将搜索并检索数据库中的每个条目。</p>
<p>您现在可以使用<em>ldapadd</em>（1）或其他LDAP客户端添加更多条目，尝试各种配置选项，后端安排等。</p>
<p>请注意，默认情况下，<em>slapd</em>（8）数据库授予对<em>超级用户</em>（除了<code>rootdn</code>配置指令指定）之外的<em>所有人的读访问权限</em>。强烈建议您建立控制以限制对授权用户的访问。访问<a href="http://www.openldap.org/doc/admin24/access-control.html">控制</a>章节讨论<a href="http://www.openldap.org/doc/admin24/access-control.html">访问控制</a>。还鼓励您阅读<a href="http://www.openldap.org/doc/admin24/security.html">安全注意事项</a>，<a href="http://www.openldap.org/doc/admin24/sasl.html">使用SASL</a>和<a href="http://www.openldap.org/doc/admin24/tls.html">使用TLS</a>部分。**``</p>
<p>以下章节提供了有关制作，安装和运行<em>slapd</em>（8）的更多详细信息。</p>
<h2 id="5-配置-slapd"><a href="#5-配置-slapd" class="headerlink" title="5 配置 slapd"></a>5 配置 slapd</h2><p>OpenLDAP 2.3和更高版本已经转换为使用动态运行时配置引擎 <em>slapd-config</em>（5）</p>
<ul>
<li>完全启用了LDAP</li>
<li>使用标准LDAP操作进行管理</li>
<li>将其配置数据存储在 LDIF数据库，一般在<code>/usr/local/etc/openldap/slapd.d</code>目录下。</li>
<li>允许slapd的所有配置选项随时更改，通常不要求服务器重新启动，以使更改生效</li>
</ul>
<p>本章介绍<em>slapd-config</em>（5）配置系统的一般格式，其次是常用设置的详细说明。</p>
<p>旧版本<em>slapd.conf</em>（5）文件仍然受支持，但其使用已被弃用，并且对其的支持将在未来的OpenLDAP版本中被撤销。在下一章将介绍通过<em>slapd.conf</em>（5）配置<em>slapd</em>（8）。</p>
<p><strong>注：</strong>虽然<em>slapd-config</em>（5）系统存储了其作为（基于文本）LDIF文件的配置，你应该<em>永远不要</em>直接编辑任何LDIF文件。应通过LDAP操作执行配置更改，例如<em>ldapadd</em>（1），<em>ldapdelete</em>（1）或<em>ldapmodify</em>（1）。</p>
<h3 id="5-1-配置布局"><a href="#5-1-配置布局" class="headerlink" title="5.1 配置布局"></a>5.1 配置布局</h3><p>slapd配置存储为具有预定义模式和DIT的特殊LDAP目录。有特定的objectClasses用于承载全局配置选项，模式定义，后端和数据库定义以及各种其他项目。示例配置树如图5.1所示。</p>
<p><img src="https://qiniu.iclouds.work/FmRtJjELzSWkM7K8VC21jahAN4SS.png" alt="图 5.1"></p>
<p>其他对象可以是配置的一部分，但是为了清楚起见，从图示中省略。</p>
<p>该 <em>slapd-config</em> 配置树有一个非常特殊的结构。树的根名为<code>cn=config</code> ，并包含全局配置设置。附加设置包含在单独的子条目中：</p>
<ul>
<li>动态加载的模块<ul>
<li>只有使用<code>--enable-modules</code>选项来配置软件时，才可以使用这些。</li>
</ul>
</li>
<li>模式定义<ul>
<li>该<code>cn=schema，cn=config</code>条目包含了系统架构（所有架构是硬编码的slapd）。 <code>cn=schema</code> 的<br>子条目，<code>cn=config</code>包含从配置文件加载或在运行时添加的用户模式。</li>
</ul>
</li>
<li>后端特定配置</li>
<li>数据库特定配置<ul>
<li>数据库条目的子节点定义了覆盖。</li>
<li>数据库和叠加也可能有其他杂项的子项。</li>
</ul>
</li>
</ul>
<p>LDIF文件的常规规则适用于配置信息：以 <code>＃</code> 字符开头的注释行将被忽略。如果一行以单个空格开始，它被认为是前一行的延续（即使前一行是注释），并且单个前导空格被删除。条目用空白行分隔。</p>
<p>配置LDIF的一般布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># global configuration settings</span><br><span class="line">dn: cn=config</span><br><span class="line">objectClass: olcGlobal</span><br><span class="line">cn: config</span><br><span class="line">&lt;global config settings&gt;</span><br><span class="line"></span><br><span class="line"># schema definitions</span><br><span class="line">dn: cn=schema,cn=config</span><br><span class="line">objectClass: olcSchemaConfig</span><br><span class="line">cn: schema</span><br><span class="line">&lt;system schema&gt;</span><br><span class="line"></span><br><span class="line">dn: cn=&#123;X&#125;core,cn=schema,cn=config</span><br><span class="line">objectClass: olcSchemaConfig</span><br><span class="line">cn: &#123;X&#125;core</span><br><span class="line">&lt;core schema&gt;</span><br><span class="line"></span><br><span class="line"># additional user-specified schema</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># backend definitions</span><br><span class="line">dn: olcBackend=&lt;typeA&gt;,cn=config</span><br><span class="line">objectClass: olcBackendConfig</span><br><span class="line">olcBackend: &lt;typeA&gt;</span><br><span class="line">&lt;backend-specific settings&gt;</span><br><span class="line"></span><br><span class="line"># database definitions</span><br><span class="line">dn: olcDatabase=&#123;X&#125;&lt;typeA&gt;,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">olcDatabase: &#123;X&#125;&lt;typeA&gt;</span><br><span class="line">&lt;database-specific settings&gt;</span><br><span class="line"></span><br><span class="line"># subsequent definitions and settings</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面列出的一些条目的名称中有数字索引<code>“&#123;X&#125;”</code>。虽然大多数配置设置具有固有的顺序依赖性（即，一个设置必须在后续设置之前生效），LDAP数据库本质上是无序的。数字索引用于在配置数据库中强制执行一致的排序，以便保留所有排序依赖关系。在大多数情况下，不必提供指数; 它将根据创建条目的顺序自动生成。</p>
<p>配置指令被指定为各个属性的值。slapd配置中使用的大多数属性和对象类在其名称中具有前缀<code>“olc”</code> （OpenLDAP Configuration）。通常，属性和旧式<code>slapd.conf</code>配置关键字之间存在一一对应关系，使用关键字作为属性名称，并附加“olc”前缀。</p>
<p>配置指令可能会引用参数。如果是这样，这些参数就被空格分开。如果一个参数包含空格，参数应该用双引号括起来<code>“像这样”</code>。在下面的描述中，应该用实际文本替换的参数在括号<code>&lt;&gt;</code>中显示。</p>
<p>该分发包含将安装在<code>/usr/local/etc/openldap</code>目录中的示例配置文件。<code>/usr/local/etc/openldap/schema</code>目录中也提供了一些包含模式定义（属性类型和对象类）的文件。</p>
<h3 id="5-2-配置指令"><a href="#5-2-配置指令" class="headerlink" title="5.2 配置指令"></a>5.2 配置指令</h3><p>节详细介绍常用的配置指令。有关完整列表，请参阅<em>slapd-config</em>（5）手册页。本节将以自上而下的顺序处理配置指令，从<code>cn=config</code>条目中的全局伪指令开始。将对每个指令及其默认值（如果有）以及其使用示例进行描述。</p>
<h4 id="5-2-1-cn-config"><a href="#5-2-1-cn-config" class="headerlink" title="5.2.1. cn=config"></a>5.2.1. cn=config</h4><p>此条目中包含的指令通常适用于整个服务器。他们大多数是系统或连接导向，而不是数据库相关。此条目必须具有<code>olcGlobal objectClass</code>。</p>
<h5 id="5-2-1-1-olcIdleTimeout-lt-integer-gt"><a href="#5-2-1-1-olcIdleTimeout-lt-integer-gt" class="headerlink" title="5.2.1.1 olcIdleTimeout: &lt;integer&gt;"></a>5.2.1.1 olcIdleTimeout: &lt;integer&gt;</h5><p>指定强制关闭空闲客户端连接之前等待的秒数。值为0，默认值，禁用此功能。</p>
<h5 id="5-2-1-2-olcLogLevel-lt-integer-gt"><a href="#5-2-1-2-olcLogLevel-lt-integer-gt" class="headerlink" title="5.2.1.2 olcLogLevel: &lt;integer&gt;"></a>5.2.1.2 olcLogLevel: &lt;integer&gt;</h5><p>此指令指定调试语句和操作统计信息应该被syslog的级别（当前记录到<em>syslogd</em>（8）<code>LOG_LOCAL4</code>设施）。您必须配置OpenLDAP <code>--enable-debug</code>（默认值）才能工作（除了始终启用的两个统计级别之外）。日志级别可以被指定为整数或关键字。可以使用多个日志级别，并且级别是相加的。要显示什么级别对应于什么样的调试，用<code>-d?</code>调用slapd 或查阅下表。&lt;level&gt;的可能值为：</p>
<p>表5.1：调试级别</p>
<table>
<thead>
<tr>
<th><strong>Level</strong></th>
<th><strong>Keyword</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>any</td>
<td>enable all debugging</td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>no debugging</td>
</tr>
<tr>
<td>1</td>
<td>(0x1 trace)</td>
<td>trace function calls</td>
</tr>
<tr>
<td>2</td>
<td>(0x2 packets)</td>
<td>debug packet handling</td>
</tr>
<tr>
<td>4</td>
<td>(0x4 args)</td>
<td>heavy trace debugging</td>
</tr>
<tr>
<td>8</td>
<td>(0x8 conns)</td>
<td>connection management</td>
</tr>
<tr>
<td>16</td>
<td>(0x10 BER)</td>
<td>print out packets sent and received</td>
</tr>
<tr>
<td>32</td>
<td>(0x20 filter)</td>
<td>search filter processing</td>
</tr>
<tr>
<td>64</td>
<td>(0x40 config)</td>
<td>configuration processing</td>
</tr>
<tr>
<td>128</td>
<td>(0x80 ACL)</td>
<td>access control list processing</td>
</tr>
<tr>
<td>256</td>
<td>(0x100 stats)</td>
<td>stats log connections/operations/results</td>
</tr>
<tr>
<td>512</td>
<td>(0x200 stats2)</td>
<td>stats log entries sent</td>
</tr>
<tr>
<td>1024</td>
<td>(0x400 shell)</td>
<td>print communication with shell backends</td>
</tr>
<tr>
<td>2048</td>
<td>(0x800 parse)</td>
<td>print entry parsing debugging</td>
</tr>
<tr>
<td>16384</td>
<td>(0x4000 sync)</td>
<td>syncrepl consumer processing</td>
</tr>
<tr>
<td>32768</td>
<td>(0x8000 none)</td>
<td>only messages that get logged whatever log level is set</td>
</tr>
</tbody></table>
<p>期望的日志级别可以作为单个整数输入，该整数将（ORed）所需的级别（十进制或十六进制符号）组合为整数列表（在内部进行ORed操作），或作为显示的名称列表在括号之间，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcLogLevel 129</span><br><span class="line">olcLogLevel 0x81</span><br><span class="line">olcLogLevel 128 1</span><br><span class="line">olcLogLevel 0x80 0x1</span><br><span class="line">olcLogLevel acl trace</span><br></pre></td></tr></table></figure>

<p>是等同的</p>
<p><strong>例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcLogLevel -1</span><br></pre></td></tr></table></figure>

<p>这将导致大量的调试信息被记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcLogLevel conns filter</span><br></pre></td></tr></table></figure>

<p>只需记录连接并搜索过滤器处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcLogLevel none</span><br></pre></td></tr></table></figure>

<p>记录无论配置的日志级别如何记录的消息。这不同于在不发生日志记录时将日志级别设置为0。至少需要“ <code>无”</code>级才能记录高优先级消息。</p>
<p><strong>默认：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcLogLevel stats</span><br></pre></td></tr></table></figure>

<p>默认情况下配置基本统计记录。但是，如果未定义<code>olcLogLevel</code>，则不会发生日志记录（相当于0级）。</p>
<h5 id="5-2-1-3-olcReferral-lt-URI-gt"><a href="#5-2-1-3-olcReferral-lt-URI-gt" class="headerlink" title="5.2.1.3 olcReferral &lt;URI&gt;"></a>5.2.1.3 olcReferral &lt;URI&gt;</h5><p>此指令指定当slapd找不到本地数据库来处理请求时要传回的引用。</p>
<p><strong>例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcReferral: ldap://root.openldap.org</span><br></pre></td></tr></table></figure>

<p>这将在OpenLDAP项目中将非本地查询引用到全局根LDAP服务器。智能LDAP客户端可以在该服务器上重新询问他们的查询，但请注意，大多数这些客户端只会知道如何处理包含主机部分和可选的可分辨名称部分的简单LDAP URL。</p>
<h5 id="5-2-1-4-条目样例"><a href="#5-2-1-4-条目样例" class="headerlink" title="5.2.1.4 条目样例"></a>5.2.1.4 条目样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=config</span><br><span class="line">objectClass: olcGlobal</span><br><span class="line">cn: config</span><br><span class="line">olcIdleTimeout: 30</span><br><span class="line">olcLogLevel: Stats</span><br><span class="line">olcReferral: ldap://root.openldap.org</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-cn-module"><a href="#5-2-2-cn-module" class="headerlink" title="5.2.2 cn=module"></a>5.2.2 cn=module</h4><p>如果在配置slapd时启用对动态加载模块的支持，则可以使用<code>cn=module</code>条目来指定要加载的模块集。模块条目必须具有<code>olcModuleList objectClass</code>。</p>
<h5 id="5-2-2-1-olcModuleLoad：-lt-filename-gt"><a href="#5-2-2-1-olcModuleLoad：-lt-filename-gt" class="headerlink" title="5.2.2.1 olcModuleLoad：&lt;filename&gt;"></a>5.2.2.1 olcModuleLoad：&lt;filename&gt;</h5><p>指定要加载的动态可加载模块的名称。文件名可以是绝对路径名或简单文件名。在<code>olcModulePath</code>指令指定的目录中搜索非绝对名称。</p>
<h5 id="5-2-2-2-olcModulePath-lt-pathspec-gt"><a href="#5-2-2-2-olcModulePath-lt-pathspec-gt" class="headerlink" title="5.2.2.2 olcModulePath: &lt;pathspec&gt;"></a>5.2.2.2 olcModulePath: &lt;pathspec&gt;</h5><p>指定要加载的动态可加载模块的名称。文件名可以是绝对路径名或简单文件名。在<code>olcModulePath</code>指令指定的目录中搜索非绝对名称。</p>
<h5 id="5-2-2-3-条目样例"><a href="#5-2-2-3-条目样例" class="headerlink" title="5.2.2.3 条目样例"></a>5.2.2.3 条目样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=module&#123;0&#125;,cn=config</span><br><span class="line">objectClass: olcModuleList</span><br><span class="line">cn: module&#123;0&#125;</span><br><span class="line">olcModuleLoad: /usr/local/lib/smbk5pwd.la</span><br><span class="line"></span><br><span class="line">dn: cn=module&#123;1&#125;,cn=config</span><br><span class="line">objectClass: olcModuleList</span><br><span class="line">cn: module&#123;1&#125;</span><br><span class="line">olcModulePath: /usr/local/lib:/usr/local/lib/slapd</span><br><span class="line">olcModuleLoad: accesslog.la</span><br><span class="line">olcModuleLoad: pcache.la</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-cn-schema"><a href="#5-2-3-cn-schema" class="headerlink" title="5.2.3 cn=schema"></a>5.2.3 cn=schema</h4><p><code>cn=schema</code> 条目包含在slapd中硬编码的所有模式定义。因此，此条目中的值由slapd生成，因此在配置文件中不需要提供模式值。仍然必须定义该条目，以作为用户定义的模式添加到底部的基础。模式条目必须具有<code>olcSchemaConfig objectClass</code>。</p>
<h5 id="5-2-3-1-olcAttributeTypes-lt-RFC4512-Attribute-Type-Description-gt"><a href="#5-2-3-1-olcAttributeTypes-lt-RFC4512-Attribute-Type-Description-gt" class="headerlink" title="5.2.3.1 olcAttributeTypes: &lt;RFC4512 Attribute Type Description&gt;"></a>5.2.3.1 olcAttributeTypes: &lt;<a href="http://www.rfc-editor.org/rfc/rfc4512.txt">RFC4512</a> Attribute Type Description&gt;</h5><p>此指令定义属性类型。有关如何使用此指令的信息，请参阅“ <a href="http://www.openldap.org/doc/admin24/schema.html">模式规范”</a>一章。</p>
<h5 id="5-2-3-2-olcObjectClasses-lt-RFC4512-Object-Class-Description-gt"><a href="#5-2-3-2-olcObjectClasses-lt-RFC4512-Object-Class-Description-gt" class="headerlink" title="5.2.3.2 olcObjectClasses: &lt;RFC4512 Object Class Description&gt;"></a>5.2.3.2 olcObjectClasses: &lt;<a href="http://www.rfc-editor.org/rfc/rfc4512.txt">RFC4512</a> Object Class Description&gt;</h5><p>该指令定义了一个对象类。有关如何使用此指令的信息，请参阅“ <a href="http://www.openldap.org/doc/admin24/schema.html">模式规范”</a>一章。</p>
<h5 id="5-2-3-3-条目样例"><a href="#5-2-3-3-条目样例" class="headerlink" title="5.2.3.3 条目样例"></a>5.2.3.3 条目样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=schema,cn=config</span><br><span class="line">objectClass: olcSchemaConfig</span><br><span class="line">cn: schema</span><br><span class="line"></span><br><span class="line">dn: cn=test,cn=schema,cn=config</span><br><span class="line">objectClass: olcSchemaConfig</span><br><span class="line">cn: test</span><br><span class="line">olcAttributeTypes: ( 1.1.1</span><br><span class="line">  NAME &#x27;testAttr&#x27;</span><br><span class="line">  EQUALITY integerMatch</span><br><span class="line">  SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )</span><br><span class="line">olcAttributeTypes: ( 1.1.2 NAME &#x27;testTwo&#x27; EQUALITY caseIgnoreMatch</span><br><span class="line">  SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.44 )</span><br><span class="line">olcObjectClasses: ( 1.1.3 NAME &#x27;testObject&#x27;</span><br><span class="line">  MAY ( testAttr $ testTwo ) AUXILIARY )</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-后端特定指令"><a href="#5-2-4-后端特定指令" class="headerlink" title="5.2.4 后端特定指令"></a>5.2.4 后端特定指令</h4><p>后端指令适用于所有相同类型的数据库实例，根据该指令，数据库指令可能会被覆盖。后端条目必须具有<code>olcBackendConfig objectClass</code>。</p>
<h5 id="5-2-4-1-olcBackend-lt-type-gt"><a href="#5-2-4-1-olcBackend-lt-type-gt" class="headerlink" title="5.2.4.1 olcBackend: &lt;type&gt;"></a>5.2.4.1 olcBackend: &lt;type&gt;</h5><p>该指令命名后端特定的配置条目。<code>&lt;type&gt;</code>应于表5.2中列出的支持的后端类型之一。</p>
<p><strong>表5.2：数据库后端</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>bdb</td>
<td>Berkeley DB事务后端（已弃用）</td>
</tr>
<tr>
<td>config</td>
<td>Slapd配置后端</td>
</tr>
<tr>
<td>dnssrv</td>
<td>DNS SRV后端</td>
</tr>
<tr>
<td>hdb</td>
<td>bdb后端的分层变体（已弃用）</td>
</tr>
<tr>
<td>ldap</td>
<td>轻量级目录访问协议（Proxy）后端</td>
</tr>
<tr>
<td>ldif</td>
<td>轻量级数据交换格式后端</td>
</tr>
<tr>
<td>mdb</td>
<td>内存映射DB后端</td>
</tr>
<tr>
<td>meta</td>
<td>元目录后端</td>
</tr>
<tr>
<td>monitor</td>
<td>监视后端</td>
</tr>
<tr>
<td>passwd</td>
<td>提供对<em>passwd的</em>只读访问（5）</td>
</tr>
<tr>
<td>perl</td>
<td>Perl可编程后端</td>
</tr>
<tr>
<td>shell</td>
<td>Shell（外部程序）后端</td>
</tr>
<tr>
<td>sql</td>
<td>SQL可编程后端</td>
</tr>
</tbody></table>
<p><strong>例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcBackend：bdb</span><br></pre></td></tr></table></figure>

<p>没有为此条目定义其他指令。特定的后端类型可以为其特定用途定义附加属性，但是迄今为止还没有定义。因此，这些指令通常不会出现在任何实际配置中。</p>
<h5 id="5-2-4-2-条目样例"><a href="#5-2-4-2-条目样例" class="headerlink" title="5.2.4.2 条目样例"></a>5.2.4.2 条目样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn：olcBackend=bdb，cn=config</span><br><span class="line">objectClass:olcBackendConfig</span><br><span class="line">olcBackend:bdb</span><br></pre></td></tr></table></figure>

<h4 id="5-2-5-数据库特定的指令"><a href="#5-2-5-数据库特定的指令" class="headerlink" title="5.2.5 数据库特定的指令"></a>5.2.5 数据库特定的指令</h4><p>每个类型的数据库都支持本节中的指令。数据库条目必须具有<code>olcDatabaseConfig objectClass</code>。</p>
<h5 id="5-2-5-1-olcDatabase-lt-index-gt-lt-type-gt"><a href="#5-2-5-1-olcDatabase-lt-index-gt-lt-type-gt" class="headerlink" title="5.2.5.1 olcDatabase: [{&lt;index&gt;}]&lt;type&gt;"></a>5.2.5.1 olcDatabase: [{&lt;index&gt;}]&lt;type&gt;</h5><p>该指令命名一个特定的数据库实例。可以提供数字<code>&#123;&lt;index&gt;&#125;</code>来区分相同类型的多个数据库。通常可以省略索引，slapd将自动生成。<code>&lt;type&gt;</code>应于表5.2或列出的支持的后端类型之一<code>前端</code>类型。</p>
<p>该<code>前端</code>是用来保存应适用于所有其他数据库的数据库级选项一个特殊的数据库。后续数据库定义也可以覆盖一些前端设置。</p>
<p>在配置数据库也是特殊的; 无论是<code>配置</code>和<code>前端</code>数据库总是隐式创建的，即使他们没有明确配置，以及它们的任何其他数据库之前创建。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDatabase: bdb</span><br></pre></td></tr></table></figure>

<p>这标志着一个新的开始 BDB 数据库实例。</p>
<h5 id="5-2-5-2-olcAccess-to-lt-what-gt-by-lt-who-gt-lt-accesslevel-gt-lt-control-gt"><a href="#5-2-5-2-olcAccess-to-lt-what-gt-by-lt-who-gt-lt-accesslevel-gt-lt-control-gt" class="headerlink" title="5.2.5.2 olcAccess: to &lt;what&gt; [ by &lt;who&gt; [&lt;accesslevel&gt;] [&lt;control&gt;] ]+"></a>5.2.5.2 olcAccess: to &lt;what&gt; [ by &lt;who&gt; [&lt;accesslevel&gt;] [&lt;control&gt;] ]+</h5><p>该指令通过一个或多个请求者（由&lt;who&gt;指定）向一组条目和/或属性（由&lt;what&gt;指定）访问（由&lt;accesslevel&gt;指定）。有关基本用途，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/access-control.html">访问控制</a>部分。</p>
<p><strong>注意：</strong>如果没有指定<code>olcAccess</code>指令，默认访问控制策略（<code>* by * read</code>）允许所有用户（通过身份验证和匿名）读取访问权限。</p>
<p><strong>注意：</strong>在前端定义的访问控件附加到所有其他数据库的控件。</p>
<h5 id="5-2-5-3-olcReadonly-TRUE-FALSE"><a href="#5-2-5-3-olcReadonly-TRUE-FALSE" class="headerlink" title="5.2.5.3 olcReadonly { TRUE | FALSE }"></a>5.2.5.3 olcReadonly { TRUE | FALSE }</h5><p>该指令将数据库置于“只读”模式。任何修改数据库的尝试将返回“不愿意执行”的错误。如果设置在消费者身上，syncrepl发送的修改仍然会发生。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcReadonly：FALSE</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-4-olcRootDN-lt-DN-gt"><a href="#5-2-5-4-olcRootDN-lt-DN-gt" class="headerlink" title="5.2.5.4 olcRootDN: &lt;DN&gt;"></a>5.2.5.4 olcRootDN: &lt;DN&gt;</h5><p>此指令指定不受该数据库操作的访问控制或管理限制限制的DN。DN不需要引用此数据库中的条目，甚至不在目录中。DN可以指SASL身份。</p>
<p>基于入门的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcRootDN: &quot;cn=Manager,dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>基于SASL的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcRootDN: &quot;uid=root,cn=example.com,cn=digest-md5,cn=auth&quot;</span><br></pre></td></tr></table></figure>

<p>有关[SASL认证身份](<a href="http://www.openldap.org/doc/admin24/sasl.html#SASL">http://www.openldap.org/doc/admin24/sasl.html#SASL</a> Authentication)的信息，请参阅[SASL认证](<a href="http://www.openldap.org/doc/admin24/sasl.html#SASL">http://www.openldap.org/doc/admin24/sasl.html#SASL</a> Authentication)部分。</p>
<h5 id="5-2-5-5-olcRootPW-lt-password-gt"><a href="#5-2-5-5-olcRootPW-lt-password-gt" class="headerlink" title="5.2.5.5 olcRootPW: &lt;password&gt;"></a>5.2.5.5 olcRootPW: &lt;password&gt;</h5><p>该指令可用于为rootdn指定DN的密码（当rootdn设置为数据库中的DN时）。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcRootPW: secret</span><br></pre></td></tr></table></figure>

<p>还允许在<a href="http://www.rfc-editor.org/rfc/rfc2307.txt">RFC2307</a>表单中提供密码的散列。 <em>slappasswd</em>（8）可用于生成密码哈希。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcRootPW: &#123;SSHA&#125;ZKKuqbEKJfKSXhUbHG3fG8MDn9j1v4QN</span><br></pre></td></tr></table></figure>

<p>散列是使用命令<code>slappasswd -s secret</code>生成的。</p>
<h5 id="5-2-5-6-olcSizeLimit-lt-integer-gt"><a href="#5-2-5-6-olcSizeLimit-lt-integer-gt" class="headerlink" title="5.2.5.6 olcSizeLimit: &lt;integer&gt;"></a>5.2.5.6 olcSizeLimit: &lt;integer&gt;</h5><p>此指令指定从搜索操作返回的最大条目数。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcSizeLimit: 500</span><br></pre></td></tr></table></figure>

<p>关详细信息，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/limits.html">“限制”</a>部分和slapd-config（5）。</p>
<h5 id="5-2-5-7-olcSuffix-lt-dn-suffix-gt"><a href="#5-2-5-7-olcSuffix-lt-dn-suffix-gt" class="headerlink" title="5.2.5.7 olcSuffix: &lt;dn suffix&gt;"></a>5.2.5.7 olcSuffix: &lt;dn suffix&gt;</h5><p>此指令指定将传递给此后端数据库的查询的DN后缀。可以给出多个后缀行，并且每个数据库定义通常需要至少一个。（一些后端类型，如<code>前端</code>和<code>监视器</code>使用硬编码后缀，可能不会在配置中被覆盖。）</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcSuffix：&quot;dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>以<code>dc=example,dc=com</code>结尾的DN的查询将传递给此后端。</p>
<p><strong>注意：</strong></p>
<p>当选择要传递查询的后端时，slapd按照配置顺序查看每个数据库定义中的后缀值。因此，如果一个数据库后缀是另一个数据库后缀，则必须在配置中显示。</p>
<h5 id="5-2-5-8-olcSyncrepl"><a href="#5-2-5-8-olcSyncrepl" class="headerlink" title="5.2.5.8. olcSyncrepl"></a>5.2.5.8. olcSyncrepl</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcSyncrepl: rid=&lt;replica ID&gt;</span><br><span class="line">                provider=ldap[s]://&lt;hostname&gt;[:port]</span><br><span class="line">                [type=refreshOnly|refreshAndPersist]</span><br><span class="line">                [interval=dd:hh:mm:ss]</span><br><span class="line">                [retry=[&lt;retry interval&gt; &lt;# of retries&gt;]+]</span><br><span class="line">                searchbase=&lt;base DN&gt;</span><br><span class="line">                [filter=&lt;filter str&gt;]</span><br><span class="line">                [scope=sub|one|base]</span><br><span class="line">                [attrs=&lt;attr list&gt;]</span><br><span class="line">                [attrsonly]</span><br><span class="line">                [sizelimit=&lt;limit&gt;]</span><br><span class="line">                [timelimit=&lt;limit&gt;]</span><br><span class="line">                [schemachecking=on|off]</span><br><span class="line">                [bindmethod=simple|sasl]</span><br><span class="line">                [binddn=&lt;DN&gt;]</span><br><span class="line">                [saslmech=&lt;mech&gt;]</span><br><span class="line">                [authcid=&lt;identity&gt;]</span><br><span class="line">                [authzid=&lt;identity&gt;]</span><br><span class="line">                [credentials=&lt;passwd&gt;]</span><br><span class="line">                [realm=&lt;realm&gt;]</span><br><span class="line">                [secprops=&lt;properties&gt;]</span><br><span class="line">                [starttls=yes|critical]</span><br><span class="line">                [tls_cert=&lt;file&gt;]</span><br><span class="line">                [tls_key=&lt;file&gt;]</span><br><span class="line">                [tls_cacert=&lt;file&gt;]</span><br><span class="line">                [tls_cacertdir=&lt;path&gt;]</span><br><span class="line">                [tls_reqcert=never|allow|try|demand]</span><br><span class="line">                [tls_cipher_suite=&lt;ciphers&gt;]</span><br><span class="line">                [tls_crlcheck=none|peer|all]</span><br><span class="line">                [logbase=&lt;base DN&gt;]</span><br><span class="line">                [logfilter=&lt;filter str&gt;]</span><br><span class="line">                [syncdata=default|accesslog|changelog]</span><br></pre></td></tr></table></figure>

<p>该指令通过将当前的<em>slapd</em>（8）建立为运行syncrepl复制引擎的复制用户站点来将当前数据库指定为主内容的副本。主数据库位于由<code>provider</code>参数指定的复制提供程序站点。使用LDAP内容同步协议，副本数据库与主内容保持最新。有关<a href="http://www.rfc-editor.org/rfc/rfc4533.txt">协议</a>的更多信息，请参阅<a href="http://www.rfc-editor.org/rfc/rfc4533.txt">RFC4533</a>。</p>
<p><code>RID</code>参数用于当前的识别<code>的syncrepl</code>复制消费者服务器内的指令，其中<code>&lt;replica ID&gt;</code>唯一地识别由当前所描述的的syncrepl规范<code>的syncrepl</code>指令。<code>&lt;replica ID&gt;</code>为非负数，长度不超过三位十进制数字。</p>
<p><code>provider </code>参数指定包含主内容作为LDAP URI复制提供者站点。<code>provider </code>参数指定的方案，主机和可选地其中该提供者的slapd实例可以发现一个端口。域名或IP地址可以用于&lt;hostname&gt;。示例是<code>ldap://provider.example.com：389</code>或<code>ldaps://192.168.1.1：636</code>。如果未指定&lt;port&gt;，则使用标准LDAP端口号（389或636）。请注意，syncrepl使用消费者启动的协议，因此其规范位于消费者站点，而<code>replica </code>规范位于提供者站点。<code>syncrepl</code>和<code>replica </code>指令定义了两个独立的复制机制。它们不代表彼此的复制对等体。</p>
<p>使用搜索规范作为其结果集定义syncrepl副本的内容。消费者slapd将根据搜索规范将搜索请求发送给提供商slapd。搜索规范包括<code>searchbase</code>，<code>scope</code>，<code>filter</code>，<code>attrs </code>，<code>attrsonly</code>，<code>sizeLimit</code>和<code>timelimit </code>参数如在正常搜索规范。该<code>searchbase</code>参数没有默认值，必须指定。的<code>scope </code>默认为<code>sub</code>中，<code>filter </code>默认为<code>（objectclass=*） </code>，<code>attrs </code>默认为<code>“*，+”</code>来复制所有用户和操作属性，默认情况下，<code>attrsonly</code>未设置。双方的<code>sizeLimit</code>和<code>timelimit</code>默认为“无限制”，只有正整数或“无限制”可能被指定。</p>
<p>该 LDAP内容同步协议有两种操作类型：<code>refreshOnly</code>和<code>refreshAndPersist</code>。操作类型由<code>type</code>参数指定。在<code>refreshOnly</code>操作中，在每次同步操作结束之后的间隔时间周期性地重新调度下一个同步搜索操作。间隔由<code>interval</code>参数指定。默认设置为一天。在<code>refreshAndPersist</code>操作中，同步搜索在提供者<em>slapd</em>实例中保持不变。对主副本的进一步更新将生成<code>searchResultEntry</code> 到消费者slapd作为搜索响应的持续同步搜索。</p>
<p>如果在复制期间发生错误，消费者将尝试根据重试参数重新连接，该重试参数是&lt;retry interval&gt;和&lt;＃of retries&gt; 的列表。例如，retry =“60 10 300 3”可让消费者重新开始前10次，每60秒重试一次，然后在停止重试之前每300秒重试三次。+在&lt;＃重试次数&gt;中意味着无限期的重试，直到成功。</p>
<p>可以通过打开<code>schemachecking</code>参数，在LDAP Sync使用者站点上强制执行模式检查。如果它被打开，则每个复制的条目将被检查其模式，因为条目存储在副本内容中。副本中的每个条目都应包含模式定义所需的属性。如果它被关闭，条目将被存储，而不检查模式一致性。默认是关闭。</p>
<p>该<code>binddn</code>参数给出了DN绑定为进行syncrepl搜索到提供者的slapd。它应该是具有对主数据库中的复制内容的读取访问权限的DN。</p>
<p>该<code>bindmethod</code>是<code>simple </code>还是<code>SASL</code>，取决于是否简单基于密码的认证或SASL连接到提供商<em>slapd</em>实例时要使用身份验证。</p>
<p>除非有足够的数据完整性和机密性保护（例如TLS或IPsec），否则不应使用简单认证。简单的身份验证需要指定<code>binddn</code>和<code>credentials</code>参数。</p>
<p>通常建议使用SASL认证。SASL身份验证需要使用<code>saslmech</code>参数来指定机制。根据机制，可以分别使用<code>authcid</code>和<code>credentials</code>来指定身份验证身份和/或凭据。所述<code>authzid</code>参数可以被用来指定一个授权身份。</p>
<p><code>realm</code>参数指定其中的某些机制认证中的身份的境界。该<code>secprops</code>参数指定Cyrus  SASL安全属性。</p>
<p>该<code>STARTTLS</code>参数指定使用扩展操作认证的供应商之前建立TLS会话启动TLS的。如果提供了<code>critical </code>参数，则如果StartTLS请求失败，则该会话将中止。否则syncrepl会话继续而不使用TLS。tls_reqcert设置默认为<code>“demand”</code>，其他TLS设置默认与主slapd TLS设置相同。</p>
<p>消费者不是复制整个条目，而是可以查询数据修改的日志。这种操作模式称为<em>delta syncrepl</em>。除了上述参数之外，必须对要使用的日志适当地设置<code>logbase</code>和<code>logfilter</code>参数。所述<code>syncdata</code>参数必须设置为<code>“accesslog”</code>如果日志符合<em>slapo-ACCESSLOG</em>（5）日志格式，或<code>“更改日志”</code>如果日志符合过时的<em>更改日志</em>的格式。如果<code>syncdata</code>参数被省略或设置为<code>“default”，</code>则日志参数将被忽略。</p>
<p><em>syncrepl</em> 复制机制是由支持<em>BDB</em>，<em>hdb</em>，以及 <em>mdb</em>后端。</p>
<p>有关如何使用此指令的详细信息，请参阅本指南的“ [LDAP同步复制”](<a href="http://www.openldap.org/doc/admin24/replication.html#LDAP">http://www.openldap.org/doc/admin24/replication.html#LDAP</a> Sync Replication)一章。</p>
<h5 id="5-2-5-9-olcTimeLimit-lt-integer-gt"><a href="#5-2-5-9-olcTimeLimit-lt-integer-gt" class="headerlink" title="5.2.5.9 olcTimeLimit: &lt;integer&gt;"></a>5.2.5.9 olcTimeLimit: &lt;integer&gt;</h5><p>此指令指定slapd将花费回答搜索请求的最大秒数（实时）。如果此时尚未完成请求，将返回指示超时时间的结果。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcTimeLimit: 3600</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/limits.html">“限制”</a>部分和slapd-config（5）。</p>
<h5 id="5-2-5-10-olcUpdateref-lt-URL-gt"><a href="#5-2-5-10-olcUpdateref-lt-URL-gt" class="headerlink" title="5.2.5.10 olcUpdateref: &lt;URL&gt;"></a>5.2.5.10 olcUpdateref: &lt;URL&gt;</h5><p>该指令仅适用于从属slapd。它指定返回到在副本上提交更新请求的客户端的URL。如果指定多次，每个网址 被提供。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcUpdateref: ldap://master.example.net</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-11-条目案例"><a href="#5-2-5-11-条目案例" class="headerlink" title="5.2.5.11 条目案例"></a>5.2.5.11 条目案例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: olcDatabase=frontend,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcFrontendConfig</span><br><span class="line">olcDatabase: frontend</span><br><span class="line">olcReadOnly: FALSE</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=config,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">olcDatabase: config</span><br><span class="line">olcRootDN: cn=Manager,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<h4 id="5-2-6-BDB-and-HDB-Database-Directives"><a href="#5-2-6-BDB-and-HDB-Database-Directives" class="headerlink" title="5.2.6 BDB and HDB Database Directives"></a>5.2.6 BDB and HDB Database Directives</h4><p>此类别中的指令适用于 BDB 和 HDB 两个数据库。除了上面定义的通用数据库指令之外，它们还用于olcDatabase条目。有关BDB / HDB配置指令的完整参考，请参见<em>slapd-bdb</em>（5）。除了<code>olcDatabaseConfig objectClass</code>之外，BDB和HDB数据库条目必须分别具有<code>olcBdbConfig</code>和<code>olcHdbConfig objectClass</code>。</p>
<h5 id="5-2-6-1-olcDbDirectory-lt-directory-gt"><a href="#5-2-6-1-olcDbDirectory-lt-directory-gt" class="headerlink" title="5.2.6.1. olcDbDirectory: &lt;directory&gt;"></a>5.2.6.1. olcDbDirectory: &lt;directory&gt;</h5><p>此伪指令指定包含数据库和关联索引的BDB文件的目录。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbDirectory: /usr/local/var/openldap-data</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-2-olcDbCachesize：-lt-integer-gt"><a href="#5-2-6-2-olcDbCachesize：-lt-integer-gt" class="headerlink" title="5.2.6.2 olcDbCachesize：&lt;integer&gt;"></a>5.2.6.2 olcDbCachesize：&lt;integer&gt;</h5><p>此指令指定由BDB后端数据库实例维护的内存中缓存条目的大小。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbCachesize: 1000</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-3-olcDbCheckpoint-lt-kbyte-gt-lt-min-gt"><a href="#5-2-6-3-olcDbCheckpoint-lt-kbyte-gt-lt-min-gt" class="headerlink" title="5.2.6.3 olcDbCheckpoint:  &lt;kbyte&gt; &lt;min&gt;"></a>5.2.6.3 olcDbCheckpoint:  &lt;kbyte&gt; &lt;min&gt;</h5><p>此指令指定检查点BDB事务日志的频率。检查点操作将数据库缓冲区刷新到磁盘，并在日志中写入检查点记录。如果已经写入了<code>&lt;kbyte&gt;</code>数据或自上次检查点起已经过了<code>&lt;min&gt;</code>分钟，则检查点将发生。两个参数默认为零，在这种情况下，它们将被忽略。当<code>&lt;min&gt;</code>参数不为零时，内部任务将每分钟运行一分钟以执行检查点。有关详细信息，请参阅Berkeley DB参考指南。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbCheckpoint: 1024 10</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-4-olcDbConfig-lt-DB-CONFIG-setting-gt"><a href="#5-2-6-4-olcDbConfig-lt-DB-CONFIG-setting-gt" class="headerlink" title="5.2.6.4 olcDbConfig: &lt;DB_CONFIG setting&gt;"></a>5.2.6.4 olcDbConfig: &lt;DB_CONFIG setting&gt;</h5><p>此属性指定要放置在数据库目录的<code>DB_CONFIG</code>文件中的配置指令。在服务器启动时，如果尚未存在此类文件，则将创建<code>DB_CONFIG</code>文件，并将此属性中的设置写入。如果文件存在，其内容将被读取并显示在此属性中。该属性是多值的，以适应多个配置指令。没有提供默认值，但是在这里使用适当的设置来获得最佳的服务器性能是至关重要的。</p>
<p>对此属性所做的任何更改都将写入<code>DB_CONFIG</code>文件，并将导致数据库环境重置，以便更改可立即生效。如果环境缓存大并且最近没有被检查点，这种重置操作可能需要很长时间。在使用LDAP修改更改此属性之前，建议您使用Berkeley DB <em>db_checkpoint</em>实用程序手动执行单个检查点。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbConfig: set_cachesize 0 10485760 0</span><br><span class="line">olcDbConfig: set_lg_bsize 2097512</span><br><span class="line">olcDbConfig: set_lg_dir /var/tmp/bdb-log</span><br><span class="line">olcDbConfig: set_flags DB_LOG_AUTOREMOVE</span><br></pre></td></tr></table></figure>

<p>在本示例中，BDB缓存设置为10MB，BDB事务日志缓冲区大小设置为2MB，并将事务日志文件存储在<code>/var/tmp/bdb-log</code>目录中。另外还设置一个标志来告知BDB一旦它们的内容被检查点并且不再需要就删除事务日志文件。没有此设置，事务日志文件将继续累积，直到其他一些清除过程删除它们。有关详细信息，请参见<code>db_archive</code>命令的Berkeley DB文档。有关Berkeley DB标志的完整列表，请参阅 - <a href="http://www.oracle.com/technology/documentation/berkeley-db/db/api_c/env_set_flags.html">http://www.oracle.com/technology/documentation/berkeley-db/db/api_c/env_set_flags.html</a></p>
<p>理想情况下，BDB缓存必须至少与数据库的工作集一样大，日志缓冲区大小应足够大以适应大多数事务而不会溢出，并且日志目录必须与主数据库文件在单独的物理磁盘上。数据库目录和日志目录应与用于常规系统活动（例如根，引导或交换文件系统）的磁盘分开。有关更多详细信息，请参阅FAQ-o-Matic和Berkeley DB文档。</p>
<h5 id="5-2-6-5-olcDbNosync-TRUE-FALSE"><a href="#5-2-6-5-olcDbNosync-TRUE-FALSE" class="headerlink" title="5.2.6.5 olcDbNosync: { TRUE | FALSE }"></a>5.2.6.5 olcDbNosync: { TRUE | FALSE }</h5><p>此选项会导致磁盘数据库内容在更改时不会立即与内存更改同步。将此选项设置为<code>TRUE</code>可能会牺牲数据完整性来提高性能。该指令与使用具有相同的效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbConfig: set_flags DB_TXN_NOSYNC</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-6-olcDbIDLcacheSize：-lt-integer-gt"><a href="#5-2-6-6-olcDbIDLcacheSize：-lt-integer-gt" class="headerlink" title="5.2.6.6 olcDbIDLcacheSize：&lt;integer&gt;"></a>5.2.6.6 olcDbIDLcacheSize：&lt;integer&gt;</h5><p>在索引插槽中指定内存中索引缓存的大小。默认值为零。较大的值将加快索引条目的频繁搜索。最佳大小将取决于数据库的数据和搜索特性，但使用三倍的条目缓存大小是一个很好的起点。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbIDLcacheSize: 3000</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-7-olcDbIndex-lt-attrlist-gt-default-pres-eq-approx-sub-none"><a href="#5-2-6-7-olcDbIndex-lt-attrlist-gt-default-pres-eq-approx-sub-none" class="headerlink" title="5.2.6.7 olcDbIndex: {&lt;attrlist&gt; | default} [pres,eq,approx,sub,none]"></a>5.2.6.7 olcDbIndex: {&lt;attrlist&gt; | default} [pres,eq,approx,sub,none]</h5><p>该指令指定为给定属性维护的索引。如果只给出一个<code>&lt;attrlist&gt;</code>，则会保留默认索引。索引关键字对应于可在LDAP搜索过滤器中使用的常见匹配类型。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbIndex: default pres,eq</span><br><span class="line">olcDbIndex: uid</span><br><span class="line">olcDbIndex: cn,sn pres,eq,sub</span><br><span class="line">olcDbIndex: objectClass eq</span><br></pre></td></tr></table></figure>

<p>第一行设置默认的索引集，以保持呈现和相等。第二行导致为<code>uid</code>属性类型维护默认（pres，eq）索引集。第三行导致为<code>cn</code>和<code>sn</code>属性类型维护当前，等于和子字符串索引。第四行导致<code>objectClass</code>属性类型的相等索引。</p>
<p>不等式匹配没有索引关键字。通常这些匹配不使用索引。然而，一些属性确实支持基于等式索引的不等式匹配的索引。</p>
<p>子串的索引可以更明确地指定为<code>subinitial</code>，<code>subany</code>，或<code>subfinal</code>，对应于字符串匹配滤波器的三种可能的组分。一个小数中间索引仅索引出现在属性值开头的子字符串。子索引仅索引出现在属性值末尾的子字符串，而子索引则会在值中任何位置发生子字符串索引。</p>
<p>请注意，默认情况下，为属性设置索引也会影响该属性的每个子类型。例如，在<code>name</code>属性上设置一个相等的索引会导致<code>cn</code>，<code>sn</code>和从<code>name</code>继承的每个其他属性被索引。</p>
<p>缺省情况下，没有维护索引。通常建议保持对象类的最小等同索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbindex: objectClass eq</span><br></pre></td></tr></table></figure>

<p>应根据在数据库中使用的最常见的搜索来配置其他索引。除非属性在数据库中很少出现，否则不应为属性配置存在索引，并且在正常使用目录期间，属性上的出现搜索会非常频繁地出现。大多数应用程序不使用存在搜索，因此通常存在索引不是很有用。</p>
<p>如果slapd运行时此设置发生更改，则将运行内部任务以生成已更改的索引数据。所有的服务器操作都能像索引器一样正常工作。如果在索引任务完成之前slapd已停止，则索引将必须使用slapindex工具手动完成。</p>
<h5 id="5-2-6-8-olcDbLinearIndex-TRUE-FALSE"><a href="#5-2-6-8-olcDbLinearIndex-TRUE-FALSE" class="headerlink" title="5.2.6.8 olcDbLinearIndex: { TRUE | FALSE }"></a>5.2.6.8 olcDbLinearIndex: { TRUE | FALSE }</h5><p>如果此设置为<code>TRUE</code>， slapindex将一次为一个属性索引。默认设置为<code>FALSE</code>，在这种情况下，条目的所有索引属性都将同时处理。启用时，每个索引属性都被单独处理，使用遍历整个数据库的多次遍历。当数据库大小超过BDB缓存大小时，此选项可提高slapindex性能。当BDB缓存足够大时，不需要此选项并降低性能。同样默认情况下，slapadd执行完整的索引，因此不需要单独的slapindex运行。使用此选项，slapadd不进行索引编译，并且必须使用slapindex。</p>
<h5 id="5-2-6-9-olcDbMode-lt-octal-gt-lt-symbolic-gt"><a href="#5-2-6-9-olcDbMode-lt-octal-gt-lt-symbolic-gt" class="headerlink" title="5.2.6.9 olcDbMode: { &lt;octal&gt; | &lt;symbolic&gt; }"></a>5.2.6.9 olcDbMode: { &lt;octal&gt; | &lt;symbolic&gt; }</h5><p>此指令指定新创建的数据库索引文件应具有的文件保护模式。这可以是<code>0600</code>或<code>-rw -------</code></p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbMode：0600</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-10-olcDbSearchStack-lt-integer-gt"><a href="#5-2-6-10-olcDbSearchStack-lt-integer-gt" class="headerlink" title="5.2.6.10 olcDbSearchStack: &lt;integer&gt;"></a>5.2.6.10 olcDbSearchStack: &lt;integer&gt;</h5><p>指定用于搜索过滤器评估的堆栈的深度。搜索过滤器在堆栈中进行评估，以适应嵌套的<code>AND</code> / <code>OR</code>条款。为每个服务器线程分配单个堆栈。堆栈的深度决定了如何复杂的过滤器可以被评估，而不需要额外的内存分配。比搜索堆栈深度嵌套的过滤器将导致为该特定搜索操作分配单独的堆栈。这些单独的分配可能对服务器性能造成严重的负面影响，但是指定太多堆栈也将消耗大量内存。每个搜索在32位计算机上每级使用512K字节，或64位计算机上每级的1024K字节。默认堆栈深度为16，因此在32位和64位机器上分别使用每个线程8MB或16MB。同样512KB大小的单个堆栈槽由编译时常数设置，如果需要可以更改;</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbSearchStack: 16</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-11-olcDbShmKey-lt-integer-gt"><a href="#5-2-6-11-olcDbShmKey-lt-integer-gt" class="headerlink" title="5.2.6.11 olcDbShmKey: &lt;integer&gt;"></a>5.2.6.11 olcDbShmKey: &lt;integer&gt;</h5><p>指定共享内存BDB环境的密钥。默认情况下，BDB环境使用内存映射文件。如果指定了非零值，它将被用作标识将容纳环境的共享内存区域的键。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcDbShmKey: 42</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-12-输出样例"><a href="#5-2-6-12-输出样例" class="headerlink" title="5.2.6.12 输出样例"></a>5.2.6.12 输出样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: olcDatabase=hdb,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcHdbConfig</span><br><span class="line">olcDatabase: hdb</span><br><span class="line">olcSuffix: &quot;dc=example,dc=com&quot;</span><br><span class="line">olcDbDirectory: /usr/local/var/openldap-data</span><br><span class="line">olcDbCacheSize: 1000</span><br><span class="line">olcDbCheckpoint: 1024 10</span><br><span class="line">olcDbConfig: set_cachesize 0 10485760 0</span><br><span class="line">olcDbConfig: set_lg_bsize 2097152</span><br><span class="line">olcDbConfig: set_lg_dir /var/tmp/bdb-log</span><br><span class="line">olcDbConfig: set_flags DB_LOG_AUTOREMOVE</span><br><span class="line">olcDbIDLcacheSize: 3000</span><br><span class="line">olcDbIndex: objectClass eq</span><br></pre></td></tr></table></figure>

<h3 id="5-3-配置举例"><a href="#5-3-配置举例" class="headerlink" title="5.3 配置举例"></a>5.3 配置举例</h3><p>以下是一个示例配置，散布说明文字。它定义了两个数据库来处理不同的部分X.500树; 两者都是BDB数据库实例。显示的行号仅供参考，不包括在实际文件中。首先，全局配置部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.    # example config file - global configuration entry</span><br><span class="line">2.    dn: cn=config</span><br><span class="line">3.    objectClass: olcGlobal</span><br><span class="line">4.    cn: config</span><br><span class="line">5.    olcReferral: ldap://root.openldap.org</span><br><span class="line">6.</span><br></pre></td></tr></table></figure>

<p>第1行是一条评论。第2-4行将其标识为全局配置条目。第5行上的<code>olcReferral：</code>指令意味着不属于下面定义的数据库之一的查询将被引用到在主机<code>root.openldap.org</code>上的标准端口（389）上运行的LDAP服务器。第6行是空白行，表示此条目的结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 7.    # internal schema</span><br><span class="line"> 8.    dn: cn=schema,cn=config</span><br><span class="line"> 9.    objectClass: olcSchemaConfig</span><br><span class="line">10.    cn: schema</span><br><span class="line">11.</span><br></pre></td></tr></table></figure>

<p>第7行是一条评论。第8-10行将此标识为模式子树的根。此条目中的实际模式定义将被硬编码为slapd，因此在此处未指定其他属性。第11行是空白行，表示此条目的结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12.    # include the core schema</span><br><span class="line">13.    include: file:///usr/local/etc/openldap/schema/core.ldif</span><br><span class="line">14.</span><br></pre></td></tr></table></figure>

<p>第12行是一条评论。第13行是以LDIF格式访问<em>核心</em>模式定义的LDIF include指令。第14行是空行。</p>
<p>接下来是数据库定义。第一个数据库是其全局应用于所有其他数据库的特殊<code>前端</code>数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15.    # global database parameters</span><br><span class="line">16.    dn: olcDatabase=frontend,cn=config</span><br><span class="line">17.    objectClass: olcDatabaseConfig</span><br><span class="line">18.    olcDatabase: frontend</span><br><span class="line">19.    olcAccess: to * by * read</span><br><span class="line">20.</span><br></pre></td></tr></table></figure>

<p>第15行是一条评论。第16-18行将此条目标识为全局数据库条目。第19行是一个全局访问控制。它适用于所有条目（在任何适用的特定于数据库的访问控制之后）。第20行是空行。</p>
<p>下一个条目定义了配置后端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21.    # set a rootpw for the config database so we can bind.</span><br><span class="line">22.    # deny access to everyone else.</span><br><span class="line">23.    dn: olcDatabase=config,cn=config</span><br><span class="line">24.    objectClass: olcDatabaseConfig</span><br><span class="line">25.    olcDatabase: config</span><br><span class="line">26.    olcRootPW: &#123;SSHA&#125;XKYnrjvGT3wZFQrDD5040US592LxsdLy</span><br><span class="line">27.    olcAccess: to * by * none</span><br><span class="line">28.</span><br></pre></td></tr></table></figure>

<p>第21-22行是评论。第23-25行将此条目标识为配置数据库条目。第26行定义了该数据库的<em>超级用户</em>密码。（DN默认为<em>“cn = config”</em>。）第27行拒绝对该数据库的所有访问，因此只有超级用户才能访问该数据库。（这已经是配置数据库中的默认访问权限，这里只是列出了说明，并且重申，除非明确配置超级用户身份验证的方式，否则配置数据库将无法访问。）</p>
<p>第28行是空行。</p>
<p>下一个条目定义了一个BDB后端，它将处理对树的“dc = example，dc = com”部分中的事物的查询。指数将被维护为几个属性，并且<code>userPassword</code>属性被保护免受未经授权的访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">29.    # BDB definition for example.com</span><br><span class="line">30.    dn: olcDatabase=bdb,cn=config</span><br><span class="line">31.    objectClass: olcDatabaseConfig</span><br><span class="line">32.    objectClass: olcBdbConfig</span><br><span class="line">33.    olcDatabase: bdb</span><br><span class="line">34.    olcSuffix: dc=example,dc=com</span><br><span class="line">35.    olcDbDirectory: /usr/local/var/openldap-data</span><br><span class="line">36.    olcRootDN: cn=Manager,dc=example,dc=com</span><br><span class="line">37.    olcRootPW: secret</span><br><span class="line">38.    olcDbIndex: uid pres,eq</span><br><span class="line">39.    olcDbIndex: cn,sn pres,eq,approx,sub</span><br><span class="line">40.    olcDbIndex: objectClass eq</span><br><span class="line">41.    olcAccess: to attrs=userPassword</span><br><span class="line">42.      by self write</span><br><span class="line">43.      by anonymous auth</span><br><span class="line">44.      by dn.base=&quot;cn=Admin,dc=example,dc=com&quot; write</span><br><span class="line">45.      by * none</span><br><span class="line">46.    olcAccess: to *</span><br><span class="line">47.      by self write</span><br><span class="line">48.      by dn.base=&quot;cn=Admin,dc=example,dc=com&quot; write</span><br><span class="line">49.      by * read</span><br></pre></td></tr></table></figure>

<p>第29行是一条评论。30-33行将此条目标识为BDB数据库配置条目。第34行指定查询传递给此数据库的DN后缀。第35行指定数据库文件将在其中生存的目录。</p>
<p>36和37行标识数据库<em>超级用户</em>条目和相关密码。此条目不受访问控制或大小或时间限制的限制。</p>
<p>第38至40行表示维持各种属性的索引。</p>
<p>第41至49行为此数据库中的条目指定访问控制。对于所有适用的条目，<code>userPassword</code>属性可由条目本身和“admin”条目写入。它可以用于认证/授权目的，但是不可读。所有其他属性可由条目和“admin”条目写入，但可由所有用户（经过身份验证或不被认证）读取。</p>
<p>第50行是空白行，表示此条目的结尾。</p>
<p>下一个条目定义另一个BDB数据库。这个处理涉及<code>dc=example,dc=net</code> subtree的查询，但是由与第一个数据库相同的实体进行管理。请注意，没有第60行，由于第19行的全局访问规则，读访问将被允许。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">51.    # BDB definition for example.net</span><br><span class="line">52.    dn: olcDatabase=bdb,cn=config</span><br><span class="line">53.    objectClass: olcDatabaseConfig</span><br><span class="line">54.    objectClass: olcBdbConfig</span><br><span class="line">55.    olcDatabase: bdb</span><br><span class="line">56.    olcSuffix: &quot;dc=example,dc=net&quot;</span><br><span class="line">57.    olcDbDirectory: /usr/local/var/openldap-data-net</span><br><span class="line">58.    olcRootDN: &quot;cn=Manager,dc=example,dc=com&quot;</span><br><span class="line">59.    olcDbIndex: objectClass eq</span><br><span class="line">60.    olcAccess: to * by users read</span><br></pre></td></tr></table></figure>

<h3 id="5-4-将旧样式slapd-conf（5）文件转换为cn-config格式"><a href="#5-4-将旧样式slapd-conf（5）文件转换为cn-config格式" class="headerlink" title="5.4 将旧样式slapd.conf（5）文件转换为cn=config格式"></a>5.4 将旧样式<em>slapd.conf</em>（5）文件转换为<em>cn=config</em>格式</h3><p>在转换为<em>cn=config</em>格式之前，您应该确保配置后端在您现有的配置文件中正确配置。虽然配置后端始终存在于slapd内，但默认情况下只能由其rootDN访问，并且没有分配默认凭据，除非您明确配置一种认证方式，否则将无法使用。</p>
<p>如果您还没有<code>database config</code>部分，请在<code>slapd.conf</code>的末尾添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database config</span><br><span class="line">rootpw VerySecret</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>由于配置后端可用于将任意代码加载到slapd进程中，因此仔细保护用于访问它的任何凭据是非常重要的。由于简单的密码容易受到密码猜测攻击，通常最好省略rootpw，只能使用SASL身份验证配置rootDN。</p>
<p>现有的<em>slapd.conf</em>（5）文件可以使用<em>slaptest</em>（8）或任何照片工具转换为新格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaptest -f /usr/local/etc/openldap/slapd.conf -F /usr/local/etc/openldap/slapd.d</span><br></pre></td></tr></table></figure>

<p>测试您可以使用默认<em>rootdn</em>和<em>上面</em>配置的<em>rootpw</em>访问<code>cn=config</code>下的条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -D cn=config -w VerySecret -b cn=config</span><br></pre></td></tr></table></figure>

<p>然后可以丢弃旧的<em>slapd.conf</em>（5）文件。如果不使用默认目录路径，请确保使用*-F<em>选项启动</em>slapd*（8）以指定配置目录。</p>
<p><strong>注意：</strong>从slapd.conf格式转换为slapd.d格式时，任何包含的文件也将集成到生成的配置数据库中。</p>
<h2 id="6-slapd配置文件"><a href="#6-slapd配置文件" class="headerlink" title="6 slapd配置文件"></a>6 slapd配置文件</h2><p>本章介绍通过<em>slapd.conf</em>（5）配置文件配置<em>slapd</em>（8）。 <em>slapd.conf</em>（5）已被弃用，只有当您的站点需要尚未更新的后台之一才能使用较新的<em>slapd-config</em>（5）系统时，才能使用它。在上一章中介绍了通过<em>slapd-config</em>（5）配置<em>slapd</em>（8）。</p>
<p><em>slapd.conf</em>（5）文件通常安装在<code>/usr/local/etc/openldap</code> 目录。可以通过命令行选项将备用配置文件位置指定为<em>slapd</em>（8）。</p>
<h3 id="6-1-配置文件格式"><a href="#6-1-配置文件格式" class="headerlink" title="6.1 配置文件格式"></a>6.1 配置文件格式</h3><p>在<em>slapd.conf</em>（5）文件由三种类型的配置信息：全局的，特定后台和特定数据库的。首先指定全局信息，然后指定与特定后端类型相关联的信息，然后跟随特定数据库实例关联的信息。可以在后端和 / 或数据库指令中覆盖全局伪指令，并且数据库伪指令可以覆盖后端伪指令。</p>
<p>以“ <code>＃</code> ”字符开头的空行和注释行将被忽略。如果一行以空格开头，则被认为是上一行的延续（即使上一行是注释）。</p>
<p>slapd.conf的一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># global configuration directives</span><br><span class="line">&lt;global config directives&gt;</span><br><span class="line"></span><br><span class="line"># backend definition</span><br><span class="line">backend &lt;typeA&gt;</span><br><span class="line">&lt;backend-specific directives&gt;</span><br><span class="line"></span><br><span class="line"># first database definition &amp; config directives</span><br><span class="line">database &lt;typeA&gt;</span><br><span class="line">&lt;database-specific directives&gt;</span><br><span class="line"></span><br><span class="line"># second database definition &amp; config directives</span><br><span class="line">database &lt;typeB&gt;</span><br><span class="line">&lt;database-specific directives&gt;</span><br><span class="line"></span><br><span class="line"># second database definition &amp; config directives</span><br><span class="line">database &lt;typeA&gt;</span><br><span class="line">&lt;database-specific directives&gt;</span><br><span class="line"></span><br><span class="line"># subsequent backend &amp; database definitions &amp; config directives</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>配置指令可能会引用参数。如果是这样，他们被空白分隔开来。如果一个参数包含空格，参数应该用双引号括起来<code>“像这样”</code>。如果参数包含双引号或反斜杠字符“ <code>\</code> ”，则该字符前面应该有一个反斜杠字符“ <code>\</code> ”。</p>
<p>该分发包含将安装在<code>/usr/local/etc/openldap</code>目录中的示例配置文件。<code>/usr/local/etc/openldap/schema</code>目录中也提供了一些包含模式定义（属性类型和对象类）的文件。</p>
<h3 id="6-2-配置文件指令"><a href="#6-2-配置文件指令" class="headerlink" title="6.2 配置文件指令"></a>6.2 配置文件指令</h3><p>本节详细介绍常用的配置指令。有关完整列表，请参阅<em>slapd.conf</em>（5）手册页。本节将配置文件指令分为全局，后端特定和特定于数据的类别，描述每个指令及其默认值（如果有），并给出其使用示例。</p>
<h4 id="6-2-1-全局指令"><a href="#6-2-1-全局指令" class="headerlink" title="6.2.1 全局指令"></a>6.2.1 全局指令</h4><p>本节中描述的指令适用于所有后端和数据库，除非在后端或数据库定义中特别覆盖。应该用实际文本替换的参数显示在括号<code>&lt;&gt;</code>中。</p>
<h5 id="6-2-1-1-access-to-by-lt-who-gt-lt-accesslevel-gt-lt-control-gt"><a href="#6-2-1-1-access-to-by-lt-who-gt-lt-accesslevel-gt-lt-control-gt" class="headerlink" title="6.2.1.1 access to  [ by &lt;who&gt; [&lt;accesslevel&gt;] [&lt;control&gt;] ]+"></a>6.2.1.1 access to  [ by &lt;who&gt; [&lt;accesslevel&gt;] [&lt;control&gt;] ]+</h5><p>该指令通过一个或多个请求者（由&lt;who&gt;指定）向一组条目和/或属性（由&lt;what&gt;指定）访问（由&lt;accesslevel&gt;指定）。有关基本用途，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/access-control.html">访问控制</a>部分。</p>
<p><strong>注意：</strong>如果没有指定<code>访问</code>指令，则默认访问控制策略<code>access to * by * read</code>，允许所有身份验证和匿名用户都可以读取访问权限。</p>
<h4 id="6-2-1-2-attributetype-lt-RFC4512-Attribute-Type-Description-gt"><a href="#6-2-1-2-attributetype-lt-RFC4512-Attribute-Type-Description-gt" class="headerlink" title="6.2.1.2 attributetype &lt;RFC4512 Attribute Type Description&gt;"></a>6.2.1.2 attributetype &lt;<a href="http://www.rfc-editor.org/rfc/rfc4512.txt">RFC4512</a> Attribute Type Description&gt;</h4><p>此指令定义属性类型。有关如何使用此指令的信息，请参阅“ <a href="http://www.openldap.org/doc/admin24/schema.html">模式规范”</a>一章</p>
<h4 id="6-2-1-3-idletimeout-lt-integer-gt"><a href="#6-2-1-3-idletimeout-lt-integer-gt" class="headerlink" title="6.2.1.3 idletimeout &lt;integer&gt;"></a>6.2.1.3 idletimeout &lt;integer&gt;</h4><p>指定强制关闭空闲客户端连接之前等待的秒数。idletimeout为0，默认值为禁用此功能。</p>
<h4 id="6-2-1-4-include-lt-filename-gt"><a href="#6-2-1-4-include-lt-filename-gt" class="headerlink" title="6.2.1.4 include &lt;filename&gt;"></a>6.2.1.4 include &lt;filename&gt;</h4><p>该指令指定slapd应该在继续当前文件的下一行之前从给定文件中读取其他配置信息。包含的文件应遵循正常的slapd配置文件格式。该文件通常用于包含包含模式规范的文件。</p>
<p><strong>注意：</strong>使用这个指令时应该小心 - 嵌套的include指令的数量没有很小的限制，没有进行环路检测。</p>
<h4 id="6-2-1-5-loglevel-lt-level-gt"><a href="#6-2-1-5-loglevel-lt-level-gt" class="headerlink" title="6.2.1.5. loglevel &lt;level&gt;"></a>6.2.1.5. loglevel &lt;level&gt;</h4><p>此指令指定调试语句和操作统计信息应该被syslog的级别（当前记录到<em>syslogd</em>（8）<code>LOG_LOCAL4</code>设施）。您必须配置OpenLDAP <code>--enable-debug</code>（默认值）才能工作（除了始终启用的两个统计级别之外）。日志级别可以被指定为整数或关键字。可以使用多个日志级别，并且级别是相加的。要显示什么号码对应于什么样的调试，用<code>-d?</code>调用slapd 或查阅下表。&lt;integer&gt;的可能值为：</p>
<p><strong>表6.1：调试级别</strong></p>
<table>
<thead>
<tr>
<th><strong>水平</strong></th>
<th><strong>描述</strong></th>
<th><strong>关键词</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>启用所有调试</td>
<td>任何</td>
</tr>
<tr>
<td>0</td>
<td>没有调试</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>跟踪函数调用</td>
<td>（0x1跟踪）</td>
</tr>
<tr>
<td>2</td>
<td>调试数据包处理</td>
<td>（0x2数据包）</td>
</tr>
<tr>
<td>4</td>
<td>重调查</td>
<td>（0x4 args）</td>
</tr>
<tr>
<td>8</td>
<td>连接管理</td>
<td>（0x8连接）</td>
</tr>
<tr>
<td>16</td>
<td>打印发送和接收的数据包</td>
<td>（0x10 BER）</td>
</tr>
<tr>
<td>32</td>
<td>搜索过滤处理</td>
<td>（0x20过滤器）</td>
</tr>
<tr>
<td>64</td>
<td>配置处理</td>
<td>（0x40配置）</td>
</tr>
<tr>
<td>128</td>
<td>访问控制列表处理</td>
<td>（0x80 ACL）</td>
</tr>
<tr>
<td>256</td>
<td>统计日志连接/操作/结果</td>
<td>（0x100统计）</td>
</tr>
<tr>
<td>512</td>
<td>统计日志条目发送</td>
<td>（0x200 stats2）</td>
</tr>
<tr>
<td>1024</td>
<td>打印与后台的通讯</td>
<td>（0x400 shell）</td>
</tr>
<tr>
<td>2048</td>
<td>打印输入解析调试</td>
<td>（0x800解析）</td>
</tr>
<tr>
<td>16384</td>
<td>syncrepl消费者处理</td>
<td>（0x4000同步）</td>
</tr>
<tr>
<td>32768</td>
<td>只有设置了记录日志级别的消息</td>
<td>（0x8000无）</td>
</tr>
</tbody></table>
<p>期望的日志级别可以作为单个整数输入，该整数将（ORed）所需的级别（十进制或十六进制符号）组合为整数列表（在内部进行ORed操作），或作为显示的名称列表在括号之间，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel 129</span><br><span class="line">loglevel 0x81</span><br><span class="line">loglevel 128 1</span><br><span class="line">loglevel 0x80 0x1</span><br><span class="line">loglevel acl跟踪</span><br></pre></td></tr></table></figure>

<p>是等同的</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel -1</span><br></pre></td></tr></table></figure>

<p>这将导致大量的调试信息被记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel conns filter</span><br></pre></td></tr></table></figure>

<p>只需记录连接并搜索过滤器处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel none</span><br></pre></td></tr></table></figure>

<p>记录无论配置的日志级别如何记录的消息。这不同于在不发生日志记录时将日志级别设置为0。至少需要“ <code>None ”</code>级才能记录高优先级消息。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel stats</span><br></pre></td></tr></table></figure>

<p>默认情况下配置基本统计记录。但是，如果未定义日志级别，则不会发生日志记录（相当于0级别）。</p>
<h4 id="6-2-1-6-objectclass-lt-RFC4512-Object-Class-Description-gt"><a href="#6-2-1-6-objectclass-lt-RFC4512-Object-Class-Description-gt" class="headerlink" title="6.2.1.6 objectclass &lt;RFC4512 Object Class Description&gt;"></a>6.2.1.6 objectclass &lt;<a href="http://www.rfc-editor.org/rfc/rfc4512.txt">RFC4512</a> Object Class Description&gt;</h4><p>该指令定义了一个对象类。有关如何使用此指令的信息，请参阅“ <a href="http://www.openldap.org/doc/admin24/schema.html">模式规范”</a>一章。</p>
<h4 id="6-2-1-7-referral-lt-URI-gt"><a href="#6-2-1-7-referral-lt-URI-gt" class="headerlink" title="6.2.1.7 referral &lt;URI&gt;"></a>6.2.1.7 referral &lt;URI&gt;</h4><p>此指令指定当slapd找不到本地数据库来处理请求时要传回的引用。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">referral ldap://root.openldap.org</span><br></pre></td></tr></table></figure>

<p>这将在OpenLDAP项目中将非本地查询引用到全局根LDAP服务器。智能LDAP客户端可以在该服务器上重新询问他们的查询，但请注意，大多数这些客户端只会知道如何处理包含主机部分和可选的可分辨名称部分的简单LDAP URL。</p>
<h4 id="6-2-1-8-sizelimit-lt-integer-gt"><a href="#6-2-1-8-sizelimit-lt-integer-gt" class="headerlink" title="6.2.1.8 sizelimit &lt;integer&gt;"></a>6.2.1.8 sizelimit &lt;integer&gt;</h4><p>此指令指定从搜索操作返回的最大条目数。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizelimit 500</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/limits.html">“限制”</a>部分和<em>slapd.conf</em>（5）。</p>
<h4 id="6-2-1-9-timelimit-lt-integer-gt"><a href="#6-2-1-9-timelimit-lt-integer-gt" class="headerlink" title="6.2.1.9 timelimit &lt;integer&gt;"></a>6.2.1.9 timelimit &lt;integer&gt;</h4><p>此指令指定slapd将花费回答搜索请求的最大秒数（实时）。如果此时尚未完成请求，将返回指示超时时间的结果。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timelimit 3600</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/limits.html">“限制”</a>部分和<em>slapd.conf</em>（5）。</p>
<h3 id="6-2-2-一般后端指令"><a href="#6-2-2-一般后端指令" class="headerlink" title="6.2.2 一般后端指令"></a>6.2.2 一般后端指令</h3><p>本节中的指令仅适用于定义它们的后端。它们由每种后端支持。后端指令适用于所有相同类型的数据库实例，根据该指令，数据库指令可能会被覆盖。</p>
<h4 id="6-2-2-1-backend-lt-type-gt"><a href="#6-2-2-1-backend-lt-type-gt" class="headerlink" title="6.2.2.1 backend &lt;type&gt;"></a>6.2.2.1 backend &lt;type&gt;</h4><p>后端该指令标志着后端声明的开始。<code>&lt;type&gt;</code>应于表6.2中列出的支持的后端类型之一。</p>
<p><strong>表6.2：数据库后端</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>bdb</td>
<td>Berkeley DB事务后端（已弃用）</td>
</tr>
<tr>
<td>dnssrv</td>
<td>DNS SRV后端</td>
</tr>
<tr>
<td>hdb</td>
<td>bdb后端的分层变体（已弃用）</td>
</tr>
<tr>
<td>ldap</td>
<td>轻量级目录访问协议（Proxy）后端</td>
</tr>
<tr>
<td>mdb</td>
<td>内存映射DB后端</td>
</tr>
<tr>
<td>meta</td>
<td>元目录后端</td>
</tr>
<tr>
<td>monitor</td>
<td>监视后端</td>
</tr>
<tr>
<td>passwd</td>
<td>提供对<em>passwd的</em>只读访问（5）</td>
</tr>
<tr>
<td>perl</td>
<td>Perl可编程后端</td>
</tr>
<tr>
<td>shell</td>
<td>Shell（外部程序）后端</td>
</tr>
<tr>
<td>sql</td>
<td>SQL可编程后端</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backend bdb</span><br></pre></td></tr></table></figure>

<p>这标志着一个新的开始 BDB 后端定义</p>
<h3 id="6-2-3-一般数据库指令"><a href="#6-2-3-一般数据库指令" class="headerlink" title="6.2.3 一般数据库指令"></a>6.2.3 一般数据库指令</h3><p>本节中的指令仅适用于定义它们的数据库。它们由每种类型的数据库支持。</p>
<h4 id="6-2-3-1-database-lt-type-gt"><a href="#6-2-3-1-database-lt-type-gt" class="headerlink" title="6.2.3.1 database &lt;type&gt;"></a>6.2.3.1 database &lt;type&gt;</h4><p>该指令标志着数据库实例声明的开始。<code>&lt;类型&gt;</code>应于表6.2中列出的支持的后端类型之一。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database bdb</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3-2-limits-lt-selector-gt-lt-limit-gt-lt-limit-gt-…"><a href="#6-2-3-2-limits-lt-selector-gt-lt-limit-gt-lt-limit-gt-…" class="headerlink" title="6.2.3.2 limits &lt;selector&gt; &lt;limit&gt; [&lt;limit&gt; […]]"></a>6.2.3.2 limits &lt;selector&gt; &lt;limit&gt; [&lt;limit&gt; […]]</h4><p>根据操作的启动器或基本DN指定时间和大小限制。</p>
<p>有关详细信息，请参阅本指南的<a href="http://www.openldap.org/doc/admin24/limits.html">“限制”</a>部分和<em>slapd.conf</em>（5）。</p>
<h4 id="6-2-3-3-readonly-on-off"><a href="#6-2-3-3-readonly-on-off" class="headerlink" title="6.2.3.3 readonly { on | off }"></a>6.2.3.3 readonly { on | off }</h4><p>该指令将数据库置于“只读”模式。任何修改数据库的尝试将返回“不愿意执行”的错误。如果设置在消费者身上，syncrepl发送的修改仍然会发生。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readonly off</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3-4-rootdn-lt-DN-gt"><a href="#6-2-3-4-rootdn-lt-DN-gt" class="headerlink" title="6.2.3.4 rootdn &lt;DN&gt;"></a>6.2.3.4 rootdn &lt;DN&gt;</h4><p>此指令指定不受该数据库操作的访问控制或管理限制限制的DN。DN不需要引用此数据库中的条目，甚至不在目录中。DN可以指SASL身份。</p>
<p>基于入门的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootdn &quot;cn=Manager,dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>基于SASL的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootdn &quot;uid=root,cn=example.com,cn=digest-md5,cn=auth&quot;</span><br></pre></td></tr></table></figure>

<p>有关[SASL认证身份](<a href="http://www.openldap.org/doc/admin24/sasl.html#SASL">http://www.openldap.org/doc/admin24/sasl.html#SASL</a> Authentication)的信息，请参阅[SASL认证](<a href="http://www.openldap.org/doc/admin24/sasl.html#SASL">http://www.openldap.org/doc/admin24/sasl.html#SASL</a> Authentication)部分。</p>
<h4 id="6-2-3-5-rootpw-lt-password-gt"><a href="#6-2-3-5-rootpw-lt-password-gt" class="headerlink" title="6.2.3.5 rootpw &lt;password&gt;"></a>6.2.3.5 rootpw &lt;password&gt;</h4><p>该指令可用于为rootdn指定DN的密码（当rootdn设置为数据库中的DN时）。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootpw secret</span><br></pre></td></tr></table></figure>

<p>还可以在<a href="http://www.rfc-editor.org/rfc/rfc2307.txt">RFC2307</a>表单中提供密码散列。 <em>slappasswd</em>（8）可用于生成密码哈希。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootpw &#123;SSHA&#125;ZKKuqbEKJfKSXhUbHG3fG8MDn9j1v4QN</span><br></pre></td></tr></table></figure>

<p>散列是使用命令<code>slappasswd -s secret</code>生成的。</p>
<h4 id="6-2-3-6-suffix-lt-dn-suffix-gt"><a href="#6-2-3-6-suffix-lt-dn-suffix-gt" class="headerlink" title="6.2.3.6 suffix &lt;dn suffix&gt;"></a>6.2.3.6 suffix &lt;dn suffix&gt;</h4><p>此指令指定将传递给此后端数据库的查询的DN后缀。可以给出多个后缀行，每个数据库定义至少需要一个。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suffix &quot;dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>以“<code>dc = example,dc = com</code>”结尾的DN的查询将传递给此后端。</p>
<p><strong>注意：</strong>当选择要传递查询的后端时，slapd按照它们在文件中显示的顺序查看每个数据库定义中的后缀行。因此，如果一个数据库后缀是另一个数据库后缀，则它必须出现在配置文件中。</p>
<h4 id="6-2-3-7-syncrepl"><a href="#6-2-3-7-syncrepl" class="headerlink" title="6.2.3.7 syncrepl"></a>6.2.3.7 syncrepl</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syncrepl rid=&lt;replica ID&gt;</span><br><span class="line">                provider=ldap[s]://&lt;hostname&gt;[:port]</span><br><span class="line">                searchbase=&lt;base DN&gt;</span><br><span class="line">                [type=refreshOnly|refreshAndPersist]</span><br><span class="line">                [interval=dd:hh:mm:ss]</span><br><span class="line">                [retry=[&lt;retry interval&gt; &lt;# of retries&gt;]+]</span><br><span class="line">                [filter=&lt;filter str&gt;]</span><br><span class="line">                [scope=sub|one|base]</span><br><span class="line">                [attrs=&lt;attr list&gt;]</span><br><span class="line">                [exattrs=&lt;attr list&gt;]</span><br><span class="line">                [attrsonly]</span><br><span class="line">                [sizelimit=&lt;limit&gt;]</span><br><span class="line">                [timelimit=&lt;limit&gt;]</span><br><span class="line">                [schemachecking=on|off]</span><br><span class="line">                [network-timeout=&lt;seconds&gt;]</span><br><span class="line">                [timeout=&lt;seconds&gt;]</span><br><span class="line">                [bindmethod=simple|sasl]</span><br><span class="line">                [binddn=&lt;DN&gt;]</span><br><span class="line">                [saslmech=&lt;mech&gt;]</span><br><span class="line">                [authcid=&lt;identity&gt;]</span><br><span class="line">                [authzid=&lt;identity&gt;]</span><br><span class="line">                [credentials=&lt;passwd&gt;]</span><br><span class="line">                [realm=&lt;realm&gt;]</span><br><span class="line">                [secprops=&lt;properties&gt;]</span><br><span class="line">                [keepalive=&lt;idle&gt;:&lt;probes&gt;:&lt;interval&gt;]</span><br><span class="line">                [starttls=yes|critical]</span><br><span class="line">                [tls_cert=&lt;file&gt;]</span><br><span class="line">                [tls_key=&lt;file&gt;]</span><br><span class="line">                [tls_cacert=&lt;file&gt;]</span><br><span class="line">                [tls_cacertdir=&lt;path&gt;]</span><br><span class="line">                [tls_reqcert=never|allow|try|demand]</span><br><span class="line">                [tls_cipher_suite=&lt;ciphers&gt;]</span><br><span class="line">                [tls_crlcheck=none|peer|all]</span><br><span class="line">                [tls_protocol_min=&lt;major&gt;[.&lt;minor&gt;]]</span><br><span class="line">                [suffixmassage=&lt;real DN&gt;]</span><br><span class="line">                [logbase=&lt;base DN&gt;]</span><br><span class="line">                [logfilter=&lt;filter str&gt;]</span><br><span class="line">                [syncdata=default|accesslog|changelog]</span><br></pre></td></tr></table></figure>

<p>该指令通过将当前的<em>slapd</em>（8）建立为运行syncrepl复制引擎的复制用户站点来将当前数据库指定为主内容的副本。主数据库位于由<code>provider</code>参数指定的复制提供程序站点。使用LDAP内容同步协议，副本数据库与主内容保持最新。有关<a href="http://www.rfc-editor.org/rfc/rfc4533.txt">协议</a>的更多信息，请参阅<a href="http://www.rfc-editor.org/rfc/rfc4533.txt">RFC4533</a>。</p>
<p><code>RID</code>参数用于当前的识别<code>的syncrepl</code>复制消费者服务器内的指令，其中<code>&lt;replica ID&gt;</code>唯一地识别由当前所描述的的syncrepl规范<code>syncrepl</code>指令。<code>&lt;replica ID&gt;</code>为非负数，长度不超过三位十进制数字。</p>
<p><code>provider</code>参数指定包含主内容作为LDAP URI复制提供者站点。<code>provider</code>参数指定的方案，主机和可选地其中该提供者的slapd实例可以发现一个端口。域名或IP地址可以用于&lt;hostname&gt;。示例是<code>ldap://provider.example.com:389</code>或<code>ldaps://192.168.1.1:636</code>。如果未指定&lt;port&gt;，则使用标准LDAP端口号（389或636）。请注意，syncrepl使用消费者启动的协议，因此其规范位于消费者站点，而<code>副本</code>规范位于提供者站点。<code>syncrepl</code>和<code>副本</code>指令定义了两个独立的复制机制。它们不代表彼此的复制对等体。</p>
<p>使用搜索规范作为其结果集定义syncrepl副本的内容。消费者slapd将根据搜索规范将搜索请求发送给提供商slapd。搜索规范包括<code>searchbase</code>，<code>scope</code>，<code>filter</code>，<code>attrs</code>，<code>exattrs</code>，<code>attrsonly</code>，<code>sizeLimit</code>和<code>timelimit </code>参数如在正常搜索规范。该<code>searchbase</code>参数没有默认值，必须指定。scope 默认为<code>sub</code>中，<code>filter </code>默认为<code>（objectclass= *） </code>，<code>attrs</code>默认为<code>“*，+”</code>来复制所有用户和操作属性，默认情况下<code>attrsonly</code>是未设置的。双方<code>的sizeLimit</code>和<code>时限</code>默认为“无限制”，只有正整数或“无限制”可能被指定。该<code>exattrs</code>选项也可被用来指定应该从输入的条目被省略属性。</p>
<p>该 LDAP内容同步协议有两种操作类型：<code>refreshOnly</code>和<code>refreshAndPersist</code>。操作类型由<code>type</code>参数指定。在<code>refreshOnly</code>操作中，在每次同步操作结束之后的间隔时间周期性地重新调度下一个同步搜索操作。间隔由<code>interval</code>参数指定。默认设置为一天。在<code>refreshAndPersist</code>操作中，同步搜索在提供者<em>slapd</em>实例中保持不变。对主副本的进一步更新将生成<code>searchResultEntry</code> 到消费者slapd作为搜索响应的持续同步搜索。</p>
<p>如果在复制期间发生错误，消费者将尝试根据重试参数重新连接，该重试参数是&lt;retry interval&gt;和&lt;＃of retries&gt; pair的列表。例如，retry =“60 10 300 3”可让消费者重新开始前10次，每60秒重试一次，然后在停止重试之前每300秒重试三次。+在&lt;＃重试次数&gt;中意味着无限期的重试，直到成功。</p>
<p>可以通过打开<code>schemachecking</code>参数，在LDAP Sync使用者站点上强制执行模式检查。如果它被打开，则每个复制的条目将被检查其模式，因为条目存储在副本内容中。副本中的每个条目都应包含模式定义所需的属性。如果它被关闭，条目将被存储，而不检查模式一致性。默认是关闭。</p>
<p><code>network-timeout</code>参数设置，消费者将等待多长时间来建立网络连接到提供商。一旦建立连接，<code>timeout</code>参数确定消费者等待初始绑定请求完成的时间。这些参数的默认值来自<em>ldap.conf</em>（5）。</p>
<p><code>binddn</code>参数给出了DN绑定为进行syncrepl搜索到提供者的slapd。它应该是具有对主数据库中的复制内容的读取访问权限的DN。</p>
<p><code>bindmethod</code>是<code>simple</code>还是<code>SASL</code>，取决于是否简单基于密码的认证或SASL连接到提供商<em>slapd</em>实例时要使用身份验证。</p>
<p>除非有足够的数据完整性和机密性保护（例如TLS或IPsec），否则不应使用简单认证。简单的身份验证需要指定<code>binddn</code>和<code>credentials</code>参数。</p>
<p>通常建议使用SASL认证。SASL身份验证需要使用<code>saslmech</code>参数来指定机制。根据机制，可以分别使用<code>authcid</code>和<code>credentials</code>来指定身份验证身份和/或凭据。所述<code>authzid</code>参数可以被用来指定一个授权身份。</p>
<p><code>realm</code>参数指定其中的某些机制认证中的身份的境界。该<code>secprops</code>参数指定赛勒斯SASL安全属性。</p>
<p><code>keepalive </code>参数设定空闲，探针和间隔用于检查套接字是否是活的值; 空闲是TCP开始发送keepalive探测之前连接需要保持空闲的秒数; 探测器是TCP连接之前应发送的Keepalive探测器的最大数量; 间隔是个体保持性探测之间的间隔（以秒为单位）。只有一些系统支持定制这些值; 否则将忽略keepalive参数，并使用系统范围的设置。例如，在240秒的空闲活动之后，keepalive =“240：10：30”将发送10次，每30秒钟一次Keepalive。如果没有收到对探测器的响应，则连接将被丢弃。</p>
<p><code>starttls </code>参数指定使用扩展操作认证的供应商之前建立TLS会话启动TLS的。如果提供了<code>critical </code>参数，则如果StartTLS请求失败，则该会话将中止。否则syncrepl会话继续而不使用TLS。tls_reqcert设置默认为<code>“demand”</code>，其他TLS设置默认与主slapd TLS设置相同。</p>
<p><code>suffixmassage</code>参数允许用户从远程目录中其DN后缀从本地目录不同拉条目。与搜索库匹配的远程条目DN的部分将被后缀名称DN替换。</p>
<p>消费者不是复制整个条目，而是可以查询数据修改的日志。这种操作模式称为<em>delta syncrepl</em>。除了上述参数之外，必须对要使用的日志适当地设置<code>logbase</code>和<code>logfilter</code>参数。所述<code>syncdata</code>参数必须设置为<code>“accesslog”</code>如果日志符合<em>slapo-accesslog</em>（5）日志格式，或<code>“更改日志”</code>如果日志符合过时的<em>更改日志</em>的格式。如果<code>syncdata</code>参数被省略或设置为<code>“default”</code> ，则日志参数将被忽略。</p>
<p><em>syncrepl</em> 复制机制是由支持<em>BDB</em>，<em>hdb</em>，以及<em>MDB</em>后端。</p>
<p>有关如何使用此指令的详细信息，请参阅本指南的“ [LDAP同步复制”](<a href="http://www.openldap.org/doc/admin24/replication.html#LDAP">http://www.openldap.org/doc/admin24/replication.html#LDAP</a> Sync Replication)一章。</p>
<h4 id="6-2-3-8-updateref-lt-URL-gt"><a href="#6-2-3-8-updateref-lt-URL-gt" class="headerlink" title="6.2.3.8 updateref &lt;URL&gt;"></a>6.2.3.8 updateref &lt;URL&gt;</h4><p>此伪指令仅适用于<em>从属</em>（或<em>阴影</em>）<em>slapd</em>（8）实例。它指定返回到在副本上提交更新请求的客户端的URL。如果指定多次，每个网址 被提供。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updateref       ldap://master.example.net</span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-BDB和HDB数据库指令"><a href="#6-2-4-BDB和HDB数据库指令" class="headerlink" title="6.2.4 BDB和HDB数据库指令"></a>6.2.4 BDB和HDB数据库指令</h3><p>此类别中的指令仅适用于 BDB 和 HDB数据库。也就是说，它们必须遵循“数据库bdb”或“数据库hdb”行，并在任何后续的“后端”或“数据库”行之前。有关BDB / HDB配置指令的完整参考，请参见<em>slapd-bdb</em>（5）。</p>
<h4 id="6-2-4-1-directory-lt-directory-gt"><a href="#6-2-4-1-directory-lt-directory-gt" class="headerlink" title="6.2.4.1 directory &lt;directory&gt;"></a>6.2.4.1 directory &lt;directory&gt;</h4><p>此伪指令指定包含数据库和关联索引的BDB文件的目录。</p>
<p>默认：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">directory /usr/local/var/openldap-data</span><br></pre></td></tr></table></figure>

<h2 id="6-3-配置文件示例"><a href="#6-3-配置文件示例" class="headerlink" title="6.3 配置文件示例"></a>6.3 配置文件示例</h2><p>以下是一个示例配置文件，其中插有说明文字。它定义了两个数据库来处理不同的部分X.500树; 两者都是BDB数据库实例。显示的行号仅供参考，不包括在实际文件中。首先，全局配置部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.    # example config file - global configuration section</span><br><span class="line">2.    include /usr/local/etc/schema/core.schema</span><br><span class="line">3.    referral ldap://root.openldap.org</span><br><span class="line">4.    access to * by * read</span><br></pre></td></tr></table></figure>

<p>第1行是一条评论。第2行包含另一个包含<em>核心</em>模式定义的配置文件。第3行的<code>referral </code>指令意味着不属于下面定义的数据库之一的查询将被引用到在主机<code>root.openldap.org</code>上的标准端口（389）上运行的LDAP服务器。</p>
<p>第4行是一个全局访问控制。它适用于所有条目（在任何适用的特定于数据库的访问控制之后）。</p>
<p>配置文件的下一部分定义了一个BDB后端，它将处理对树的“<code>dc=example,dc=com</code>”部分中的内容的查询。数据库将被复制到两个从属 slapds，一个在叛逃，另一个在判断日。指数将被维护为几个属性，并且<code>userPassword</code>属性被保护免受未经授权的访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 5.    # BDB definition for the example.com</span><br><span class="line"> 6.    database bdb</span><br><span class="line"> 7.    suffix &quot;dc=example,dc=com&quot;</span><br><span class="line"> 8.    directory /usr/local/var/openldap-data</span><br><span class="line"> 9.    rootdn &quot;cn=Manager,dc=example,dc=com&quot;</span><br><span class="line">10.    rootpw secret</span><br><span class="line">11.    # indexed attribute definitions</span><br><span class="line">12.    index uid pres,eq</span><br><span class="line">13.    index cn,sn pres,eq,approx,sub</span><br><span class="line">14.    index objectClass eq</span><br><span class="line">15.    # database access control definitions</span><br><span class="line">16.    access to attrs=userPassword</span><br><span class="line">17.        by self write</span><br><span class="line">18.        by anonymous auth</span><br><span class="line">19.        by dn.base=&quot;cn=Admin,dc=example,dc=com&quot; write</span><br><span class="line">20.        by * none</span><br><span class="line">21.    access to *</span><br><span class="line">22.        by self write</span><br><span class="line">23.        by dn.base=&quot;cn=Admin,dc=example,dc=com&quot; write</span><br><span class="line">24.        by * read</span><br></pre></td></tr></table></figure>

<p>第5行是一条评论。数据库定义的开始由第6行的数据库关键字标记。第7行指定查询传递到此数据库的DN后缀。第8行指定数据库文件将在哪个目录。</p>
<p>第9行和第10行标识数据库<em>超级用户</em>条目和相关密码。此条目不受访问控制或大小或时间限制的限制。</p>
<p>第12至14行表示维持各种属性的索引。</p>
<p>第16到24行为此数据库中的条目指定访问控制。对于所有适用的条目，<code>userPassword</code>属性可由条目本身和“admin”条目写入。它可以用于认证/授权目的，但是不可读。所有其他属性可由条目和“admin”条目写入，但可由所有用户（经过身份验证或不被认证）读取。</p>
<p>示例配置文件的下一部分定义了另一个BDB数据库。这个处理涉及<code>dc=example,dc=net</code> subtree的查询<code>，</code>但是由与第一个数据库相同的实体进行管理。请注意，没有第39行，由于第4行的全局访问规则，读访问将被允许。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">33.    # BDB definition for example.net</span><br><span class="line">34.    database bdb</span><br><span class="line">35.    suffix &quot;dc=example,dc=net&quot;</span><br><span class="line">36.    directory /usr/local/var/openldap-data-net</span><br><span class="line">37.    rootdn &quot;cn=Manager,dc=example,dc=com&quot;</span><br><span class="line">38.    index objectClass eq</span><br><span class="line">39.    access to * by users read</span><br></pre></td></tr></table></figure>

<h2 id="7-运行slapd"><a href="#7-运行slapd" class="headerlink" title="7 运行slapd"></a>7 运行slapd</h2><p><em>slapd</em>（8）被设计为作为独立服务运行。这允许服务器利用缓存，管理底层数据库的并发问题，并节省系统资源。从<em>inetd</em>（8）运行<em>不是</em>一个选项。</p>
<h3 id="7-1-命令行选项"><a href="#7-1-命令行选项" class="headerlink" title="7.1 命令行选项"></a>7.1 命令行选项</h3><p><em>slapd</em>（8）支持手册页中详细说明的许多命令行选项。本节详细介绍了一些常用的选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>此选项指定slapd的备用配置文件。默认值通常是<code>/usr/local/etc/openldap/slapd.conf</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-F &lt;slapd-config-directory&gt;</span><br></pre></td></tr></table></figure>

<p>指定slapd配置目录。默认值为<code>/usr/local/etc/openldap/slapd.d</code>。</p>
<p>如果指定了<code>-f</code>和<code>-F</code>，则配置文件将被读取并转换为config目录格式并写入指定的目录。如果未指定任何选项，slapd将尝试读取默认配置目录，然后再尝试使用默认配置文件。如果存在有效的配置目录，那么默认配置文件将被忽略。所有使用配置选项的拍照工具都遵循同样的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h &lt;URLs&gt;</span><br></pre></td></tr></table></figure>

<p>此选项指定备用侦听器配置。默认值是<code>ldap:///</code>这意味着LDAP 过度 TCP您可以指定特定的主机端口对或其他协议方案（如<code>ldaps://</code>或<code>ldapi://</code>）。</p>
<table>
<thead>
<tr>
<th><strong>网址</strong></th>
<th><strong>协议</strong></th>
<th><strong>传输</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LDAP：///</td>
<td>LDAP</td>
<td>TCP端口389</td>
</tr>
<tr>
<td>LDAPS：///</td>
<td>LDAP over SSL</td>
<td>TCP端口636</td>
</tr>
<tr>
<td>ldapi：///</td>
<td>LDAP</td>
<td>IPC（Unix域套接字）</td>
</tr>
</tbody></table>
<p>例如，-h <code>ldaps:// ldap://127.0.0.1:666 </code>将创建两个监听器：一个用于默认<code>ldaps</code>上的所有接口上的（非标准）方案<code>ldaps：//</code>端口 636 ，另外一个用于端口666 上<code>localhost</code>（<em>loopback</em>）接口上的标准<code>ldap://</code>方案。主机可以使用主机名或 IPv4 要么 IPv6 地址。端口值必须是数字。</p>
<p>对于通过IPC的LDAP，可以在URL中编码Unix域套接字的路径名。请注意，目录分隔符必须与URL特殊的任何其他字符进行URL编码。因此，套接字<code>/usr/local/var/ldapi</code>必须编码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapi://%2Fusr%2Flocal%2Fvar%2Fldapi</span><br></pre></td></tr></table></figure>

<p>ldapi：在<em>使用LDAP机制</em>中详细描述[ <a href="http://tools.ietf.org/html/draft-chu-ldap-ldapi-00">Chu-LDAPI</a> ]</p>
<p>请注意，ldapi：///传输没有被广泛实现：非OpenLDAP客户端可能无法使用它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-n &lt;service-name&gt;</span><br></pre></td></tr></table></figure>

<p>此选项指定用于记录和其他目的的服务名称。默认的服务名称是<code>slapd</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l &lt;syslog-local-user&gt;</span><br></pre></td></tr></table></figure>

<p>此选项指定<em>syslog</em>（8）设施的本地用户。值可以是<code>LOCAL0</code>，<code>LOCAL1</code>，<code>LOCAL2</code>，…和<code>LOCAL7</code>。默认值为<code>LOCAL4</code>。所有系统可能不支持此选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u user -g group</span><br></pre></td></tr></table></figure>

<p>这些选项分别指定用户和组作为运行。 <code>用户</code>可以是用户名或uid。 <code>组</code>可以是组名或gid。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r directory</span><br></pre></td></tr></table></figure>

<p>此选项指定运行时目录。打开侦听器之后，slapd将在读取任何配置文件或初始化任何后端之前将<em>chroot</em>（2）<em>chroot</em>（2）转到此目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d &lt;level&gt; | ?</span><br></pre></td></tr></table></figure>

<p>此选项将slapd调试级别设置为&lt;level&gt;。当级别是’？’ 字符，打印各种调试级别并退出slapd，无论您提供任何其他选项。当前的调试级别是</p>
<p><strong>表7.1：调试级别</strong></p>
<table>
<thead>
<tr>
<th><strong>水平</strong></th>
<th><strong>关键词</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>任何</td>
<td>启用所有调试</td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>没有调试</td>
</tr>
<tr>
<td>1</td>
<td>（0x1跟踪）</td>
<td>跟踪函数调用</td>
</tr>
<tr>
<td>2</td>
<td>（0x2数据包）</td>
<td>调试数据包处理</td>
</tr>
<tr>
<td>4</td>
<td>（0x4 args）</td>
<td>重调查</td>
</tr>
<tr>
<td>8</td>
<td>（0x8连接）</td>
<td>连接管理</td>
</tr>
<tr>
<td>16</td>
<td>（0x10 BER）</td>
<td>打印发送和接收的数据包</td>
</tr>
<tr>
<td>32</td>
<td>（0x20过滤器）</td>
<td>搜索过滤处理</td>
</tr>
<tr>
<td>64</td>
<td>（0x40配置）</td>
<td>配置处理</td>
</tr>
<tr>
<td>128</td>
<td>（0x80 ACL）</td>
<td>访问控制列表处理</td>
</tr>
<tr>
<td>256</td>
<td>（0x100统计）</td>
<td>统计日志连接/操作/结果</td>
</tr>
<tr>
<td>512</td>
<td>（0x200 stats2）</td>
<td>统计日志条目发送</td>
</tr>
<tr>
<td>1024</td>
<td>（0x400 shell）</td>
<td>打印与后台的通讯</td>
</tr>
<tr>
<td>2048</td>
<td>（0x800解析）</td>
<td>打印输入解析调试</td>
</tr>
<tr>
<td>16384</td>
<td>（0x4000同步）</td>
<td>syncrepl消费者处理</td>
</tr>
<tr>
<td>32768</td>
<td>（0x8000无）</td>
<td>只有设置了记录日志级别的消息</td>
</tr>
</tbody></table>
<p>您可以通过为每个所需级别指定一次调试选项来启用多个级别。或者，由于调试级别相加，您可以自己做数学。也就是说，如果要跟踪函数调用并观察正在处理的配置文件，可以将级别设置为这两级的总和（在这种情况下为<code>-d 65</code>）。或者，您可以让slapd做数学，（例如<code>-d 1 -d 64</code>）。有关详细信息，请<code>参阅&lt;ldap_log.h&gt;</code>。</p>
<p><strong>注意：</strong> slapd必须已经使用<code>--enable-debug</code>进行编译，以便在两个统计级别之外的任何调试信息都可用（默认值）定义。</p>
<h3 id="7-2-开始slapd"><a href="#7-2-开始slapd" class="headerlink" title="7.2 开始slapd"></a>7.2 开始slapd</h3><p>一般来说，slapd是这样运行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/libexec/slapd [&lt;option&gt;]*</span><br></pre></td></tr></table></figure>

<p>其中<code>/usr/local/libexec </code>由<code>configure</code>确定，&lt;option&gt;是上述选项之一（或<em>slapd</em>（8））。除非你已经指定了一个调试级别（包括<code>0</code>级），否则slapd会自动从控制终端进行分支和分离，并在后台运行。</p>
<h3 id="7-3-停止slapd"><a href="#7-3-停止slapd" class="headerlink" title="7.3 停止slapd"></a>7.3 停止slapd</h3><p>要安全地杀死<em>slapd</em>（8），你应该给出这样的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -INT `cat /usr/local/var/slapd.pid`</span><br></pre></td></tr></table></figure>

<p>其中<code> /usr/local/var</code>由<code>configure</code>决定。</p>
<p>通过更加激烈的方法杀死slapd可能会导致信息丢失或数据库损坏。</p>
<h2 id="8-访问控制"><a href="#8-访问控制" class="headerlink" title="8 访问控制"></a>8 访问控制</h2><h3 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h3><p>随着目录被越来越多的灵敏度数据填充，控制授予目录的访问种类变得越来越重要。例如，目录可能包含您可能需要通过合同或法律保护的机密性质的数据。或者，如果使用目录来控制对其他服务的访问，则对目录的不当访问可能会对您的站点的安全性造成攻击，从而对您的资产造成毁灭性破坏。</p>
<p>可以通过两种方法配置您的目录访问，第一种使用<a href="https://www.openldap.org/doc/admin24/slapdconfig.html">slapd配置文件</a>，第二种使用<em>slapd-config</em>（5）格式（<a href="https://www.openldap.org/doc/admin24/slapdconf2.html">配置slapd</a>）。</p>
<p>默认访问控制策略允许所有客户端读取。无论什么访问控制策略被定义，<em>rootdn</em>总是允许在一切和任何事情上的完全权限（即验证，搜索，比较，读取和写入）。</p>
<p>因此，在&lt;<em>by</em>&gt;子句中明确列出 <em>rootdn</em> 是无用的（并导致性能损失）。</p>
<p>以下部分将更详细地描述访问控制列表，并附有一些示例和建议。有关详细信息，请参阅<em>slapd.access</em>（5）。</p>
<h3 id="8-2-通过静态配置访问控制"><a href="#8-2-通过静态配置访问控制" class="headerlink" title="8.2 通过静态配置访问控制"></a>8.2 通过静态配置访问控制</h3><p>访问条目和属性由访问配置文件指令控制。访问线路的一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;access directive&gt; ::= access to &lt;what&gt;</span><br><span class="line">    [by &lt;who&gt; [&lt;access&gt;] [&lt;control&gt;] ]+</span><br><span class="line">&lt;what&gt; ::= * |</span><br><span class="line">    [dn[.&lt;basic-style&gt;]=&lt;regex&gt; | dn.&lt;scope-style&gt;=&lt;DN&gt;]</span><br><span class="line">    [filter=&lt;ldapfilter&gt;] [attrs=&lt;attrlist&gt;]</span><br><span class="line">&lt;basic-style&gt; ::= regex | exact</span><br><span class="line">&lt;scope-style&gt; ::= base | one | subtree | children</span><br><span class="line">&lt;attrlist&gt; ::= &lt;attr&gt; [val[.&lt;basic-style&gt;]=&lt;regex&gt;] | &lt;attr&gt; , &lt;attrlist&gt;</span><br><span class="line">&lt;attr&gt; ::= &lt;attrname&gt; | entry | children</span><br><span class="line">&lt;who&gt; ::= * | [anonymous | users | self</span><br><span class="line">        | dn[.&lt;basic-style&gt;]=&lt;regex&gt; | dn.&lt;scope-style&gt;=&lt;DN&gt;]</span><br><span class="line">    [dnattr=&lt;attrname&gt;]</span><br><span class="line">    [group[/&lt;objectclass&gt;[/&lt;attrname&gt;][.&lt;basic-style&gt;]]=&lt;regex&gt;]</span><br><span class="line">    [peername[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [sockname[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [domain[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [sockurl[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [set=&lt;setspec&gt;]</span><br><span class="line">    [aci=&lt;attrname&gt;]</span><br><span class="line">&lt;access&gt; ::= [self]&#123;&lt;level&gt;|&lt;priv&gt;&#125;</span><br><span class="line">&lt;level&gt; ::= none | disclose | auth | compare | search | read | write | manage</span><br><span class="line">&lt;priv&gt; ::= &#123;=|+|-&#125;&#123;m|w|r|s|c|x|d|0&#125;+</span><br><span class="line">&lt;control&gt; ::= [stop | continue | break]</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;what&gt;</code>部分选择访问适用的条目和 / 或属性，<code>&lt;who&gt;</code>部分指定哪些实体被授予访问权限，并且<code>&lt;access&gt;</code>部分指定所授予的访问权限。支持多个<code>&lt;who&gt; &lt;access&gt; &lt;control&gt;</code>三元组，允许许多实体被授予对同一组条目和属性的不同访问权限。不是所有这些访问控制选项都在这里描述; 有关更多详细信息，请参阅<em>slapd.access</em>（5）手册页。</p>
<h4 id="8-2-1-什么来控制访问"><a href="#8-2-1-什么来控制访问" class="headerlink" title="8.2.1 什么来控制访问"></a>8.2.1 什么来控制访问</h4><p>访问规范的&lt;what&gt;部分确定访问控制适用于的条目和属性。条目通常以两种方式进行选择：通过DN和过滤器。以下限定符通过DN选择条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to *</span><br><span class="line">to dn[.&lt;basic-style&gt;]=&lt;regex&gt;</span><br><span class="line">to dn.&lt;scope-style&gt;=&lt;DN&gt;</span><br></pre></td></tr></table></figure>

<p>第一个表单用于选择所有条目。第二种形式可以用于通过将正则表达式与目标条目的<em>标准化DN</em>相匹配来选择条目。（本文档中没有进一步讨论第二种形式。）第三种形式用于选择DN请求范围内的条目。<code>&lt;DN&gt;</code>是可分辨名称的字符串表示形式，如<a href="http://www.rfc-editor.org/rfc/rfc4514.txt">RFC4514所述</a>。</p>
<p>范围可以是<code>base</code>，<code>one</code>，<code>subtree</code>或<code>children</code>。当<code>基地</code>只提供DN的条目相匹配，<code>one</code>匹配，其父母为所提供的DN的条目，<code>subtree</code>的所有条目匹配，其根源在于所提供的DN子树，和<code>children</code>的所有条目匹配的DN下（但不是以项名为DN）。</p>
<p>例如，如果目录包含名为的条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: o=suffix</span><br><span class="line">1: cn=Manager,o=suffix</span><br><span class="line">2: ou=people,o=suffix</span><br><span class="line">3: uid=kdz,ou=people,o=suffix</span><br><span class="line">4: cn=addresses,uid=kdz,ou=people,o=suffix</span><br><span class="line">5: uid=hyc,ou=people,o=suffix</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn.base=&quot;ou=people,o=suffix&quot; match 2;</span><br><span class="line">dn.one=&quot;ou=people,o=suffix&quot; match 3, and 5;</span><br><span class="line">dn.subtree=&quot;ou=people,o=suffix&quot; match 2, 3, 4, and 5; and</span><br><span class="line">dn.children=&quot;ou=people,o=suffix&quot; match 3, 4, and 5.</span><br></pre></td></tr></table></figure>

<p>也可以使用过滤器选择条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to filter=&lt;ldap filter&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;ldap filter&gt;</code>是LDAP搜索过滤器的字符串表示形式，如<a href="http://www.rfc-editor.org/rfc/rfc4515.txt">RFC4515中所述</a>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to filter=(objectClass=person)</span><br></pre></td></tr></table></figure>

<p>请注意，可以通过在<code>&lt;what&gt;</code>子句中包含两个限定符来由DN和过滤器选择条目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to dn.one=&quot;ou=people,o=suffix&quot; filter=(objectClass=person)</span><br></pre></td></tr></table></figure>

<p>请注意，可以通过在<code>&lt;what&gt;</code>子句中包含两个限定符来由DN和过滤器选择条目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrs=&lt;attribute list&gt;</span><br></pre></td></tr></table></figure>

<p>通过使用单个属性名称并使用值选择器来选择属性的特定值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrs=&lt;attribute&gt; val[.&lt;style&gt;]=&lt;regex&gt;</span><br></pre></td></tr></table></figure>

<p>有两个特殊的<em>伪</em>属性<code>条目</code>和<code>子项</code>。要读取（并返回）目标条目，主体必须具有对目标<em>条目</em>属性的<code>读取</code>访问权限。要执行搜索，主题必须具有对搜索库<em>条目</em>属性的<code>搜索</code>访问权限。要添加或删除条目，主体必须<code>写入</code>到条目的访问<code>入口</code>属性，必须有<code>写</code>访问条目的父级的<code>子级</code>属性。要重命名的条目，主题必须<code>写</code>进入的访问<code>入口</code>属性并且具有对旧父级和新父级的<code>子级</code>属性的<code>写</code>访问权限。本节末尾的完整示例应该有助于清除。</p>
<p>最后，有一个特殊的条目选择器<code>“*”</code>用于选择任何条目。当没有提供其他<code>&lt;what&gt;</code>选择器时使用它。这相当于“ <code>dn=.*</code> ”</p>
<h4 id="8-2-2-谁授予访问权限"><a href="#8-2-2-谁授予访问权限" class="headerlink" title="8.2.2 谁授予访问权限"></a>8.2.2 谁授予访问权限</h4><p>&lt;who&gt;部分标识被授予访问权限的实体或实体。请注意，访问权限授予“实体”而不是“条目”。下表总结了实体说明符：</p>
<table>
<thead>
<tr>
<th><strong>Specifier</strong></th>
<th><strong>Entities</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>全部，包括匿名和经过身份验证的用户</td>
</tr>
<tr>
<td><code>anonymous</code></td>
<td>匿名（未认证）用户</td>
</tr>
<tr>
<td><code>users</code></td>
<td>认证用户</td>
</tr>
<tr>
<td><code>self</code></td>
<td>与目标条目关联的用户</td>
</tr>
<tr>
<td><code>dn[.&lt;basic-style&gt;]=&lt;regex&gt;</code></td>
<td>用户匹配正则表达式</td>
</tr>
<tr>
<td><code>dn.&lt;scope-style&gt;=&lt;DN&gt;</code></td>
<td>DN范围内的用户</td>
</tr>
</tbody></table>
<p>DN说明符的行为非常类似于&lt;what&gt;子句DN说明符。</p>
<p>还支持其他控制因素。例如，<code>&lt;who&gt;</code>可以被访问应用的条目中的DN值属性中列出的条目限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnattr=&lt;dn-valued attribute name&gt;</span><br></pre></td></tr></table></figure>

<p>dnattr规范用于授予访问其DN在条目的属性中的条目的访问权限（例如，授予访问组条目以列为组条目的所有者的任何用户的访问权限）。</p>
<p>在所有环境（或任何）环境中，某些因素可能不合适。例如，域名依赖于IP到域名查找。因为这些可以很容易被欺骗，因此应该避免领域因素。</p>
<h4 id="8-2-3-获得授权"><a href="#8-2-3-获得授权" class="headerlink" title="8.2.3 获得授权"></a>8.2.3 获得授权</h4><p>授予的&lt;access&gt;类型可以是以下之一：</p>
<p><strong>表6.4：访问级别</strong></p>
<table>
<thead>
<tr>
<th><strong>Level</strong></th>
<th><strong>权限</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>none        =</td>
<td>0</td>
<td>无法访问</td>
</tr>
<tr>
<td>disclose    =</td>
<td>d</td>
<td>需要信息披露的错误</td>
</tr>
<tr>
<td>auth        =</td>
<td>dx</td>
<td>需要验证（绑定）</td>
</tr>
<tr>
<td>compare     =</td>
<td>cdx</td>
<td>需要比较</td>
</tr>
<tr>
<td>search      =</td>
<td>scdx</td>
<td>需要应用搜索过滤器</td>
</tr>
<tr>
<td>read        =</td>
<td>rscdx</td>
<td>需要阅读搜索结果</td>
</tr>
<tr>
<td>write       =</td>
<td>wrscdx</td>
<td>需要修改/重命名</td>
</tr>
<tr>
<td>manage      =</td>
<td>mwrscdx</td>
<td>需要管理</td>
</tr>
</tbody></table>
<p>每个级别意味着所有较低级别的访问。因此，例如，给予某人<code>写</code>访问的入口也授予他们<code>阅读</code>，<code>搜索</code>，<code>比较</code>，<code>权威性</code>和<code>公开</code>访问。但是，可以使用特权说明符来授予特定权限。</p>
<h4 id="8-2-4-访问控制评估"><a href="#8-2-4-访问控制评估" class="headerlink" title="8.2.4 访问控制评估"></a>8.2.4 访问控制评估</h4><p>当评估某个请求者是否需要访问条目和/或属性时，slapd将条目和/或属性与配置文件中给出的<code>&lt;what&gt;</code>选择器进行比较。对于每个条目，数据库中提供的存储条目的访问控制（或全局访问指令，如果不保存在任何数据库中）首先应用，然后应用全局访问指令。然而，当处理访问列表时，由于全局访问列表被有效地附加到每个每个数据库列表中，所以如果结果列表不为空，则访问列表将以<code>* by * none</code>指令的隐式<code>访问</code>结束。如果没有适用于后端的访问指令，则使用默认读取。</p>
<p>在这个优先级中，访问指令按照它们在配置文件中出现的顺序进行检查。Slapd与第一个匹配条目和/或属性的<code>&lt;what&gt;</code>选择器停止。相应的访问指令是用于评估访问的一个slapd。</p>
<p>接下来，slapd将请求访问的实体与上面选择的访问指令中的<code>&lt;who&gt;</code>选择器按其出现顺序进行比较。它与第一个<code>&lt;who&gt;</code>选择符匹配请求者停止。这决定了请求访问的实体对入口和/或属性的访问。</p>
<p>最后，slapd将选定的<code>&lt;access&gt;</code>子句中授予的访问权限与客户端请求的访问进行比较。如果允许访问权限更大或相等，则授予访问权限。否则访问被拒绝。</p>
<p>访问指令的评估顺序使得它们在配置文件中的位置重要。如果一个访问指令比另一个访问指令更具体，那么它应该首先显示在配置文件中。类似地，如果一个<code>&lt;who&gt;</code>选择器比另一个更具体，那么它应该在access指令中首先出现。下面给出的访问控制示例应该有助于清楚。</p>
<h4 id="8-2-5-访问控制示例"><a href="#8-2-5-访问控制示例" class="headerlink" title="8.2.5 访问控制示例"></a>8.2.5 访问控制示例</h4><p>上述访问控制设施相当强大。本节显示了用于描述目的的一些示例。</p>
<p>一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to * by * read</span><br></pre></td></tr></table></figure>

<p>此访问指令授予对所有人的读访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">    by self write</span><br><span class="line">    by anonymous auth</span><br><span class="line">    by * read</span><br></pre></td></tr></table></figure>

<p>该指令允许用户修改其条目，允许匿名者对这些条目进行身份验证，并允许所有其他人读取这些条目。请注意，只有第一个<code>通过&lt;who&gt;</code>子句匹配。因此，匿名用户被授予<code>认证</code>，而不是<code>阅读</code>。最后一个条款也可以“ <code>被用户阅读</code> ”。</p>
<p>通常希望根据现有的保护级别来限制操作。以下显示如何使用安全强度因子（SSF）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">    by ssf=128 self write</span><br><span class="line">    by ssf=64 anonymous auth</span><br><span class="line">    by ssf=64 users read</span><br></pre></td></tr></table></figure>

<p>如果已建立强度为128或更好的安全保护，允许用户修改自己的条目，允许对匿名用户进行身份验证，并在已建立64或更好的安全保护时读取访问权限。如果客户端尚未建立足够的安全保护，则将使用隐含<code>的* none</code>子句。</p>
<p>以下示例显示了使用样式说明符在两个访问指令中按顺序选择DN的条目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.children=&quot;dc=example,dc=com&quot;</span><br><span class="line">     by * search</span><br><span class="line">access to dn.children=&quot;dc=com&quot;</span><br><span class="line">     by * read</span><br></pre></td></tr></table></figure>

<p>读取访问权限被授予<code>dc = com</code>子树下的条目，除了<code>dc = example，dc = com</code>子树之下的条目，授予搜索访问权限。由于两个访问指令都不匹配此DN，因此无法访问<code>dc = com</code>。如果这些访问指令的顺序被颠倒，则将永远不会达到尾随指令，因为<code>dc = example，dc = com</code>下的所有条目也都在<code>dc = com</code>条目下。</p>
<p>另请注意，如果没有<code>访问</code>指令与<code>&lt;who&gt;</code>子句匹配或否，<strong>访问被拒绝</strong>。也就是说，每个<code>对</code>指令的<code>访问都以``* none</code>子句隐含。当处理访问列表时，因为全局访问列表被有效地附加到每个数据库列表中，如果结果列表不为空，则访问列表将以<code>* by * none</code>指令的隐式<code>访问</code>结束。如果没有适用于后端的访问指令，则使用默认读取。</p>
<p>下一个例子再次显示了对访问指令和<code>&lt;who&gt;</code>子句的排序的重要性。它还显示了使用属性选择器来授予对特定属性和各种<code>&lt;who&gt;</code>选择器的访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.subtree=&quot;dc=example,dc=com&quot; attrs=homePhone</span><br><span class="line">    by self write</span><br><span class="line">    by dn.children=&quot;dc=example,dc=com&quot; search</span><br><span class="line">    by peername.regex=IP=10\..+ read</span><br><span class="line">access to dn.subtree=&quot;dc=example,dc=com&quot;</span><br><span class="line">    by self write</span><br><span class="line">    by dn.children=&quot;dc=example,dc=com&quot; search</span><br><span class="line">    by anonymous auth</span><br></pre></td></tr></table></figure>

<p>此示例适用于“ <code>dc = example，dc = com</code> ”子树中的条目。对于除<code>homePhone</code>之外的所有属性，一个条目可以写入自己，<code>example.com</code>条目下的条目可以由他们进行搜索，任何人除了认证/授权（总是匿名完成）之外没有访问权限（<code>由* none</code>隐含）。所述<code>HOMEPHONE</code>属性由条目，通过条目搜索下是可写<code>example.com</code>，通过从网络10连接的客户端可读的，否则不读取（隐式<code>由*无</code>）。所有其他访问被<code>* *</code>的隐式访问所拒绝。</p>
<p>有时，允许特定的DN从属性中添加或删除自己是有用的。例如，如果要创建一个组，并允许人们从成员属性中添加和删除其自己的DN，则可以使用如下所示的访问指令来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to attrs=member,entry</span><br><span class="line">     by dnattr=member selfwrite</span><br></pre></td></tr></table></figure>

<p>dnattr <code>&lt;who&gt;</code>选择器表示该访问适用于<code>成员</code>属性中列出的条目。自<code>写</code>访问选择器说，这样的成员只能从属性添加或删除自己的DN，而不是其他值。添加条目属性是必需的，因为访问该条目需要访问条目的任何属性。</p>
<h3 id="8-3-通过动态配置访问控制"><a href="#8-3-通过动态配置访问控制" class="headerlink" title="8.3 通过动态配置访问控制"></a>8.3 通过动态配置访问控制</h3><p>对slapd条目和属性的访问由olcAccess属性控制，其值是一系列访问指令。olcAccess配置的一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: &lt;access directive&gt;</span><br><span class="line">&lt;access directive&gt; ::= to &lt;what&gt;</span><br><span class="line">    [by &lt;who&gt; [&lt;access&gt;] [&lt;control&gt;] ]+</span><br><span class="line">&lt;what&gt; ::= * |</span><br><span class="line">    [dn[.&lt;basic-style&gt;]=&lt;regex&gt; | dn.&lt;scope-style&gt;=&lt;DN&gt;]</span><br><span class="line">    [filter=&lt;ldapfilter&gt;] [attrs=&lt;attrlist&gt;]</span><br><span class="line">&lt;basic-style&gt; ::= regex | exact</span><br><span class="line">&lt;scope-style&gt; ::= base | one | subtree | children</span><br><span class="line">&lt;attrlist&gt; ::= &lt;attr&gt; [val[.&lt;basic-style&gt;]=&lt;regex&gt;] | &lt;attr&gt; , &lt;attrlist&gt;</span><br><span class="line">&lt;attr&gt; ::= &lt;attrname&gt; | entry | children</span><br><span class="line">&lt;who&gt; ::= * | [anonymous | users | self</span><br><span class="line">        | dn[.&lt;basic-style&gt;]=&lt;regex&gt; | dn.&lt;scope-style&gt;=&lt;DN&gt;]</span><br><span class="line">    [dnattr=&lt;attrname&gt;]</span><br><span class="line">    [group[/&lt;objectclass&gt;[/&lt;attrname&gt;][.&lt;basic-style&gt;]]=&lt;regex&gt;]</span><br><span class="line">    [peername[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [sockname[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [domain[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [sockurl[.&lt;basic-style&gt;]=&lt;regex&gt;]</span><br><span class="line">    [set=&lt;setspec&gt;]</span><br><span class="line">    [aci=&lt;attrname&gt;]</span><br><span class="line">&lt;access&gt; ::= [self]&#123;&lt;level&gt;|&lt;priv&gt;&#125;</span><br><span class="line">&lt;level&gt; ::= none | disclose | auth | compare | search | read | write | manage</span><br><span class="line">&lt;priv&gt; ::= &#123;=|+|-&#125;&#123;m|w|r|s|c|x|d|0&#125;+</span><br><span class="line">&lt;control&gt; ::= [stop | continue | break]</span><br></pre></td></tr></table></figure>

<p>其中&lt;what&gt;部分选择访问适用的条目和/或属性，<code>&lt;who&gt;</code>部分指定哪些实体被授予访问权限，并且<code>&lt;access&gt;</code>部分指定所授予的访问权限。支持多个<code>&lt;who&gt; &lt;access&gt; &lt;control&gt;</code>三元组，允许许多实体被授予对同一组条目和属性的不同访问权限。不是所有这些访问控制选项都在这里描述; 有关更多详细信息，请参阅<em>slapd.access</em>（5）手册页。</p>
<h4 id="8-3-1-什么来控制访问"><a href="#8-3-1-什么来控制访问" class="headerlink" title="8.3.1 什么来控制访问"></a>8.3.1 什么来控制访问</h4><p>访问规范的&lt;what&gt;部分确定访问控制适用于的条目和属性。条目通常以两种方式进行选择：通过DN和过滤器。以下限定符通过DN选择条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to *</span><br><span class="line">to dn[.&lt;basic-style&gt;]=&lt;regex&gt;</span><br><span class="line">to dn.&lt;scope-style&gt;=&lt;DN&gt;</span><br></pre></td></tr></table></figure>

<p>第一个表单用于选择所有条目。第二种形式可以用于通过将正则表达式与目标条目的<em>标准化DN</em>相匹配来选择条目。（本文档中没有进一步讨论第二种形式。）第三种形式用于选择DN请求范围内的条目。&lt;DN&gt;是可分辨名称的字符串表示形式，如<a href="http://www.rfc-editor.org/rfc/rfc4514.txt">RFC4514所述</a>。</p>
<p>范围可以是<code>base</code>，<code>one</code>，<code>subtree</code>或<code>children</code>。当<code>基地</code>只提供DN的条目相匹配，<code>one</code>匹配，其父母为所提供的DN的条目，<code>subtree</code>的所有条目匹配，其根源在于所提供的DN子树，和<code>children</code>的所有条目匹配的DN下（但不是以项名为DN）。</p>
<p>例如，如果目录包含名为的条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: o=suffix</span><br><span class="line">1: cn=Manager,o=suffix</span><br><span class="line">2: ou=people,o=suffix</span><br><span class="line">3: uid=kdz,ou=people,o=suffix</span><br><span class="line">4: cn=addresses,uid=kdz,ou=people,o=suffix</span><br><span class="line">5: uid=hyc,ou=people,o=suffix</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn.base=&quot;ou=people,o=suffix&quot; match 2;</span><br><span class="line">dn.one=&quot;ou=people,o=suffix&quot; match 3, and 5;</span><br><span class="line">dn.subtree=&quot;ou=people,o=suffix&quot; match 2, 3, 4, and 5; and</span><br><span class="line">dn.children=&quot;ou=people,o=suffix&quot; match 3, 4, and 5.</span><br></pre></td></tr></table></figure>

<p>也可以使用过滤器选择条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to filter=&lt;ldap filter&gt;</span><br></pre></td></tr></table></figure>

<p>其中&lt;ldap filter&gt;是LDAP搜索过滤器的字符串表示形式，如<a href="http://www.rfc-editor.org/rfc/rfc4515.txt">RFC4515中所述</a>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to filter=(objectClass=person)</span><br></pre></td></tr></table></figure>

<p>请注意，可以通过在&lt;what&gt;子句中包含两个限定符来由DN和过滤器选择条目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to dn.one=&quot;ou=people,o=suffix&quot; filter=(objectClass=person)</span><br></pre></td></tr></table></figure>

<p>通过在&lt;what&gt;选择器中包含逗号分隔的属性名称列表来选择条目中的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrs=&lt;attribute list&gt;</span><br></pre></td></tr></table></figure>

<p>通过使用单个属性名称并使用值选择器来选择属性的特定值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrs=&lt;attribute&gt; val[.&lt;style&gt;]=&lt;regex&gt;</span><br></pre></td></tr></table></figure>

<p>有两个特殊的<em>伪</em>属性<code>条目</code>和<code>子项</code>。要读取（并返回）目标条目，主体必须具有对目标<em>条目</em>属性的<code>读取</code>访问权限。要执行搜索，主题必须具有对搜索库<em>条目</em>属性的<code>搜索</code>访问权限。要添加或删除条目，主体必须<code>写入</code>到条目的访问<code>入口</code>属性，必须有<code>写</code>访问条目的父级的<code>子级</code>属性。要重命名的条目，主题必须<code>写</code>进入的访问<code>入口</code>属性并且具有对旧父级和新父级的<code>子级</code>属性的<code>写</code>访问权限。本节末尾的完整示例应该有助于清除。</p>
<p>最后，有一个特殊的条目选择器<code>“*”</code>用于选择任何条目。当没有提供其他<code>&lt;what&gt;</code>选择器时使用它。这相当于“ <code>dn =。*</code> ”</p>
<h4 id="8-3-2-谁授予访问权限"><a href="#8-3-2-谁授予访问权限" class="headerlink" title="8.3.2 谁授予访问权限"></a>8.3.2 谁授予访问权限</h4><p>&lt;who&gt;部分标识被授予访问权限的实体或实体。请注意，访问权限授予“实体”而不是“条目”。下表总结了实体说明符：</p>
<p><strong>表5.3：访问实体指定符</strong></p>
<table>
<thead>
<tr>
<th><strong>Specifier</strong></th>
<th><strong>Entities</strong></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>全部，包括匿名和经过身份验证的用户</td>
</tr>
<tr>
<td>anonymous</td>
<td>匿名（未认证）用户</td>
</tr>
<tr>
<td>users</td>
<td>认证用户</td>
</tr>
<tr>
<td>self</td>
<td>与目标条目关联的用户</td>
</tr>
<tr>
<td>dn[.&lt;basic-style&gt;]=&lt;regex&gt;</td>
<td>用户匹配正则表达式</td>
</tr>
<tr>
<td>dn.&lt;scope-style&gt;=&lt;DN&gt;</td>
<td>DN范围内的用户</td>
</tr>
</tbody></table>
<p>DN说明符的行为非常类似于&lt;what&gt;子句DN说明符。</p>
<p>还支持其他控制因素。例如，<code>&lt;who&gt;</code>可以被访问应用的条目中的DN值属性中列出的条目限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnattr=&lt;dn-valued attribute name&gt;</span><br></pre></td></tr></table></figure>

<p>dnattr规范用于授予访问其DN在条目的属性中的条目的访问权限（例如，授予访问组条目以列为组条目的所有者的任何用户的访问权限）。</p>
<p>在所有环境（或任何）环境中，某些因素可能不合适。例如，域名依赖于IP到域名查找。因为这些可以很容易被欺骗，因此应该避免领域因素。</p>
<h4 id="8-3-3-获得授权"><a href="#8-3-3-获得授权" class="headerlink" title="8.3.3 获得授权"></a>8.3.3 获得授权</h4><p>授予的&lt;access&gt;类型可以是以下之一：</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>=0</td>
<td>无法访问</td>
</tr>
<tr>
<td>disclose</td>
<td>=d</td>
<td>需要信息披露的错</td>
</tr>
<tr>
<td>auth</td>
<td>=dx</td>
<td>需要验证（绑定）</td>
</tr>
<tr>
<td>compare</td>
<td>=cdx</td>
<td>需要比较</td>
</tr>
<tr>
<td>search</td>
<td>=scdx</td>
<td>需要应用搜索过滤器</td>
</tr>
<tr>
<td>read</td>
<td>=rscdx</td>
<td>需要阅读搜索结果</td>
</tr>
<tr>
<td>write</td>
<td>=wrscdx</td>
<td>需要修改/重命名</td>
</tr>
<tr>
<td>manage</td>
<td>=mwrscdx</td>
<td>需要管理</td>
</tr>
</tbody></table>
<p>每个级别意味着所有较低级别的访问。因此，例如，给予某人<code>写</code>访问的入口也授予他们<code>阅读</code>，<code>搜索</code>，<code>比较</code>，<code>权威性</code>和<code>公开</code>访问。但是，可以使用特权说明符来授予特定权限。</p>
<h4 id="8-3-4-访问控制评估"><a href="#8-3-4-访问控制评估" class="headerlink" title="8.3.4 访问控制评估"></a>8.3.4 访问控制评估</h4><p>当评估某个请求者是否需要访问条目和/或属性时，slapd将条目和/或属性与配置中给出的<code>&lt;what&gt;</code>选择器进行比较。对于每个条目，在数据库中提供的存储条目的访问控制（或全局访问指令，如果不保存在任何数据库中）首先应用，然后应用全局访问指令（保存在<code>前端</code>数据库定义中）。然而，当处理访问列表时，由于全局访问列表被有效地附加到每个每个数据库列表中，所以如果结果列表不为空，则访问列表将以<code>* by * none</code>指令的隐式<code>访问</code>结束。如果没有适用于后端的访问指令，则使用默认读取。</p>
<p>在此优先级内，按照配置属性中显示的顺序检查访问指令。Slapd与第一个匹配条目和/或属性的<code>&lt;what&gt;</code>选择器停止。相应的访问指令是用于评估访问的一个slapd。</p>
<p>接下来，slapd将请求访问的实体与上面选择的访问指令中的<code>&lt;who&gt;</code>选择器按其出现顺序进行比较。它与第一个<code>&lt;who&gt;</code>选择符匹配请求者停止。这决定了请求访问的实体对入口和/或属性的访问。</p>
<p>最后，slapd将选定的<code>&lt;access&gt;</code>子句中授予的访问权限与客户端请求的访问进行比较。如果允许访问权限更大或相等，则授予访问权限。否则访问被拒绝。</p>
<p>访问指令的评估顺序使得它们在配置文件中的位置重要。如果一个访问指令在其选择的条目方面比其他访问指令更具体，那么它应该首先显示在配置中。类似地，如果一个<code>&lt;who&gt;</code>选择器比另一个更具体，那么它应该在access指令中首先出现。下面给出的访问控制示例应该有助于清楚。</p>
<h4 id="8-3-5-访问控制示例"><a href="#8-3-5-访问控制示例" class="headerlink" title="8.3.5 访问控制示例"></a>8.3.5 访问控制示例</h4><p>上述访问控制设施相当强大。本节显示了用于描述目的的一些示例。</p>
<p>一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to * by * read</span><br></pre></td></tr></table></figure>

<p>此访问指令授予对所有人的读访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to *</span><br><span class="line">    by self write</span><br><span class="line">    by anonymous auth</span><br><span class="line">    by * read</span><br></pre></td></tr></table></figure>

<p>该指令允许用户修改其条目，允许匿名者对这些条目进行身份验证，并允许所有其他人读取这些条目。请注意，只有第一个<code>通过&lt;who&gt;</code>子句匹配。因此，匿名用户被授予<code>认证</code>，而不是<code>阅读</code>。最后一个条款也可以“ <code>被用户阅读</code> ”。</p>
<p>通常希望根据现有的保护级别来限制操作。以下显示如何使用安全强度因子（SSF）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to *</span><br><span class="line">    by ssf=128 self write</span><br><span class="line">    by ssf=64 anonymous auth</span><br><span class="line">    by ssf=64 users read</span><br></pre></td></tr></table></figure>

<p>该指令允许用户修改自己的条目，如果强度为128或更好的安全保护已建立，允许对匿名用户的身份验证访问，并且在强度达到64或更好的安全保护建立时读取访问权限。如果客户端尚未建立足够的安全保护，则将使用隐含的<code>by * none</code>子句。</p>
<p>以下示例显示了使用样式说明符在两个访问指令中选择DN的条目，其中排序很重要。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to dn.children=&quot;dc=example,dc=com&quot;</span><br><span class="line">     by * search</span><br><span class="line">olcAccess: to dn.children=&quot;dc=com&quot;</span><br><span class="line">     by * read</span><br></pre></td></tr></table></figure>

<p>读取访问权限被授予<code>dc = com</code>子树下的条目，除了<code>dc = example，dc = com</code>子树之下的条目，授予搜索访问权限。由于两个访问指令都不匹配此DN，因此无法访问<code>dc = com</code>。如果这些访问指令的顺序被颠倒，则将永远不会达到尾随指令，因为<code>dc = example，dc = com</code>下的所有条目也都在<code>dc = com</code>条目下。</p>
<p>另请注意，如果没有<code>olcAccess：to</code>指令匹配或否<code>由&lt;who&gt;</code>子句，<strong>访问被拒绝</strong>。当处理访问列表时，因为全局访问列表被有效地附加到每个数据库列表中，如果结果列表不为空，则访问列表将以<code>* by * none</code>指令的隐式<code>访问</code>结束。如果没有适用于后端的访问指令，则使用默认读取。</p>
<p>下一个例子再次显示了对访问指令和<code>&lt;who&gt;</code>子句的排序的重要性。它还显示了使用属性选择器来授予对特定属性和各种<code>&lt;who&gt;</code>选择器的访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to dn.subtree=&quot;dc=example,dc=com&quot; attrs=homePhone</span><br><span class="line">    by self write</span><br><span class="line">    by dn.children=dc=example,dc=com&quot; search</span><br><span class="line">    by peername.regex=IP=10\..+ read</span><br><span class="line">olcAccess: to dn.subtree=&quot;dc=example,dc=com&quot;</span><br><span class="line">    by self write</span><br><span class="line">    by dn.children=&quot;dc=example,dc=com&quot; search</span><br><span class="line">    by anonymous auth</span><br></pre></td></tr></table></figure>

<p>此示例适用于“ <code>dc = example，dc = com</code> ”子树中的条目。对于除<code>homePhone</code>之外的所有属性，一个条目可以写入自己，<code>example.com</code>条目下的条目可以由他们进行搜索，任何人除了认证/授权（总是匿名完成）之外没有访问权限（<code>由* none</code>隐含）。所述<code>HOMEPHONE</code>属性由条目，通过条目搜索下是可写<code>example.com</code>，通过从网络10连接的客户端可读的，否则不读取（隐式<code>由*无</code>）。所有其他访问被<code>* *</code>的隐式访问所拒绝。</p>
<p>有时，允许特定的DN从属性中添加或删除自己是有用的。例如，如果要创建一个组，并允许人们从成员属性中添加和删除其自己的DN，则可以使用如下所示的访问指令来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to attrs=member,entry</span><br><span class="line">     by dnattr=member selfwrite</span><br></pre></td></tr></table></figure>

<p>dnattr <code>&lt;who&gt;</code>选择器表示该访问适用于<code>成员</code>属性中列出的条目。自<code>写</code>访问选择器说，这样的成员只能从属性添加或删除自己的DN，而不是其他值。添加条目属性是必需的，因为访问该条目需要访问条目的任何属性。</p>
<h4 id="8-3-6-访问控制订购"><a href="#8-3-6-访问控制订购" class="headerlink" title="8.3.6 访问控制订购"></a>8.3.6 访问控制订购</h4><p>由于<code>olcAccess</code>指令的排序对其正确的评估至关重要，但LDAP属性通常不会保留其值的排序，因此OpenLDAP使用自定义模式扩展来维护这些值的固定排序。通过为每个值预先添加一个<code>“&#123;X&#125;”</code>数字索引来维护此顺序，与用于排序配置条目的方法类似。这些索引标签由slapd自动保存，在最初定义值时不需要指定。例如，创建设置时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: to attrs=member,entry</span><br><span class="line">     by dnattr=member selfwrite</span><br><span class="line">olcAccess: to dn.children=&quot;dc=example,dc=com&quot;</span><br><span class="line">     by * search</span><br><span class="line">olcAccess: to dn.children=&quot;dc=com&quot;</span><br><span class="line">     by * read</span><br></pre></td></tr></table></figure>

<p>当您使用slapcat或ldapsearch读取它们时，它们将包含</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: &#123;0&#125;to attrs=member,entry</span><br><span class="line">     by dnattr=member selfwrite</span><br><span class="line">olcAccess: &#123;1&#125;to dn.children=&quot;dc=example,dc=com&quot;</span><br><span class="line">     by * search</span><br><span class="line">olcAccess: &#123;2&#125;to dn.children=&quot;dc=com&quot;</span><br><span class="line">     by * read</span><br></pre></td></tr></table></figure>

<p>数字索引可用于指定使用ldapmodify编辑访问规则时要更改的特定值。可以使用该索引来代替（或除了）实际的访问值。当管理多个访问规则时，使用此数字索引非常有用。</p>
<p>例如，如果我们需要更改上面的第二个规则来授予写访问权限而不是搜索，我们可以尝试这个LDIF：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">changetype: modify</span><br><span class="line">delete: olcAccess</span><br><span class="line">olcAccess: to dn.children=&quot;dc=example,dc=com&quot; by * search</span><br><span class="line">-</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: to dn.children=&quot;dc=example,dc=com&quot; by * write</span><br><span class="line">-</span><br></pre></td></tr></table></figure>

<p>但是，此示例<strong>不能</strong>保证现有值保持原始顺序，因此很可能会导致安全配置不正确。相反，应使用数字索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">changetype: modify</span><br><span class="line">delete: olcAccess</span><br><span class="line">olcAccess: &#123;1&#125;</span><br><span class="line">-</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: &#123;1&#125;to dn.children=&quot;dc=example,dc=com&quot; by * write</span><br><span class="line">-</span><br></pre></td></tr></table></figure>

<p>此示例删除<code>olcAccess</code>属性（不管其值）的值＃1中的任何规则，并添加明确插入为值＃1的新值。结果将是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">olcAccess: &#123;0&#125;to attrs=member,entry</span><br><span class="line">     by dnattr=member selfwrite</span><br><span class="line">olcAccess: &#123;1&#125;to dn.children=&quot;dc=example,dc=com&quot;</span><br><span class="line">     by * write</span><br><span class="line">olcAccess: &#123;2&#125;to dn.children=&quot;dc=com&quot;</span><br><span class="line">     by * read</span><br></pre></td></tr></table></figure>

<p>这正是目的。</p>
<h3 id="8-4-访问控制常见示例"><a href="#8-4-访问控制常见示例" class="headerlink" title="8.4 访问控制常见示例"></a>8.4 访问控制常见示例</h3><h4 id="8-4-1-基本ACL"><a href="#8-4-1-基本ACL" class="headerlink" title="8.4.1 基本ACL"></a>8.4.1 基本ACL</h4><p>一般应该从一些基本的ACL开始，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to attrs=userPassword</span><br><span class="line">    by self =xw</span><br><span class="line">    by anonymous auth</span><br><span class="line">    by * none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  access to *</span><br><span class="line">    by self write</span><br><span class="line">    by users read</span><br><span class="line">    by * none</span><br></pre></td></tr></table></figure>

<p>第一个ACL允许用户更新（而不是读取）他们的密码，匿名用户对此属性进行身份验证，并且（隐含地）拒绝所有对他人的访问。</p>
<p>第二个ACL允许用户完全访问其条目，经过身份验证的用户读取任何内容，并（隐式）拒绝对其他人（在本例中为匿名用户）的所有访问。</p>
<h4 id="8-4-2-匹配匿名和经过身份验证的用户"><a href="#8-4-2-匹配匿名和经过身份验证的用户" class="headerlink" title="8.4.2 匹配匿名和经过身份验证的用户"></a>8.4.2 匹配匿名和经过身份验证的用户</h4><p>匿名用户具有空DN。虽然可以使用<em>dn.exact =“”</em>或<em>dn.regex =“^ $”</em>，但<em>slapd</em>（8））提供了一个匿名的简写，而应该使用它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">  by anonymous none</span><br><span class="line">  by * read</span><br></pre></td></tr></table></figure>

<p>拒绝所有访问匿名用户，同时授予他人阅读。</p>
<p>经过身份验证的用户拥有主题DN。虽然<em>dn.regex =“。+”</em>将匹配任何经过身份验证的用户，但OpenLDAP为用户提供了短用的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">  by users read</span><br><span class="line">  by * none</span><br></pre></td></tr></table></figure>

<p>此ACL在拒绝其他用户（即：匿名用户））时向已验证的用户授予读取权限。</p>
<h4 id="8-4-3-控制rootdn访问"><a href="#8-4-3-控制rootdn访问" class="headerlink" title="8.4.3 控制rootdn访问"></a>8.4.3 控制rootdn访问</h4><p>您可以在<em>slapd.conf</em>（5）或<em>slapd.d中</em>指定<em>rootdn</em>，而不指定<em>rootpw</em>。那么你必须添加一个具有相同dn的实际目录条目，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Manager,o=MyOrganization</span><br><span class="line">cn: Manager</span><br><span class="line">sn: Manager</span><br><span class="line">objectClass: person</span><br><span class="line">objectClass: top</span><br><span class="line">userPassword: &#123;SSHA&#125;someSSHAdata</span><br></pre></td></tr></table></figure>

<p>然后绑定为<em>rootdn</em>将需要对该DN进行常规绑定，这又需要对该条目的DN和<em>userPassword进行</em>身份验证访问，这可以通过ACL进行限制。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.base=&quot;cn=Manager,o=MyOrganization&quot;</span><br><span class="line">  by peername.regex=127\.0\.0\.1 auth</span><br><span class="line">  by peername.regex=192\.168\.0\..* auth</span><br><span class="line">  by users none</span><br><span class="line">  by * none</span><br></pre></td></tr></table></figure>

<p>上面的ACL只允许使用roothost从localhost和192.168.0.0/24进行绑定。</p>
<h4 id="8-4-4-使用组管理访问"><a href="#8-4-4-使用组管理访问" class="headerlink" title="8.4.4 使用组管理访问"></a>8.4.4 使用组管理访问</h4><p>有几种方法可以做到这一点。这里说明了一种方法。考虑以下DIT布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-dc=example,dc=com</span><br><span class="line">+---cn=administrators,dc=example,dc=com</span><br><span class="line">+---cn=fred blogs,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>和以下组对象（LDIF格式）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=administrators,dc=example,dc=com</span><br><span class="line">cn: administrators of this region</span><br><span class="line">objectclass: groupOfNames  (important for the group acl feature)</span><br><span class="line">member: cn=fred blogs,dc=example,dc=com</span><br><span class="line">member: cn=somebody else,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>然后，可以通过将适当<em>的group</em>子句添加到<em>slapd.conf</em>（5）中的访问指令，来授予对此组的成员的访问权限。例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.children=&quot;dc=example,dc=com&quot;</span><br><span class="line">    by self write</span><br><span class="line">    by group.exact=&quot;cn=Administrators,dc=example,dc=com&quot; write</span><br><span class="line">    by * auth</span><br></pre></td></tr></table></figure>

<p>像<em>dn</em>子句一样，还可以使用<em>expand</em>来根据目标的正则表达式匹配来扩展组名，也就是到<em>dn.regex</em>。例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.regex=&quot;(.+,)?ou=People,(dc=[^,]+,dc=[^,]+)$&quot;</span><br><span class="line">         attrs=children,entry,uid</span><br><span class="line">    by group.expand=&quot;cn=Managers,$2&quot; write</span><br><span class="line">    by users read</span><br><span class="line">    by * auth</span><br></pre></td></tr></table></figure>

<p>以上图示假定要在<em>groupOfNames</em>对象类的<em>成员</em>属性类型中找到组成员。如果您需要使用不同的组对象和/或不同的属性类型，请使用以下<em>slapd.conf</em>（5）（缩写）语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to &lt;what&gt;</span><br><span class="line">        by group/&lt;objectclass&gt;/&lt;attributename&gt;=&lt;DN&gt; &lt;access&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">  by group/organizationalRole/roleOccupant=&quot;cn=Administrator,dc=example,dc=com&quot; write</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们有一个ObjectClass <em>organizationalRole</em>，其中包含<em>roleOccupant</em>属性中的管理员DN 。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Administrator,dc=example,dc=com</span><br><span class="line">cn: Administrator</span><br><span class="line">objectclass: organizationalRole</span><br><span class="line">roleOccupant: cn=Jane Doe,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>指定的成员属性类型必须为DN或<em>NameAndOptionalUID</em>语法，并且指定的对象类SHOULD允许属性类型。</p>
<h4 id="8-4-5-授予对属性子集的访问权限"><a href="#8-4-5-授予对属性子集的访问权限" class="headerlink" title="8.4.5 授予对属性子集的访问权限"></a>8.4.5 授予对属性子集的访问权限</h4><p>您可以通过在ACL <em>to</em>子句中指定属性名称列表来授予对一组属性的访问权限。为了有用，您还需要授予对该<em>条目</em>本身的访问权限。还要注意<em>儿童</em>如何控制添加，删除和重命名条目的能力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mail: self may write, authenticated users may read</span><br><span class="line">access to attrs=mail</span><br><span class="line">  by self write</span><br><span class="line">  by users read</span><br><span class="line">  by * none</span><br><span class="line"></span><br><span class="line"># cn, sn: self my write, all may read</span><br><span class="line">access to attrs=cn,sn</span><br><span class="line">  by self write</span><br><span class="line">  by * read</span><br><span class="line"></span><br><span class="line"># immediate children: only self can add/delete entries under this entry</span><br><span class="line">access to attrs=children</span><br><span class="line">  by self write</span><br><span class="line"></span><br><span class="line"># entry itself: self may write, all may read</span><br><span class="line">access to attrs=entry</span><br><span class="line">  by self write</span><br><span class="line">  by * read</span><br><span class="line"></span><br><span class="line"># other attributes: self may write, others have no access</span><br><span class="line">access to *</span><br><span class="line">  by self write</span><br><span class="line">  by * none</span><br></pre></td></tr></table></figure>

<p>也可以在此列表中指定ObjectClass名称，这将影响该<em>objectClass</em>所需和/或允许的所有属性。实际上，以前缀为*@* 是 <em>attrlist</em>中的名称直接被视为objectClass名称。一个名字作为前缀<em>！</em>也被视为一个对象类，但在这种情况下，访问规则影响不需要的，也不由允许的属性<em>对象类</em>。</p>
<h4 id="8-4-6-允许用户写入其下的所有条目"><a href="#8-4-6-允许用户写入其下的所有条目" class="headerlink" title="8.4.6 允许用户写入其下的所有条目"></a>8.4.6 允许用户写入其下的所有条目</h4><p>对于用户可以写入自己的记录及其所有子项的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.regex=&quot;(.+,)?(uid=[^,]+,o=Company)$&quot;</span><br><span class="line">   by dn.exact,expand=&quot;$2&quot; write</span><br><span class="line">   by anonymous auth</span><br></pre></td></tr></table></figure>

<p>（添加上面的更多示例）</p>
<h4 id="8-4-7-允许创建条目"><a href="#8-4-7-允许创建条目" class="headerlink" title="8.4.7 允许创建条目"></a>8.4.7 允许创建条目</h4><p>假设你有这样的想法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o=&lt;basedn&gt;</span><br><span class="line">    ou=domains</span><br><span class="line">        associatedDomain=&lt;somedomain&gt;</span><br><span class="line">            ou=users</span><br><span class="line">                uid=&lt;someuserid&gt;</span><br><span class="line">                uid=&lt;someotheruserid&gt;</span><br><span class="line">            ou=addressbooks</span><br><span class="line">                uid=&lt;someuserid&gt;</span><br><span class="line">                    cn=&lt;someone&gt;</span><br><span class="line">                    cn=&lt;someoneelse&gt;</span><br></pre></td></tr></table></figure>

<p>而另一个域&lt;someotherdomain&gt;：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o=&lt;basedn&gt;</span><br><span class="line">    ou=domains</span><br><span class="line">        associatedDomain=&lt;someotherdomain&gt;</span><br><span class="line">            ou=users</span><br><span class="line">                uid=&lt;someuserid&gt;</span><br><span class="line">                uid=&lt;someotheruserid&gt;</span><br><span class="line">            ou=addressbooks</span><br><span class="line">                uid=&lt;someotheruserid&gt;</span><br><span class="line">                    cn=&lt;someone&gt;</span><br><span class="line">                    cn=&lt;someoneelse&gt;</span><br></pre></td></tr></table></figure>

<p>那么，如果你想用户*的uid = &lt;someuserid&gt;*以<strong>ONLY</strong>创造自己的事项，你可以写一个这样的ACL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># this rule lets users of &quot;associatedDomain=&lt;matcheddomain&gt;&quot;</span><br><span class="line"># write under &quot;ou=addressbook,associatedDomain=&lt;matcheddomain&gt;,ou=domains,o=&lt;basedn&gt;&quot;,</span><br><span class="line"># i.e. a user can write ANY entry below its domain&#x27;s address book;</span><br><span class="line"># this permission is necessary, but not sufficient, the next</span><br><span class="line"># will restrict this permission further</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">access to dn.regex=&quot;^ou=addressbook,associatedDomain=([^,]+),ou=domains,o=&lt;basedn&gt;$&quot; attrs=children</span><br><span class="line">        by dn.regex=&quot;^uid=([^,]+),ou=users,associatedDomain=$1,ou=domains,o=&lt;basedn&gt;$$&quot; write</span><br><span class="line">        by * none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Note that above the &quot;by&quot; clause needs a &quot;regex&quot; style to make sure</span><br><span class="line"># it expands to a DN that starts with a &quot;uid=&lt;someuserid&gt;&quot; pattern</span><br><span class="line"># while substituting the associatedDomain submatch from the &quot;what&quot; clause.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># This rule lets a user with &quot;uid=&lt;matcheduid&gt;&quot; of &quot;&lt;associatedDomain=matcheddomain&gt;&quot;</span><br><span class="line"># write (i.e. add, modify, delete) the entry whose DN is exactly</span><br><span class="line"># &quot;uid=&lt;matcheduid&gt;,ou=addressbook,associatedDomain=&lt;matcheddomain&gt;,ou=domains,o=&lt;basedn&gt;&quot;</span><br><span class="line"># and ANY entry as subtree of it</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">access to dn.regex=&quot;^(.+,)?uid=([^,]+),ou=addressbook,associatedDomain=([^,]+),ou=domains,o=&lt;basedn&gt;$&quot;</span><br><span class="line">        by dn.exact,expand=&quot;uid=$2,ou=users,associatedDomain=$3,ou=domains,o=&lt;basedn&gt;&quot; write</span><br><span class="line">        by * none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Note that above the &quot;by&quot; clause uses the &quot;exact&quot; style with the &quot;expand&quot;</span><br><span class="line"># modifier because now the whole pattern can be rebuilt by means of the</span><br><span class="line"># submatches from the &quot;what&quot; clause, so a &quot;regex&quot; compilation and evaluation</span><br><span class="line"># is no longer required.</span><br></pre></td></tr></table></figure>

<h4 id="8-4-8-在Access-Control中使用正则表达式的提示"><a href="#8-4-8-在Access-Control中使用正则表达式的提示" class="headerlink" title="8.4.8 在Access Control中使用正则表达式的提示"></a>8.4.8 在Access Control中使用正则表达式的提示</h4><p>当您打算使用正则表达式匹配时，始终使用*dn.regex = &lt;pattern&gt;<em>。</em>dn = &lt;pattern&gt;<em>单独默认为</em>dn.exact &lt;pattern&gt;*。</p>
<p>当您想要至少匹配一个字符时，使用<em>（.+）</em>而不是<em>（.*）</em>。<em>（.*）也</em>匹配空字符串。</p>
<p>不要使用正则表达式，否则可以以更安全和更便宜的方式进行匹配。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn.regex=&quot;.*dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>是不安全和昂贵的：</p>
<ul>
<li>不安全，因为包含<em>dc=example，dc=com的</em>任何字符串都不会匹配，而不是以所需的模式结束的字符串; 使用** dc=example，dc=com $*。</li>
<li>不安全，因为它将允许任何<em>attributeType</em>以<em>dc</em>结尾为字符串中第一个RDN的命名属性，例如自定义的attributeType <em>mydc</em>也会匹配。如果真的需要一个正则表达式，它只允许<em>dc=example，dc=com</em>或其任何子树，请使用*^(,+,)？dc = example，dc = com $*，这意味着：dc=…（如果有的话（括号内的模式后面的问号）必须以逗号结尾;</li>
<li>昂贵，因为如果你不需要submatches，你可以使用范围设计样式，例如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn.subtree=&quot;dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>在匹配模式中包括<em>dc = example，dc = com</em>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn.children=&quot;dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>从匹配模式中排除<em>dc = example，dc = com</em>，或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn.onelevel=&quot;dc=example,dc=com&quot;</span><br></pre></td></tr></table></figure>

<p>只允许一个子级匹配。</p>
<p>因为<em>ou =（。+），ou =（。+），ou=addressbooks，o=basedn</em>将匹配<em>something=bla，ou=xxx，ou=yyy，ou=addressbooks，</em>总是在正则表达式中使用<em>^</em>和*$ *，o=basedn中，ou=addressbooks，o= BaseDN中，dc=some，dc=org</p>
<p>始终使用<em>（[^，] +）</em>来表示一个RDN，因为<em>（。+）</em>可以包含任意数量的RDN; 例如<em>ou =（。+），dc = example，dc = com</em>将匹配<em>ou = My，o = Org，dc = example，dc = com</em>，这可能不是你想要的。</p>
<p>不要将rootdn添加到by子句中。对于使用rootdn身份执行的操作，ACL甚至不会被处理（否则根本就没有理由定义rootdn）。</p>
<p>使用shorthands。用户指令与经过身份验证的用户匹配，匿名指令与匿名用户匹配。</p>
<p>如果您需要的是范围和/或子字符串替换，则不要使用<em>dn.regex</em>表单来执行<by>子句。使用范围设计样式（例如，<em>精确</em>，<em>一级</em>，<em>子级</em>或<em>子树</em>），并且样式修饰符将展开以引起子字符串扩展。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.regex=&quot;.+,dc=([^,]+),dc=([^,]+)$&quot;</span><br><span class="line">  by dn.regex=&quot;^[^,],ou=Admin,dc=$1,dc=$2$$&quot; write</span><br></pre></td></tr></table></figure>

<p>虽然正确，可以安全有效地代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.regex=&quot;.+,(dc=[^,]+,dc=[^,]+)$&quot;</span><br><span class="line">  by dn.onelevel,expand=&quot;ou=Admin,$1&quot; write</span><br></pre></td></tr></table></figure>

<p>其中*&lt;what&gt;<em>子句中的正则表达式更紧凑，并且</em>&lt;by&gt;*子句中的正则表达式被具有子字符串扩展的更高效的一级方法范围取代。</p>
<h4 id="8-4-9-基于安全强度因素（ssf）授予和拒绝访问权限"><a href="#8-4-9-基于安全强度因素（ssf）授予和拒绝访问权限" class="headerlink" title="8.4.9 基于安全强度因素（ssf）授予和拒绝访问权限"></a>8.4.9 基于安全强度因素（ssf）授予和拒绝访问权限</h4><p>您可以根据安全强度因子（SSF）限制访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn=&quot;cn=example,cn=edu&quot;</span><br><span class="line">      by * ssf=256 read</span><br></pre></td></tr></table></figure>

<p>0（零）意味着没有保护，1表示完整性保护，56 DES或其他弱密码，112三重DES和其他强密码，128 RC4，Blowfish等现代强密码。</p>
<p>其他可能性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transport_ssf=&lt;n&gt;</span><br><span class="line">tls_ssf=&lt;n&gt;</span><br><span class="line">sasl_ssf=&lt;n&gt;</span><br></pre></td></tr></table></figure>

<p>建议使用256。</p>
<p>请参见<em>slapd.conf中</em>的信息（5）<em>SSF</em>。</p>
<h4 id="8-4-10-当事情不按预期工作时"><a href="#8-4-10-当事情不按预期工作时" class="headerlink" title="8.4.10 当事情不按预期工作时"></a>8.4.10 当事情不按预期工作时</h4><p>考虑这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">  by anonymous auth</span><br><span class="line"></span><br><span class="line">access to *</span><br><span class="line">  by self write</span><br><span class="line"></span><br><span class="line">access to *</span><br><span class="line">  by users read</span><br></pre></td></tr></table></figure>

<p>您可能认为这将允许任何用户登录，阅读所有内容并更改自己的数据，如果他已经登录。但是在这个例子中，只有登录工作，并且ldapsearch不返回任何数据。问题是，SLAPD逐行执行其访问配置，并在访问规则的一部分找到匹配后立即停止（这里：***）</p>
<p>要获得我们想要的文件必须阅读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">  by anonymous auth</span><br><span class="line">  by self write</span><br><span class="line">  by users read</span><br></pre></td></tr></table></figure>

<p>一般规则是：“特殊访问规则第一，通用访问规则最后”</p>
<p>另请参见<em>slapd.access</em>（5），loglevel 128和<em>slapacl</em>（8）来调试信息。</p>
<h3 id="8-5-集-根据关系授予权限"><a href="#8-5-集-根据关系授予权限" class="headerlink" title="8.5 集 - 根据关系授予权限"></a>8.5 集 - 根据关系授予权限</h3><p>集合通过示例最好地说明。以下部分将介绍几个ACL示例，以便于他们的理解。</p>
<p>（设置在访问控制FAQ条目：<a href="http://www.openldap.org/faq/data/cache/1133.html">http</a> : <a href="http://www.openldap.org/faq/data/cache/1133.html">//www.openldap.org/faq/data/cache/1133.html</a>）</p>
<p><strong>注意：</strong>集合被认为是实验性的。</p>
<h4 id="8-5-1-群组"><a href="#8-5-1-群组" class="headerlink" title="8.5.1 群组"></a>8.5.1 群组</h4><p>组的OpenLDAP ACL不会扩展组内的组，它们是具有另一组作为成员的组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=sudoadm,ou=group,dc=example,dc=com</span><br><span class="line">cn: sudoadm</span><br><span class="line">objectClass: groupOfNames</span><br><span class="line">member: uid=john,ou=people,dc=example,dc=com</span><br><span class="line">member: cn=accountadm,ou=group,dc=example,dc=com</span><br><span class="line"></span><br><span class="line">dn: cn=accountadm,ou=group,dc=example,dc=com</span><br><span class="line">cn: accountadm</span><br><span class="line">objectClass: groupOfNames</span><br><span class="line">member: uid=mary,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>如果我们使用具有上述条目的标准组ACL，并允许<code>sudoadm</code>组的成员写入某个地方，则不会包括<code>mary</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.subtree=&quot;ou=sudoers,dc=example,dc=com&quot;</span><br><span class="line">        by group.exact=&quot;cn=sudoadm,ou=group,dc=example,dc=com&quot; write</span><br><span class="line">        by * read</span><br></pre></td></tr></table></figure>

<p>使用集合，我们可以使ACL成为递归，并在组内考虑组。因此，对于每个成员，它进一步扩展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.subtree=&quot;ou=sudoers,dc=example,dc=com&quot;</span><br><span class="line">      by set=&quot;[cn=sudoadm,ou=group,dc=example,dc=com]/member* &amp; user&quot; write</span><br><span class="line">      by * read</span><br></pre></td></tr></table></figure>

<p>此设置ACL意味着：取<code>cn = sudoadm</code> DN，检查其<code>成员</code>属性（“ <code>*</code> ”表示递归），并将结果与经过身份验证的用户DN相交。如果结果不为空，则将ACL视为匹配，并授予写访问权限。</p>
<p>下图解释了如何构建这个集合：</p>
<p><img src="https://qiniu.iclouds.work/FoylQKTYLfguYkfrAUxV1bcWeofE.png" alt="图XY：填充递归组集"></p>
<p>首先我们得到<code>uid = john</code> DN。此条目没有<code>成员</code>属性，因此扩展在此停止。现在我们来到<code>cn = accountadm</code>。这个确实有一个<code>成员</code>属性，这是<code>uid = mary</code>。该<code>UID =玛丽</code>项，然而，没有成员，所以我们在这里再次停止。最后的比较是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;uid=john,ou=people,dc=example,dc=com&quot;,&quot;uid=mary,ou=people,dc=example,dc=com&quot;&#125; &amp; user</span><br></pre></td></tr></table></figure>

<p>如果经过身份验证的用户的DN是其中的任何一个，则授予写访问权限。所以这集将包括<code>玛丽</code>中<code>sudoadm</code>组，她将被允许写访问。</p>
<h4 id="8-5-2-没有DN语法的组ACL"><a href="#8-5-2-没有DN语法的组ACL" class="headerlink" title="8.5.2 没有DN语法的组ACL"></a>8.5.2 没有DN语法的组ACL</h4><p>传统的组ACL，甚至上一个关于递归组的例子，都要求成员被指定为DN而不是用户名。</p>
<p>然而，使用集合，也可以在组ACL中使用简单的名称，如该示例所示。</p>
<p>假设我们要允许<code>sudoadm</code>组的成员写入我们树的<code>ou = suders</code>分支。但是我们现在的组定义是使用<code>memberUid</code>作为组成员：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=sudoadm,ou=group,dc=example,dc=com</span><br><span class="line">cn: sudoadm</span><br><span class="line">objectClass: posixGroup</span><br><span class="line">gidNumber: 1000</span><br><span class="line">memberUid: john</span><br></pre></td></tr></table></figure>

<p>使用这种类型的组，我们不能使用组ACL。但是使用一组ACL，我们可以授予所需的访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.subtree=&quot;ou=sudoers,dc=example,dc=com&quot;</span><br><span class="line">      by set=&quot;[cn=sudoadm,ou=group,dc=example,dc=com]/memberUid &amp; user/uid&quot; write</span><br><span class="line">      by * read</span><br></pre></td></tr></table></figure>

<p>我们使用一个简单的交集，我们将连接（和认证）用户的<code>uid</code>属性与组的<code>memberUid</code>属性进行比较。如果匹配，交叉路口不为空，ACL将授予写入权限。</p>
<p>当连接用户被认证为<code>uid = john，ou = people，dc = example，dc = com</code>时，此图说明了该集合：</p>
<p><img src="https://qiniu.iclouds.work/Fn9FyhrGdS01P9RVlzfAuSJLfmUH.png" alt="图XY：使用`memberUid进行`设置"></p>
<p>在这种情况下，这是一场比赛。然而，如果它是<code>mary</code>验证的，她将被拒绝对<code>ou = sudoers的</code>写入权限，因为她的<code>uid</code>属性没有列在该组的<code>memberUid中</code>。</p>
<h4 id="8-5-3-以下参考"><a href="#8-5-3-以下参考" class="headerlink" title="8.5.3 以下参考"></a>8.5.3 以下参考</h4><p>现在我们将展示一个非常强大的例子，说明可以用套来做什么。这个例子倾向于使OpenLDAP管理员在理解它及其含义之后微笑。</p>
<p>我们从一个用户条目开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: uid=john,ou=people,dc=example,dc=com</span><br><span class="line">uid: john</span><br><span class="line">objectClass: inetOrgPerson</span><br><span class="line">givenName: John</span><br><span class="line">sn: Smith</span><br><span class="line">cn: john</span><br><span class="line">manager: uid=mary,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>编写ACL以允许管理员更新某些属性是非常简单的使用集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.exact=&quot;uid=john,ou=people,dc=example,dc=com&quot;</span><br><span class="line">   attrs=carLicense,homePhone,mobile,pager,telephoneNumber</span><br><span class="line">   by self write</span><br><span class="line">   by set=&quot;this/manager &amp; user&quot; write</span><br><span class="line">   by * read</span><br></pre></td></tr></table></figure>

<p>在该集合中，<code>这</code>扩展到被访问的条目，以便在访问约翰条目时，<code>该/ manager</code>扩展为<code>uid = mary，ou = people，dc = example，dc = com</code>。如果经理自己正在访问约翰的条目，则ACL将匹配，并且将授予对这些属性的写访问权限。</p>
<p>到目前为止，使用<code>dnattr</code>关键字可以获得同样的行为。然而，使用集合，我们可以进一步增强此ACL。假设我们想允许经理的秘书也更新这些属性。这是我们的做法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.exact=&quot;uid=john,ou=people,dc=example,dc=com&quot;</span><br><span class="line">   attrs=carLicense,homePhone,mobile,pager,telephoneNumber</span><br><span class="line">   by self write</span><br><span class="line">   by set=&quot;this/manager &amp; user&quot; write</span><br><span class="line">   by set=&quot;this/manager/secretary &amp; user&quot; write</span><br><span class="line">   by * read</span><br></pre></td></tr></table></figure>

<p>现在我们需要一张照片来帮助解释这里发生了什么（为了清楚起见，条目缩短）：</p>
<p><img src="https://qiniu.iclouds.work/FpRVHSwbdNwpOccDGg141q4ayWKR.png" alt="图XY：设置跳过条目"></p>
<p>在这个例子中，简是玛丽的秘书，是约翰的经理。这个整体关系由<code>经理</code>和<code>秘书</code>属性定义，它们都是distinguishedName语法（即，完整的DN）。因此，当<code>uid = john</code>条目被访问时，<code>这个/ manager / secretary</code>集合变为<code>&#123;“uid = jane，ou = people，dc = example，dc = com”</code> }（遵循图片中的引用）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this = [uid=john,ou=people,dc=example,dc=com]</span><br><span class="line">this/manager = \</span><br><span class="line">  [uid=john,ou=people,dc=example,dc=com]/manager = uid=mary,ou=people,dc=example,dc=com</span><br><span class="line">this/manager/secretary = \</span><br><span class="line">  [uid=mary,ou=people,dc=example,dc=com]/secretary = uid=jane,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>最终的结果是当Jane访问John的条目时，她将被授予对指定属性的写访问权限。更好的是，这将会发生在她访问的任何一个玛丽作为经理。</p>
<p>这是很酷和好，但也许给秘书太多的权力。也许我们需要进一步限制。例如，让我们只允许执行秘书有这样的权力：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to dn.exact=&quot;uid=john,ou=people,dc=example,dc=com&quot;</span><br><span class="line">  attrs=carLicense,homePhone,mobile,pager,telephoneNumber</span><br><span class="line">  by self write</span><br><span class="line">  by set=&quot;this/manager &amp; user&quot; write</span><br><span class="line">  by set=&quot;this/manager/secretary &amp;</span><br><span class="line">          [cn=executive,ou=group,dc=example,dc=com]/member* &amp;</span><br><span class="line">          user&quot; write</span><br><span class="line">  by * read</span><br></pre></td></tr></table></figure>

<p>它与以前几乎是一样的ACL，但我们现在也要求连接用户是（可能嵌套的）<code>cn =executive</code>组的成员。</p>
<h2 id="13-模式规范"><a href="#13-模式规范" class="headerlink" title="13 模式规范"></a>13 模式规范</h2><p>本章介绍如何扩展<em>slapd</em>（8）使用的用户模式。本章假设读者熟悉了LDAP/X.500 信息模型。</p>
<p>第一部分，[分布式模式文件](<a href="https://www.openldap.org/doc/admin24/schema.html#Distributed">https://www.openldap.org/doc/admin24/schema.html#Distributed</a> Schema Files)详细说明了分发中提供的可选模式定义以及获取其他定义的位置。第二部分“ [扩展架构](<a href="https://www.openldap.org/doc/admin24/schema.html#Extending">https://www.openldap.org/doc/admin24/schema.html#Extending</a> Schema) ”详细介绍了如何定义新的架构项目。</p>
<p>本章不讨论如何扩展<em>slapd</em>（8）使用的系统模式，因为这需要源代码修改。系统架构包括所有操作属性类型或允许或需要操作属性（直接或间接）的任何对象类。</p>
<h3 id="13-1-分布式模式文件"><a href="#13-1-分布式模式文件" class="headerlink" title="13.1 分布式模式文件"></a>13.1 分布式模式文件</h3><p>OpenLDAP软件分布有一组模式规范供您使用。每个集合都在一个适合包含（使用<code>include</code>指令）的文件中定义在您的<em>slapd.conf</em>（5）文件中。这些模式文件通常安装在<code>/usr/local/etc/openldap/schema</code>目录中。</p>
<table>
<thead>
<tr>
<th><strong>File</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>core.schema</td>
<td>OpenLDAP <em>core</em> (required)</td>
</tr>
<tr>
<td>cosine.schema</td>
<td>Cosine and Internet X.500 (useful)</td>
</tr>
<tr>
<td>inetorgperson.schema</td>
<td>InetOrgPerson (useful)</td>
</tr>
<tr>
<td>misc.schema</td>
<td>Assorted (experimental)</td>
</tr>
<tr>
<td>nis.schema</td>
<td>Network Information Services (FYI)</td>
</tr>
<tr>
<td>openldap.schema</td>
<td>OpenLDAP Project (experimental)</td>
</tr>
</tbody></table>
<p>要使用任何这些模式文件，您只需要将所需的文件包含在<em>slapd.conf</em>（5）文件的全局定义部分中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include schema</span><br><span class="line">include /usr/local/etc/openldap/schema/core.schema</span><br><span class="line">include /usr/local/etc/openldap/schema/cosine.schema</span><br><span class="line">include /usr/local/etc/openldap/schema/inetorgperson.schema</span><br></pre></td></tr></table></figure>

<p>其他文件可能可用。请咨询OpenLDAP常问问题（<a href="http://www.openldap.org/faq/">http://www.openldap.org/faq/</a>）。</p>
<p><strong>注意：</strong>不应修改提供的文件中定义的任何模式项。</p>
<h3 id="13-2-扩展架构"><a href="#13-2-扩展架构" class="headerlink" title="13.2 扩展架构"></a>13.2 扩展架构</h3><p>可以扩展<em>slapd</em>（8）使用的模式，以支持其他语法，匹配规则，属性类型和对象类。本章详细介绍了如何使用slapd支持的语法和匹配规则添加用户应用程序属性类型和对象类。slapd也可以扩展以支持额外的语法，匹配规则和系统模式，但这需要一些编程，因此这里不讨论。</p>
<p>定义新模式有五个步骤：</p>
<ol>
<li>获取对象标识符</li>
<li>选择名称前缀</li>
<li>创建本地架构文件</li>
<li>定义自定义属性类型（如有必要）</li>
<li>定义自定义对象类</li>
</ol>
<h4 id="13-2-1-对象标识符"><a href="#13-2-1-对象标识符" class="headerlink" title="13.2.1 对象标识符"></a>13.2.1 对象标识符</h4><p>每个架构元素由全局唯一标识 对象标识符（OID）。OID也用于识别其他对象。它们通常用协议描述ASN.1。特别是，它们被大量使用简单网络管理协议（SNMP）。由于OID是分级的，您的组织可以获得一个OID，并根据需要进行分支。例如，如果您的组织分配了OID <code>1.1</code>，则可以按如下方式分支树：</p>
<p><strong>表8.2：OID层次结构示例</strong></p>
<table>
<thead>
<tr>
<th><strong>OID</strong></th>
<th><strong>Assignment</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1.1</td>
<td>Organization’s OID</td>
</tr>
<tr>
<td>1.1.1</td>
<td>SNMP Elements</td>
</tr>
<tr>
<td>1.1.2</td>
<td>LDAP Elements</td>
</tr>
<tr>
<td>1.1.2.1</td>
<td>AttributeTypes</td>
</tr>
<tr>
<td>1.1.2.1.1</td>
<td>x-my-Attribute</td>
</tr>
<tr>
<td>1.1.2.2</td>
<td>ObjectClasses</td>
</tr>
<tr>
<td>1.1.2.2.1</td>
<td>x-my-ObjectClass</td>
</tr>
</tbody></table>
<p>当然，您可以自由地设计适合您组织OID下的组织需求的层次结构。不管你选择什么层次结构，你应该保留一个你所做的作业的注册表。这可以是一个简单的平面文件或更复杂的一些，例如<em>OpenLDAP OID Registry</em>（<a href="http://www.openldap.org/faq/index.cgi?file=197">http://www.openldap.org/faq/index.cgi?file=197</a>）。</p>
<p>有关对象标识符（以及列表服务）的更多信息，请参见<a href="http://www.alvestrand.no/objectid/">http://www.alvestrand.no/objectid/</a>。</p>
<p>为了获得注册的OID在<em>没有成本</em>，申请下OID <a href="http://www.iana.org/">互联网编号分配机构</a>（ORG：IANA）维护<em>民营企业</em>的弧线。任何私营企业（组织）可以要求私营企业号（PEN）被分配在这个弧。只需填写IANA表单，<a href="http://pen.iana.org/pen/PenApplication.page">网址</a>为<a href="http://pen.iana.org/pen/PenApplication.page">http://pen.iana.org/pen/PenApplication.page</a>，您的官方笔会通常在几天内发送给您。您的基地OID将像<code>1.3.6.1.4.1.X</code>这样的<code>X</code>，其中<code>X</code>是一个整数。</p>
<p>注意：使用此表单获取的PEN可用于任何目的，包括识别LDAP模式元素。</p>
<p>或者，OID名称空间可以从国家机构获得（例如，<a href="http://www.ansi.org/">ANSI</a>，<a href="http://www.bsi-global.com/">BSI</a>）。</p>
<h4 id="13-2-2-命名元素"><a href="#13-2-2-命名元素" class="headerlink" title="13.2.2 命名元素"></a>13.2.2 命名元素</h4><p>除了为每个架构元素分配唯一的对标识符之外，还应为每个元素提供至少一个文本名称。名称应该向<a href="http://www.iana.org/">IANA</a>注册，或者以“x-”为前缀，放在“私人使用”的名称空间中。</p>
<p>该名称应该是描述性的，不可能与其他模式元素的名称冲突。特别地，您选择的任何名称不应与现在或将来的标准曲目名称冲突（如果您以“x-”开头注册名称或使用名称），则可以保证。</p>
<p>请注意，您可以获得自己的注册名称前缀，以避免不必单独注册您的姓名。有关详细信息，请参阅<a href="http://www.rfc-editor.org/rfc/rfc4520.txt">RFC4520</a>。</p>
<p>在下面的例子中，我们使用了一个短的前缀’ <code>x-my-</code> ‘。这样一个短的前缀只适合于一个非常大的全球组织。一般来说，我们建议像“ <code>x-de-Firm-</code> ”（德国公司）或“ <code>x-com-Example</code> ”（与<code>example.com</code>相关的组织相关的元素）。</p>
<h4 id="13-2-3-本地架构文件"><a href="#13-2-3-本地架构文件" class="headerlink" title="13.2.3 本地架构文件"></a>13.2.3 本地架构文件</h4><p>该<code>对象类</code>和<code>attributeTypes</code>配置文件指令可以被用来在目录中的条目定义模式规则。通常要创建一个文件来包含自定义模式项的定义。我们建议您在<code>/usr/local/etc/openldap/schema/local.schema中</code>创建一个文件<code>local.schema</code>，然后在其他模式<code>include</code>指令之后立即将此文件包含在<em>slapd.conf</em>（5）文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include schema</span><br><span class="line">include /usr/local/etc/openldap/schema/core.schema</span><br><span class="line">include /usr/local/etc/openldap/schema/cosine.schema</span><br><span class="line">include /usr/local/etc/openldap/schema/inetorgperson.schema</span><br><span class="line"># include local schema</span><br><span class="line">include /usr/local/etc/openldap/schema/local.schema</span><br></pre></td></tr></table></figure>

<h4 id="13-2-4-属性类型规范"><a href="#13-2-4-属性类型规范" class="headerlink" title="13.2.4 属性类型规范"></a>13.2.4 属性类型规范</h4><p>该<em>属性类型</em>指令用于定义一个新的属性类型。该伪指令使用在子模式子条目中找到的attributeTypes属性使用的相同属性类型说明（如<a href="http://www.rfc-editor.org/rfc/rfc4512.txt">RFC4512中</a>定义），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attributetype &lt;RFC4512 Attribute Type Description&gt;</span><br></pre></td></tr></table></figure>

<p>其中属性类型描述由以下定义 ABNF：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AttributeTypeDescription = &quot;(&quot; whsp</span><br><span class="line">      numericoid whsp              ; AttributeType identifier</span><br><span class="line">    [ &quot;NAME&quot; qdescrs ]             ; name used in AttributeType</span><br><span class="line">    [ &quot;DESC&quot; qdstring ]            ; description</span><br><span class="line">    [ &quot;OBSOLETE&quot; whsp ]</span><br><span class="line">    [ &quot;SUP&quot; woid ]                 ; derived from this other</span><br><span class="line">                                   ; AttributeType</span><br><span class="line">    [ &quot;EQUALITY&quot; woid              ; Matching Rule name</span><br><span class="line">    [ &quot;ORDERING&quot; woid              ; Matching Rule name</span><br><span class="line">    [ &quot;SUBSTR&quot; woid ]              ; Matching Rule name</span><br><span class="line">    [ &quot;SYNTAX&quot; whsp noidlen whsp ] ; Syntax OID</span><br><span class="line">    [ &quot;SINGLE-VALUE&quot; whsp ]        ; default multi-valued</span><br><span class="line">    [ &quot;COLLECTIVE&quot; whsp ]          ; default not collective</span><br><span class="line">    [ &quot;NO-USER-MODIFICATION&quot; whsp ]; default user modifiable</span><br><span class="line">    [ &quot;USAGE&quot; whsp AttributeUsage ]; default userApplications</span><br><span class="line">    whsp &quot;)&quot;</span><br><span class="line"></span><br><span class="line">AttributeUsage =</span><br><span class="line">    &quot;userApplications&quot;     /</span><br><span class="line">    &quot;directoryOperation&quot;   /</span><br><span class="line">    &quot;distributedOperation&quot; / ; DSA-shared</span><br><span class="line">    &quot;dSAOperation&quot;          ; DSA-specific, value depends on server</span><br></pre></td></tr></table></figure>

<p>其中whsp是空格（’ ``’），numericoid是点分十进制形式的全局唯一OID（例如<code>1.1.0</code>），qdescrs是一个或多个名称，wid是名称或OID，可选地后跟一个长度说明符（例如<code>&#123;10</code> }）。</p>
<p>例如，属性类型<code>名称</code>和<code>cn</code>在<code>core.schema</code>中定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attributeType ( 2.5.4.41 NAME &#x27;name&#x27;</span><br><span class="line">        DESC &#x27;name(s) associated with the object&#x27;</span><br><span class="line">        EQUALITY caseIgnoreMatch</span><br><span class="line">        SUBSTR caseIgnoreSubstringsMatch</span><br><span class="line">        SYNTAX 1.3.6.1.4.1.1466.115.121.1.15&#123;32768&#125; )</span><br><span class="line">attributeType ( 2.5.4.3 NAME ( &#x27;cn&#x27; &#x27;commonName&#x27; )</span><br><span class="line">        DESC &#x27;common name(s) associated with the object&#x27;</span><br><span class="line">        SUP name )</span><br></pre></td></tr></table></figure>

<p>请注意，每个定义属性的OID，提供一个简短的名称和一个简短的描述。每个名称都是OID的别名。返回结果时，<em>slapd</em>（8）返回第一个列出的名称。</p>
<p>第一个属性<code>name名称</code>包含<code>directoryString</code>（UTF-8编码Unicode）语法。语法由OID指定（1.3.6.1.4.1.1466.115.121.1.15标识directoryString语法）。指定了32768的长度建议。服务器应支持此长度的值，但可能支持更长的值。该字段不指定大小约束，因此在不强加这种大小限制的服务器（例如slapd）上被忽略。此外，相等和子串匹配使用案例忽略规则。以下是列出常用语法和匹配规则的表（<em>slapd</em>（8）支持这些和更多）。</p>
<h2 id="15-使用SASL"><a href="#15-使用SASL" class="headerlink" title="15 使用SASL"></a>15 使用SASL</h2><p>OpenLDAP客户端和服务器能够通过认证 简单的认证和安全层 （SASL）框架，详见<a href="http://www.rfc-editor.org/rfc/rfc4422.txt">RFC4422</a>。本章介绍如何在OpenLDAP中使用SASL。</p>
<p>有几种可以与SASL一起使用的行业标准认证机制，包括 GSSAPI 对于 Kerberos V， DIGEST-MD5，和 PLAIN 和 EXTERNAL 用于 传输层安全 （TLS）。</p>
<p>OpenLDAP软件提供的标准客户端工具（如<em>ldapsearch</em>（1）和<em>ldapmodify</em>（1））将默认尝试将用户认证为LDAP目录服务器使用SASL。基本身份验证服务可以由LDAP管理员设置几个步骤，允许用户对slapd服务器作为其LDAP条目进行身份验证。通过几个额外的步骤，可以允许一些用户和服务利用SASL的代理授权功能，允许他们自己进行身份验证，然后将其身份切换到另一个用户或服务的身份。</p>
<p>本章假设您已阅读<em>Cyrus SASL（系统管理员）</em>，并附带<a href="http://asg.web.cmu.edu/sasl/sasl-library.html">Cyrus SASL</a>软件包（<code>doc / sysadmin.html</code>），并安装了Cyrus SASL。您应该使用Cyrus SASL <code>sample_client</code>和<code>sample_server</code>来测试您的SASL安装，然后再尝试使用OpenLDAP软件。</p>
<p>请注意，在以下文本中，术语<em>用户</em>用于描述通过LDAP客户端（如<em>ldapsearch</em>（1））连接到LDAP服务器的人员或应用程序实体。也就是说，术语<em>用户</em>不仅适用于使用LDAP客户端的个人，而且适用于在没有直接用户控制的情况下发出LDAP客户端操作的应用程序实体。例如，使用LDAP操作访问LDAP服务器中保存的信息的电子邮件服务器是应用程序实体。</p>
<h3 id="15-1-SASL安全注意事项"><a href="#15-1-SASL安全注意事项" class="headerlink" title="15.1 SASL安全注意事项"></a>15.1 SASL安全注意事项</h3><p>SASL提供了许多不同的认证机制。本节简要概述了安全考虑。</p>
<p>一些机制，例如PLAIN和LOGIN，提供比LDAP <em>简单</em>认证更大的安全性。像LDAP <em>简单</em>认证一样，除非您有足够的安全保护，否则不应使用此类机制。建议这些机制只能与之配合使用传输层安全（TLS）。本文档不再详细讨论PLAIN和LOGIN的使用。</p>
<p>DIGEST-MD5机制是LDAPv3的强制实施认证机制。虽然与受信任的第三方认证系统相比，DIGEST-MD5不是一种强大的认证机制Kerberos的或公共密钥系统），它确实提供了对许多攻击的重大保护。不一样CRAM-MD5机制，防止选择明文攻击。DIGEST-MD5优于使用明文密码机制。CRAM-MD5机制不赞成使用DIGEST-MD5。下面讨论<a href="http://www.openldap.org/doc/admin24/sasl.html#DIGEST-MD5">DIGEST-MD5的</a>使用。</p>
<p>GSSAPI机制使用 GSS-API Kerberos的V提供安全认证服务。KERBEROS_V4机制适用于使用Kerberos IV的机构。Kerberos被视为适合小型和大型企业的安全的分布式认证系统。下面讨论<a href="http://www.openldap.org/doc/admin24/sasl.html#GSSAPI">GSSAPI</a>和<a href="http://www.openldap.org/doc/admin24/sasl.html#KERBEROS_V4">KERBEROS_V4</a>使用。</p>
<p>EXTERNAL机制利用诸如下级网络服务提供的认证服务 传输层安全 （TLS）。与TLS X.509的公钥技术配合使用时，EXTERNAL提供强大的认证。TLS在“ <a href="http://www.openldap.org/doc/admin24/tls.html">使用TLS”</a>一章中讨论。</p>
<p>EXTERNAL也可以与<code>ldapi：///</code>传输一起使用，因为Unix-domain sockets可以报告客户端进程的UID和GID。</p>
<p>还有其他强大的认证机制可供选择，包括 OTP （一次密码）和 SRP（安全远程密码）。这些机制在本文档中没有讨论。</p>
<h3 id="15-2-SASL认证"><a href="#15-2-SASL认证" class="headerlink" title="15.2 SASL认证"></a>15.2 SASL认证</h3><p>获取基本的SASL认证运行涉及到几个步骤。第一步配置您的slapd服务器环境，以便可以使用您网站上的安全系统与客户端程序进行通信。这通常涉及设置服务密钥，公钥或其他形式的秘密。第二步涉及将身份验证身份映射到LDAPDN这取决于条目在目录中的布局。将在下一节中使用Kerberos V4作为示例机制给出第一步的说明。您站点身份验证机制所需的步骤将是类似的，但SASL可用的每种机制的指南超出了本章的范围。第二步在“ [映射身份验证身份](<a href="http://www.openldap.org/doc/admin24/sasl.html#Mapping">http://www.openldap.org/doc/admin24/sasl.html#Mapping</a> Authentication Identities) ”一节中描述。</p>
<h4 id="15-2-1-GSSAPI"><a href="#15-2-1-GSSAPI" class="headerlink" title="15.2.1 GSSAPI"></a>15.2.1 GSSAPI</h4><p>本节介绍SASL GSSAPI机制和Kerberos V与OpenLDAP的使用。将假设您已部署Kerberos V，您熟悉系统的操作，并且您的用户受到使用的培训。本节还假定您已经熟悉GSSAPI机制的使用，方法是阅读<em>配置GSSAPI和Cyrus SASL</em>（<code>doc / gssapi</code>文件中的<em>Cyrus SASL</em>提供），并成功实验了Cyrus提供的<code>sample_server</code>和<code>sample_client</code>应用程序。有关Kerberos的一般信息，请访问<a href="http://web.mit.edu/kerberos/www/">http://web.mit.edu/kerberos/www/</a>。</p>
<p>要使用具有<em>slapd</em>（8）的GSSAPI机制，必须在服务运行的主机的领域内为<em>ldap</em>服务的主体创建一个服务密钥。例如，如果在<code>directory.example.com</code>上运行<em>slapd</em>，并且您的领域是<code>EXAMPLE.COM</code>，则需要使用主体创建服务密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldap/directory.example.com@EXAMPLE.COM</span><br></pre></td></tr></table></figure>

<p>当<em>slapd</em>（8）运行时，它必须具有访问该键的权限。这通常通过将密钥放入keytab文件<code>/etc/krb5.keytab</code>。有关keytab位置设置的信息，请参阅Kerberos和Cyrus SASL文档。</p>
<p>要使用GSSAPI机制对目录进行身份验证，用户将在运行LDAP客户端之前获取授权单（TGT）。当使用OpenLDAP客户端工具时，用户可以通过将<code>-Y GSSAPI</code>指定为命令选项来<code>强制</code>使用GSSAPI机制。</p>
<p>为了进行认证和授权，<em>slapd</em>（8）将认证请求DN与以下形式相关联：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;primary[/instance]&gt;,cn=&lt;realm&gt;,cn=gssapi,cn=auth</span><br></pre></td></tr></table></figure>

<p>继续我们的例子，具有Kerberos主体<code>kurt@EXAMPLE.COM</code>的用户将具有相关的DN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=kurt,cn=example.com,cn=gssapi,cn=auth</span><br></pre></td></tr></table></figure>

<p>并且主体<code>ursula/admin@FOREIGN.REALM</code>将具有关联的DN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=ursula/admin,cn=foreign.realm,cn=gssapi,cn=auth</span><br></pre></td></tr></table></figure>

<p>认证请求DN可以直接使用ACL和<code>groupOfNames</code> “member”属性，因为它是合法的LDAP DN格式。或者，可以在使用之前映射认证DN。有关详细信息，请参阅[映射身份验证身份](<a href="http://www.openldap.org/doc/admin24/sasl.html#Mapping">http://www.openldap.org/doc/admin24/sasl.html#Mapping</a> Authentication Identities)部分。</p>
<h4 id="15-2-2-KERBEROS-V4"><a href="#15-2-2-KERBEROS-V4" class="headerlink" title="15.2.2 KERBEROS_V4"></a>15.2.2 KERBEROS_V4</h4><p>本节介绍使用SASL KERBEROS_V4机制与OpenLDAP。将假定您熟悉Kerberos IV安全系统的运行情况，并且您的站点部署了Kerberos IV。您的用户应该熟悉身份验证策略，如何在Kerberos票证缓存中接收凭据，以及如何刷新过期凭证。</p>
<p><strong>注意：</strong> KERBEROS_V4和Kerberos IV不赞成使用GSSAPI和Kerberos V.</p>
<p>客户端程序需要能够获取会话密钥，以便在连接到LDAP服务器时使用。这允许LDAP服务器知道用户的身份，并允许客户端知道它正在连接到合法的服务器。如果要使用加密层，会话密钥也可以用来帮助协商该选项。</p>
<p>slapd服务器运行名为“ <em>ldap</em> ” 的服务，服务器将需要具有服务密钥的srvtab文件。SASL感知的客户端程序将获得带有用户票证授予票据（TGT）的“ldap”服务票证，其中票据的实例与OpenLDAP服务器的主机名相匹配。例如，如果您的<code>域名</code>为<code>EXAMPLE.COM</code>，并且slapd服务器正在名为<code>directory.example.com</code>的主机上运行，则服务器上的<code>/etc/srvtab</code>文件将具有服务密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldap.directory@EXAMPLE.COM</span><br></pre></td></tr></table></figure>

<p>当LDAP客户端使用KERBEROS_IV机制将用户认证到目录时，它将从票据缓存或通过从Kerberos服务器获取一个新请求来为同一主体请求会话密钥。这将需要TGT在缓存中可用和有效。如果它不存在或已经过期，客户端可能打印出消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldap_sasl_interactive_bind_s: Local error</span><br></pre></td></tr></table></figure>

<p>获得服务票证后，将作为用户身份证明传递给LDAP服务器。服务器将使用SASL库调用从服务票证中提取身份和领域，并将其转换为表单的<em>身份验证请求DN</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;username&gt;,cn=&lt;realm&gt;,cn=&lt;mechanism&gt;,cn=auth</span><br></pre></td></tr></table></figure>

<p>所以在上面的例子中，如果用户的名字是“adamson”，认证请求DN将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=adamsom,cn=example.com,cn=kerberos_v4,cn=auth</span><br></pre></td></tr></table></figure>

<p>该认证请求DN可以直接使用ACL，也可以在使用前进行映射。有关详细信息，请参阅[映射身份验证身份](<a href="http://www.openldap.org/doc/admin24/sasl.html#Mapping">http://www.openldap.org/doc/admin24/sasl.html#Mapping</a> Authentication Identities)部分。</p>
<h4 id="15-2-3-DIGEST-MD5"><a href="#15-2-3-DIGEST-MD5" class="headerlink" title="15.2.3 DIGEST-MD5"></a>15.2.3 DIGEST-MD5</h4><p>本节介绍使用SASL DIGEST-MD5机制，使用存储在目录本身或Cyrus SASL自己的数据库中的秘密。DIGEST-MD5依赖于客户端和服务器共享“秘密”，通常是密码。服务器产生一个挑战，并且客户端的响应证明它知道共享的秘密。这比通过电线发送秘密更安全。</p>
<p>赛勒斯SASL支持几种共享秘密机制。为此，它需要访问明文密码（不同于通过线路传递明文密码的机制，服务器可以存储散列版本的密码）。</p>
<p>服务器的共享密钥副本可以存储在Cyrus SASL自己的<em>sasldb</em>数据库中，在通过<em>saslauthd</em>访问的外部系统中或LDAP数据库本身中。在这两种情况下，应用文件访问控制和LDAP访问控制来防止密码暴露是非常重要的。本节讨论的配置和命令假设使用Cyrus SASL 2.1。</p>
<p>要使用存储在<em>sasldb中的</em>秘密，只需使用<em>saslpasswd2</em>命令添加用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">saslpasswd2 -c &lt;username&gt;</span><br></pre></td></tr></table></figure>

<p>必须使用<em>saslpasswd2</em>命令管理此类用户的密码。</p>
<p>要使用存储在LDAP目录中的秘密，请将明文密码放在<code>userPassword</code>属性中。有必要为<code>slapd.conf</code>添加一个选项，以确保使用LDAP密码修改操作设置的密码以明文形式存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password-hash   &#123;CLEARTEXT&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方式存储的密码可以使用<em>ldappasswd</em>（1）或简单地修改<code>userPassword</code>属性进行管理。无论存储密码在哪里，都需要从认证请求DN到用户DN的映射。</p>
<p>DIGEST-MD5机制产生以下形式的身份验证ID：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;username&gt;,cn=&lt;realm&gt;,cn=digest-md5,cn=auth</span><br></pre></td></tr></table></figure>

<p>如果使用默认领域，则从ID中省略领域名称，给出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;username&gt;,cn=digest-md5,cn=auth</span><br></pre></td></tr></table></figure>

<p>有关可选的身份映射的信息，请参阅下面的[映射身份验证](<a href="http://www.openldap.org/doc/admin24/sasl.html#Mapping">http://www.openldap.org/doc/admin24/sasl.html#Mapping</a> Authentication Identities)身份。</p>
<p>使用合适的映射，用户可以在执行LDAP操作时指定SASL ID，并且将使用存储在<em>sasldb</em>或目录本身中的密码来验证身份验证。例如，由目录条目标识的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Andrew Findlay+uid=u000997,dc=example,dc=com</span><br><span class="line">objectclass: inetOrgPerson</span><br><span class="line">objectclass: person</span><br><span class="line">sn: Findlay</span><br><span class="line">uid: u000997</span><br><span class="line">userPassword: secret</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在上述每种情况下，都没有提供授权身份（例如<code>-X</code>）。除非您正在尝试[SASL代理授权](<a href="http://www.openldap.org/doc/admin24/sasl.html#SASL">http://www.openldap.org/doc/admin24/sasl.html#SASL</a> Proxy Authorization)，否则不应指定授权身份。服务器将从认证身份推断授权身份（如下所述）。</p>
<h4 id="15-2-4-EXTERNAL"><a href="#15-2-4-EXTERNAL" class="headerlink" title="15.2.4 EXTERNAL"></a>15.2.4 EXTERNAL</h4><p>SASL EXTERNAL机制利用较低级协议进行的认证：通常 TLS 或Unix IPC</p>
<p>每个传输协议以其自己的格式返回验证身份：</p>
<h5 id="15-2-4-1-TLS认证身份格式"><a href="#15-2-4-1-TLS认证身份格式" class="headerlink" title="15.2.4.1 TLS认证身份格式"></a>15.2.4.1 TLS认证身份格式</h5><p>这是客户端证书的主题DN。请注意，DN由LDAP和X.509显示不同，因此颁发了证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C=gb, O=The Example Organisation, CN=A Person</span><br></pre></td></tr></table></figure>

<p>将产生以下认证身份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cn=A Person,o=The Example Organisation,c=gb</span><br></pre></td></tr></table></figure>

<p>请注意，您必须为TLSVerifyClient设置合适的值，以使服务器请求使用客户端证书。没有这个，SASL EXTERNAL机制将不会被提供。有关详细信息，请参阅<a href="http://www.openldap.org/doc/admin24/tls.html">使用TLS</a>一章。</p>
<h5 id="15-2-4-2-IPC-ldapi-Identity-Format"><a href="#15-2-4-2-IPC-ldapi-Identity-Format" class="headerlink" title="15.2.4.2 IPC (ldapi:///) Identity Format"></a>15.2.4.2 IPC (ldapi:///) Identity Format</h5><p>这是由客户端进程的Unix UID和GID组成的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gidNumber=&lt;number&gt;+uidNumber=&lt;number&gt;,cn=peercred,cn=external,cn=auth</span><br></pre></td></tr></table></figure>

<p>因此，以<code>root</code>身份运行的客户端进程将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth</span><br></pre></td></tr></table></figure>

<h4 id="15-2-5-映射身份验证身份"><a href="#15-2-5-映射身份验证身份" class="headerlink" title="15.2.5 映射身份验证身份"></a>15.2.5 映射身份验证身份</h4><p>slapd服务器中的认证机制将使用SASL库调用来获取经过身份验证的用户的“用户名”，这取决于所使用的基本身份验证机制。该用户名位于身份验证机制的命名空间中，而不在正常的LDAP命名空间中。如上述部分所述，该用户名重新格式化为表单的认证请求DN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;username&gt;,cn=&lt;realm&gt;,cn=&lt;mechanism&gt;,cn=auth</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;username&gt;,cn=&lt;mechanism&gt;,cn=auth</span><br></pre></td></tr></table></figure>

<p>这取决于&lt;mechanism&gt;是否采用“realms”的概念。还要注意，如果认证中使用了默认领域，则会忽略该领域部分。</p>
<p>所述<em>ldapwhoami命令</em>（1）命令可以被用来确定与用户相关联的身份。确定映射的正确功能非常有用。</p>
<p>您不应该将上述表单的LDAP条目添加到LDAP数据库。您可能有机会为LDAP中的每个人员提供一个LDAP条目，并将其放置在目录树中，树不会从cn = auth开始。但是，如果您的站点在该用户的“用户名”和LDAP条目之间有明确的映射，则可以配置LDAP服务器以自动将认证请求DN映射到用户的<em>身份验证DN</em>。</p>
<p><strong>注意：</strong>不要求认证请求DN和映射导致的用户认证DN指的是目录中保存的条目。但是，可以使用其他功能（见下文）。</p>
<p>LDAP管理员需要告诉slapd服务器如何将身份验证请求DN映射到用户的身份验证DN。这通过在<em>slapd.conf</em>（5）文件中添加一个或多个<code>authz-regexp</code>指令来完成。这个指令有两个参数：**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authz-regexp &lt;搜索模式&gt; &lt;替换模式&gt;</span><br></pre></td></tr></table></figure>

<p>使用正则表达式函数<em>regcomp</em>（）和<em>regexec</em>（）将认证请求DN与搜索模式进行比较，如果匹配，则将其重写为替换模式。如果存在多个<code>authz-regexp</code>指令，则只使用其搜索模式与身份验证身份匹配的第一个。从替换模式输出的字符串应该是用户的认证DN或LDAP URL。如果替换字符串产生DN，则此DN命名的条目不需要由此服务器持有。如果替换字符串生成LDAP URL，则该LDAP URL必须评估为此服务器所保留的唯一一个条目。</p>
<p>搜索模式可以包含<em>regexec</em>（3C）中列出的任何正则表达式字符。注意的主要特征是点“”，星号“*”和开放的圆括号“（”和“）”。本质上，点匹配任何字符，星号允许紧接在前一个字符或模式的零个或多个重复，括号中的术语被记住替换模式。</p>
<p>替换模式将产生指向用户的DN或URL。与搜索模式中的括号中的字符串匹配的认证请求DN中的任何内容都存储在变量“$ 1”中。该变量“$ 1”可以出现在替换模式中，并将被来自认证请求DN的字符串替换。如果搜索模式中有多组括号，则使用变量$ 2，$ 3等。</p>
<h4 id="15-2-6-直接映射"><a href="#15-2-6-直接映射" class="headerlink" title="15.2.6 直接映射"></a>15.2.6 直接映射</h4><p>在可能的情况下，通常建议将认证请求DN直接映射到用户的DN。除了避免搜索用户DN的费用外，还允许将映射到指向不属于此服务器的条目的DN。</p>
<p>假设认证请求DN被写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=adamson,cn=example.com,cn=gssapi,cn=auth</span><br></pre></td></tr></table></figure>

<p>用户的实际LDAP条目为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=adamson,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>那么<em>slapd.conf</em>（5）中的以下<code>authz-regexp</code>指令将提供直接映射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authz-regexp</span><br><span class="line">  uid=([^,]*),cn=example.com,cn=gssapi,cn=auth</span><br><span class="line">  uid=$1,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>一个更宽松的规则可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authz-regexp</span><br><span class="line">  uid=([^,]*),cn=[^,]*,cn=auth</span><br><span class="line">  uid=$1,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>但是，请仔细设定搜索模式，因为它可能会错误地允许人们认证为不能访问的DN。写一些严格的指令比一个具有安全漏洞的宽松指令更好。如果您的站点上只有一个身份验证机制，以及零个或一个使用的领域，则可以使用单个<code>authz-regexp</code>指令在身份验证身份和LDAP DN之间进行映射。</p>
<p>不要忘记允许省略领域的情况以及具有明确指定领域的情况。对于每种情况，这可能需要单独的<code>authz-regexp</code>指令，其中首先列出显式领域条目。</p>
<h4 id="15-2-7-基于搜索的映射"><a href="#15-2-7-基于搜索的映射" class="headerlink" title="15.2.7 基于搜索的映射"></a>15.2.7 基于搜索的映射</h4><p>有一些情况下映射到LDAP URL可能是适当的。例如，一些站点可能具有位于LDAP树的多个区域中的人物对象，例如，如果存在<code>ou=accounting</code>树和<code>ou=engineering</code>树，并且人物之间散布着它们。或者，也许所需的映射必须基于用户信息中的信息。考虑需要将上述认证请求DN映射到其条目如下的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Mark Adamson,ou=People,dc=Example,dc=COM</span><br><span class="line">objectclass: person</span><br><span class="line">cn: Mark Adamson</span><br><span class="line">uid: adamson</span><br></pre></td></tr></table></figure>

<p>认证请求DN中的信息不足以允许直接导出用户的DN，而是必须搜索用户的DN。对于这些情况，可以在<code>authz-regexp</code>指令中使用生成LDAP URL的替换模式。然后，此URL将用于执行LDAP数据库的内部搜索以查找该人的身份验证DN。</p>
<p>与其他网址相似的LDAP网址为形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldap://&lt;host&gt;/&lt;base&gt;?&lt;attrs&gt;?&lt;scope&gt;?&lt;filter&gt;</span><br></pre></td></tr></table></figure>

<p>这包含执行LDAP搜索所需的所有元素：服务器的名称&lt;host&gt;，LDAP DN搜索库&lt;base&gt;，要检索的LDAP属性&lt;attrs&gt;，搜索范围&lt;scope&gt;是三个选项“base”，“one”或“sub”，最后是LDAP搜索过滤器&lt;filter&gt;。由于搜索是当前服务器中的LDAP DN，所以&lt;host&gt;部分应为空。&lt;attrs&gt;字段也被忽略，因为只有DN值得关注。这两个元素以URL的格式保留，以保持字符串中哪些信息的清晰度。</p>
<p>假设上述示例中的人实际上具有“adamson”的身份验证用户名，并且该信息保存在其LDAP条目的属性“uid”中。在<code>authz-regexp</code>指令可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authz-regexp</span><br><span class="line">  uid=([^,]*),cn=example.com,cn=gssapi,cn=auth</span><br><span class="line">  ldap:///ou=people,dc=example,dc=com??one?(uid=$1)</span><br></pre></td></tr></table></figure>

<p>这将启动对slapd服务器内的LDAP数据库的内部搜索。如果搜索只返回一个条目，则它被接受为用户的DN。如果返回多个条目，或者返回零条目，则认证失败，并将用户的连接作为认证请求DN绑定。</p>
<p>在URL中的搜索过滤器<filter>中使用的属性应该被编入索引，以便更快地搜索。如果不是，认证步骤单独可能会持续很长时间，用户可能会认为服务器关闭。</p>
<p>一个更复杂的站点可能有几个领域的使用，每个映射到目录中的不同的子树。这些可以用以下形式的语句处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Match Engineering realm</span><br><span class="line">authz-regexp</span><br><span class="line">   uid=([^,]*),cn=engineering.example.com,cn=digest-md5,cn=auth</span><br><span class="line">   ldap:///dc=eng,dc=example,dc=com??one?(&amp;(uid=$1)(objectClass=person))</span><br><span class="line"></span><br><span class="line"># Match Accounting realm</span><br><span class="line">authz-regexp</span><br><span class="line">   uid=([^,].*),cn=accounting.example.com,cn=digest-md5,cn=auth</span><br><span class="line">   ldap:///dc=accounting,dc=example,dc=com??one?(&amp;(uid=$1)(objectClass=person))</span><br><span class="line"></span><br><span class="line"># Default realm is customers.example.com</span><br><span class="line">authz-regexp</span><br><span class="line">   uid=([^,]*),cn=digest-md5,cn=auth</span><br><span class="line">   ldap:///dc=customers,dc=example,dc=com??one?(&amp;(uid=$1)(objectClass=person))</span><br></pre></td></tr></table></figure>

<p>请注意，首先处理明确命名的域，以避免域名成为UID的一部分。还要注意使用范围和过滤器来限制匹配到所需条目。</p>
<p>请注意，<code>authz-regexp</code>内部搜索需要访问控制。具体来说，认证身份必须具有<code>auth</code>访问权限。</p>
<p>有关更多详细信息，请参阅<em>slapd.conf</em>（5）。</p>
<h3 id="15-3-SASL代理授权"><a href="#15-3-SASL代理授权" class="headerlink" title="15.3 SASL代理授权"></a>15.3 SASL代理授权</h3><p>SASL提供了一种被称为<em>代理授权</em>的功能，允许经过身份验证的用户请求他们代表另一个用户行事。此步骤发生在用户获得认证DN之后，并涉及向服务器发送授权标识。然后，服务器将决定是否允许发生授权。如果允许，则将用户的LDAP连接切换为具有从授权标识导出的绑定DN，并且LDAP会话继续访问新的授权DN。</p>
<p>允许进行授权的决定取决于运行LDAP的站点的规则和策略，因此不能由SASL单独进行。SASL库可以让服务器做出决定。LDAP管理员通过向LDAP数据库条目中添加信息来设置谁可以授权哪些身份的准则。默认情况下，授权功能被禁用，使用前必须由LDAP管理员明确配置。</p>
<h4 id="15-3-1-代理授权的使用"><a href="#15-3-1-代理授权的使用" class="headerlink" title="15.3.1 代理授权的使用"></a>15.3.1 代理授权的使用</h4><p>当一个实体需要代表许多其他用户行事时，这种服务是有用的。例如，用户可能被引导到网页以在其LDAP条目中对其个人信息进行更改。用户向Web服务器进行身份验证以建立其身份，但是由于该用户对其进行更改，因此，Web服务器CGI无法向LDAP服务器进行身份验证。相反，Web服务器将其自身认证为LDAP服务器作为服务标识，比如说，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cn=WebUpdate,dc=example,dc=com</span><br></pre></td></tr></table></figure>

<p>然后将SASL授权给用户的DN。一旦这样授权，CGI会更改用户的LDAP条目，只要slapd服务器能够识别其ACL，则用户本身就在连接的另一端。用户可以直接连接到LDAP服务器，并自己认证，但这需要用户更多地了解LDAP客户端，网页提供的知识更容易。</p>
<p>还可以使用代理授权来限制对具有对数据库的更大访问权限的帐户的访问。这样的帐户，甚至是<em>slapd.conf</em>（5）中指定的根DN ，可以有一个严格的可以授权给该DN的人员列表。那么LDAP数据库的更改只能由该DN允许，并且为了成为该DN，用户必须首先认证为列表中的人员之一。这样可以更好地审核谁对LDAP数据库进行了更改。如果允许人们通过<code>rootpw </code><em>slapd.conf</em>（5）指令或通过<code>userPassword</code>属性直接向特权帐户进行身份验证，则审核变得更加困难。</p>
<p>请注意，在成功的代理授权之后，LDAP连接的原始身份验证DN将被授权请求中的新DN覆盖。如果服务程序能够自己认证为自己的认证DN，然后授权给其他DN，并且计划在一个LDAP会话期间切换到几个不同的身份，则每次在授权给另一个DN之前需要对其进行身份验证（或使用不同的代理授权机制）。slapd服务器不记录服务程序切换到其他DN的能力。在Kerberos这样的认证机制上，由于用户的TGT和“ldap”</p>
<h4 id="15-3-2-SASL授权身份"><a href="#15-3-2-SASL授权身份" class="headerlink" title="15.3.2 SASL授权身份"></a>15.3.2 SASL授权身份</h4><p>SASL授权身份通过<em>ldapsearch</em>（1）的<code>-X</code>开关和其他工具或在<em>lutil_sasl_defaults</em>（）调用的<code>* authzid</code>参数中发送到LDAP服务器。身份可以是两种形式之一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u:&lt;username&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn:&lt;dn&gt;</span><br></pre></td></tr></table></figure>

<p>在第一种形式中，<username>来自与上述身份验证身份相同的命名空间。它是由底层身份验证机制引用的用户的用户名。该表单的授权身份通过与认证过程相同的功能转换成DN格式，生成表单的<em>授权请求DN</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid=&lt;username&gt;,cn=&lt;realm&gt;,cn=&lt;mechanism&gt;,cn=auth</span><br></pre></td></tr></table></figure>

<p>然后，该授权请求DN通过相同的<code>authz-regexp</code>进程运行，以将其转换为数据库中的合法授权DN。如果由于LDAP URL中的搜索失败而无法转换，则授权请求将失败，并显示“不当访问”。否则，DN字符串现在是准备好批准的合法授权DN。</p>
<p>如果以第二种形式提供授权身份，则使用<code>“dn：”</code>前缀，前缀后面的字符串已经处于授权DN形式，准备进行批准。</p>
<h4 id="15-3-3-代理授权规则"><a href="#15-3-3-代理授权规则" class="headerlink" title="15.3.3 代理授权规则"></a>15.3.3 代理授权规则</h4><p>一旦slapd具有授权DN，则开始实际的批准过程。LDAP管理员可以将两个属性放入LDAP条目以允许授权：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authzTo</span><br><span class="line">authzFrom</span><br></pre></td></tr></table></figure>

<p>两者都可以是多值的。该<code>authzTo</code>属性是源规则，将其置入与认证DN告诉DNS的认证DN被允许什么授权承担相关的条目。第二个属性是目标规则，它被放置到与请求的授权DN相关联的条目中，以告知哪些已验证的DN可以承担它。</p>
<p>选择要使用的授权策略属性取决于管理员。源代码规则首先在人员的身份验证DN条目中检查，并且如果<code>authzTo</code>规则中没有一个指定允许授权，则会检查授权DN条目中的<code>authzFrom</code>规则。如果两个案例都不指定请求被遵守，则该请求被拒绝。由于默认行为是拒绝授权请求，因此规则只指定允许请求; 没有消极的规则告诉什么授权拒绝。</p>
<p>两个属性中的值与<code>authz-regexp</code>伪指令的替换模式的输出形式相同：DN或LDAP URL。例如，如果<code>authzTo</code>值是DN，则该DN是经过身份验证的用户可以授权的DN。另一方面，如果<code>authzTo</code>值是LDAP URL，则该URL将用作LDAP数据库的内部搜索，并且已验证的用户可以成为搜索返回的任何DN。如果LDAP条目看起来像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=WebUpdate,dc=example,dc=com</span><br><span class="line">authzTo: ldap:///dc=example,dc=com??sub?(objectclass=person)</span><br></pre></td></tr></table></figure>

<p>那么认证为<code>cn = WebUpdate，dc = example，dc = com的</code>任何用户可以授权给具有objectClass of <code>Person</code>的搜索库<code>dc = example，dc = com</code>下的任何其他LDAP条目。``</p>
<h5 id="15-3-3-1-代理授权规则说明"><a href="#15-3-3-1-代理授权规则说明" class="headerlink" title="15.3.3.1 代理授权规则说明"></a>15.3.3.1 代理授权规则说明</h5><p><code>authzTo</code>或<code>authzFrom</code>属性中的LDAP URL 将返回一组DN。每个返回的DN将被检查。返回一个大集合的搜索可能会导致授权过程变得不舒服很长时间。此外，应该对由slapd建立索引的属性执行搜索。</p>
<p>为了帮助为<code>authzFrom</code>和<code>authzTo</code>生成更多清晰的规则，这些属性的值可以是其中具有正则表达式字符的DN。这意味着一个源规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authzTo: dn.regex:^uid=[^,]*,dc=example,dc=com$</span><br></pre></td></tr></table></figure>

<p>将允许经过身份验证的用户授权给与给定的正则表达式模式匹配的任何DN。这种正则表达式比较可以比LDAP搜索<code>（uid = *）</code>快得多。</p>
<p>另请注意，授权规则中的值必须是以下两种形式之一：LDAP URL或DN（带或不带正则表达式字符）。任何不以“ <code>ldap：//</code> ” 开头的内容都将被视为DN。不允许输入形式“ <code>u：&lt;username&gt;</code> ”的另一个授权身份作为授权规则。</p>
<h5 id="15-3-3-2-策略配置"><a href="#15-3-3-2-策略配置" class="headerlink" title="15.3.3.2 策略配置"></a>15.3.3.2 策略配置</h5><p>决定使用哪种类型的规则，<code>authzFrom</code>或<code>authzTo</code>将取决于网站的情况。例如，如果可以成为给定身份的一组人可以容易地被写为搜索过滤器，则可以写入单个目的地规则。如果一组人不容易被搜索过滤器定义，而且一组人很小，可能会更好的是在每个被允许执行代理授权的人的条目中写入源规则。</p>
<p>默认情况下，禁用代理授权规则的处理。在<code>AuthZ的政策</code>指令必须在设定<em>的slapd.conf</em>（5）文件来启用授权。该指令可以设置为<code>无</code>对无规则（默认），<code>以</code>供源的规则，<code>从</code>为目的地的规则，或者<code>两者</code>的源和目标的规则。</p>
<p>源规则非常强大。如果普通用户有权在自己的条目中写入<code>authzTo</code>属性，那么他们可以编写允许他们作为其他人授权的规则。因此，当使用源规则时，<code>authzTo</code>属性应该使用只允许特权用户设置其值的ACL进行保护。</p>
<h2 id="20-监测"><a href="#20-监测" class="headerlink" title="20 监测"></a>20 监测</h2><p><em>slapd</em>（8）支持可选LDAP监视界面，您可以使用它来获取有关<em>slapd</em>实例当前状态的信息。例如，该界面允许您确定当前有多少客户端连接到服务器。监控信息由专门的后端（<em>监视器</em>后端）提供。手册页，<em>slapd-monitor</em>（5）可用。</p>
<p>启用监视界面后，LDAP客户端可能被用于访问由<em>监视器</em>后端提供的信息，受访问和其他控制。</p>
<p>启用后，<em>监视器</em>后端将动态生成并返回对象，以响应 <em>cn=monitor</em> 子树中的搜索请求。每个对象包含有关服务器特定方面的信息。信息以用户应用程序和操作属性的组合方式进行。该信息可以使用<em>ldapsearch（1）</em>，任何通用LDAP浏览器或专门的监控工具进行访问。“ [访问监控信息”](<a href="https://www.openldap.org/doc/admin24/monitoringslapd.html#Accessing">https://www.openldap.org/doc/admin24/monitoringslapd.html#Accessing</a> Monitoring Information)部分提供了有关如何使用<em>ldapsearch</em>（1）访问监视信息的简要教程监控信息 监控信息基础及其组织部分细节。</p>
<p>虽然支持监视器后端包含在slapd（8）的默认版本中，但该支持需要一些配置才能激活。这可以使用<code>cn=config</code>或 <em>slapd.conf</em>（5）完成。前者在中讨论过通过 cn=config 监视配置本章的一部分。后者[通过](<a href="https://www.openldap.org/doc/admin24/monitoringslapd.html#Monitor">https://www.openldap.org/doc/admin24/monitoringslapd.html#Monitor</a> configuration via slapd.conf(5))本章的[slapd.conf（5）](<a href="https://www.openldap.org/doc/admin24/monitoringslapd.html#Monitor">https://www.openldap.org/doc/admin24/monitoringslapd.html#Monitor</a> configuration via slapd.conf(5))部分在[Monitor配置中](<a href="https://www.openldap.org/doc/admin24/monitoringslapd.html#Monitor">https://www.openldap.org/doc/admin24/monitoringslapd.html#Monitor</a> configuration via slapd.conf(5))讨论。这些部分假设监视器后端内置于<em>slapd中</em>（例如，<code>enable-monitor=yes</code> ，默认值）。如果监视器后端被构建为一个模块（例如，<code>enable-monitor=mod）</code>，则该模块必须加载。在“ <a href="https://www.openldap.org/doc/admin24/slapdconf2.html">配置slapd</a>和<a href="https://www.openldap.org/doc/admin24/slapdconfig.html">slapd配置文件”</a>章节中讨论了模块的加载。</p>
<h3 id="20-1-通过cn-config-5-监控配置"><a href="#20-1-通过cn-config-5-监控配置" class="headerlink" title="20.1 通过cn=config(5)监控配置"></a>20.1 通过cn=config(5)监控配置</h3><p><em>本节尚未写入。</em></p>
<h3 id="20-2-通过slapd-conf-5-监视配置"><a href="#20-2-通过slapd-conf-5-监视配置" class="headerlink" title="20.2 通过slapd.conf(5)监视配置"></a>20.2 通过slapd.conf(5)监视配置</h3><p>配置slapd.conf（5）来支持LDAP监控非常简单。</p>
<p>首先，确保您的<em>slapd.conf</em>（5）文件包含<em>core.schema</em>模式配置文件。该<em>显示器</em> 后端需要它。</p>
<p>其次，通过在现有数据库部分下方添加 *数据库监视器 <em>指令来实例化</em>监视器后端。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database monitor</span><br></pre></td></tr></table></figure>

<p>最后，根据需要添加其他全局或数据库指令。</p>
<p>像大多数其他数据库后端一样，监视器后端执行slapd（8）访问和其他管理控制。由于某些监视器信息可能很敏感，因此通常建议对 cn=monitor 进行访问，限于目录管理员及其监控代理。在<em>数据库监视器</em>指令下面添加<em>访问</em>指令是控制访问的一种清晰有效的方法。例如，在<em>数据库监视器</em>指令正下方添加以下<em>访问</em>指令将对监视信息的访问限制到指定的目录管理器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access to *</span><br><span class="line">        by dn.exact=&quot;cn=Manager,dc=example,dc=com</span><br><span class="line">        by * none</span><br></pre></td></tr></table></figure>

<p>有关<em>slapd</em>（8）访问控制的更多信息，请参阅<a href="https://www.openldap.org/doc/admin24/slapdconfig.html">“slapd配置文件”</a>一章<em>的访问控制指令</em>部分和<em>slapd.access</em>（5）。</p>
<p>重新启动<em>slapd</em>（8）后，您可以开始探索<code>cn=config</code>中提供的监视信息，如本章“ [访问监控信息”](<a href="https://www.openldap.org/doc/admin24/monitoringslapd.html#Accessing">https://www.openldap.org/doc/admin24/monitoringslapd.html#Accessing</a> Monitoring Information)部分所述。</p>
<p>可以验证slapd（8）是否被正确地配置为通过尝试读取<code>cn=monitor</code>对象来提供监视信息。例如，如果以下<em>ldapsearch</em>（1）命令返回cn=monitor对象（根据请求，没有属性），它正在运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -D &#x27;cn=Manager,dc=example,dc=com&#x27; -W \</span><br><span class="line">        -b &#x27;cn=Monitor&#x27; -s base 1.1</span><br></pre></td></tr></table></figure>

<p>请注意，与通用数据库后端不同，数据库后缀是硬编码的。它总是<code>cn =监视器</code>。所以不应该提供<em>后缀</em>指令。另请注意，通用数据库后端，显示器后端无法多次实例化。也就是说，在服务器配置中只能有一个（或零）<code>数据库监视器</code>出现。</p>
<h3 id="20-3-访问监控信息"><a href="#20-3-访问监控信息" class="headerlink" title="20.3 访问监控信息"></a>20.3 访问监控信息</h3><p>如前所述，当启用时，<em>监视器</em>后端将动态生成并响应<em>cn =监视器</em>子树中的搜索请求返回对象。每个对象包含有关服务器特定方面的信息。信息以用户应用程序和操作属性的组合方式进行。可以使用<em>ldapsearch（1）</em>，任何通用LDAP浏览器或专门的监视工具访问此信息。</p>
<p>本节提供了一个关于如何使用<em>ldapsearch</em>（1）访问监视信息的简要教程。</p>
<p>要检查任何特定的监视器对象，可以使用一个baseObject范围和一个<code>（objectClass = *）</code>过滤器对对象执行搜索操作。由于监视信息包含在用户应用程序和操作属性的组合中，所以应该要求返回所有用户应用程序属性（例如<code>&#39;*&#39;</code>）和所有操作属性（例如<code>&#39;+&#39;</code>）。例如，要读取<code>cn = Monitor</code>对象本身，可以使用<em>ldapsearch</em>（1）命令（修改为适合您的配置）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -D &#x27;cn=Manager,dc=example,dc=com&#x27; -W \</span><br><span class="line">        -b &#x27;cn=Monitor&#x27; -s base &#x27;(objectClass=*)&#x27; &#x27;*&#x27; &#x27;+&#x27;</span><br></pre></td></tr></table></figure>

<p>当您的服务器运行时，应该产生类似于以下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Monitor</span><br><span class="line">objectClass: monitorServer</span><br><span class="line">structuralObjectClass: monitorServer</span><br><span class="line">cn: Monitor</span><br><span class="line">creatorsName:</span><br><span class="line">modifiersName:</span><br><span class="line">createTimestamp: 20061208223558Z</span><br><span class="line">modifyTimestamp: 20061208223558Z</span><br><span class="line">description: This subtree contains monitoring/managing objects.</span><br><span class="line">description: This object contains information about this server.</span><br><span class="line">description: Most of the information is held in operational attributes, which</span><br><span class="line"> must be explicitly requested.</span><br><span class="line">monitoredInfo: OpenLDAP: slapd 2.4 (Dec  7 2006 17:30:29)</span><br><span class="line">entryDN: cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: TRUE</span><br></pre></td></tr></table></figure>

<p>为了减少返回的不感兴趣的属性数量，在请求哪些属性要返回时，可以更有选择性。例如，可以请求返回由<em>monitorServer</em>对象类（例如<code>@objectClass</code>）允许的所有属性，而不是所有用户和所有操作属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -D &#x27;cn=Manager,dc=example,dc=com&#x27; -W \</span><br><span class="line">        -b &#x27;cn=Monitor&#x27; -s base &#x27;(objectClass=*)&#x27; &#x27;@monitorServer&#x27;</span><br></pre></td></tr></table></figure>

<p>这将限制输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Monitor</span><br><span class="line">objectClass: monitorServer</span><br><span class="line">cn: Monitor</span><br><span class="line">description: This subtree contains monitoring/managing objects.</span><br><span class="line">description: This object contains information about this server.</span><br><span class="line">description: Most of the information is held in operational attributes, which</span><br><span class="line"> must be explicitly requested.</span><br><span class="line">monitoredInfo: OpenLDAP: slapd 2.X (Dec  7 2006 17:30:29)</span><br></pre></td></tr></table></figure>

<p>要返回所有监控对象的名称，可以使用子树范围和<code>（objectClass = *）</code>过滤器执行<code>cn = Monitor</code>的搜索，并且不要求返回任何属性（例如，<code>1.1</code>）。````</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -D &#x27;cn=Manager,dc=example,dc=com&#x27; -W -b &#x27;cn=Monitor&#x27; -s sub 1.1</span><br></pre></td></tr></table></figure>

<p>如果运行此命令，您会发现<em>cn = Monitor</em>子树中有很多对象。以下部分介绍了一些常用的监视对象。</p>
<h3 id="20-4-监控信息"><a href="#20-4-监控信息" class="headerlink" title="20.4 监控信息"></a>20.4 监控信息</h3><p>所述<em>监视器</em>后端提供了丰富的用于监控在设置中的显示屏的对象的slapd（8）的有用信息。每个对象包含有关服务器特定方面的信息，例如后端，连接或线程。一些对象用作其他对象的容器，用于构造对象的层次结构。</p>
<p>在这个层次结构中，最高级的对象是{cn = Monitor}。虽然此对象主要用作其他对象的容器，其中大多数是容器，但此对象提供有关此服务器的信息。特别是它提供了slapd（8）版本字符串。例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Monitor</span><br><span class="line">monitoredInfo: OpenLDAP: slapd 2.X (Dec  7 2006 17:30:29)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>本节（及其子部分）中的示例已被修剪以仅显示关键信息。</p>
<h4 id="20-4-1-后端"><a href="#20-4-1-后端" class="headerlink" title="20.4.1 后端"></a>20.4.1 后端</h4><p>该<code>cn=Backends</code>，<code>cn=Monitor </code>对象，本身提供了可用后端的列表。所有内置后端的可用后端列表以及模块加载的后端。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Backends,cn=Monitor</span><br><span class="line">monitoredInfo: config</span><br><span class="line">monitoredInfo: ldif</span><br><span class="line">monitoredInfo: monitor</span><br><span class="line">monitoredInfo: bdb</span><br><span class="line">monitoredInfo: hdb</span><br></pre></td></tr></table></figure>

<p>这表示<em>config</em>，<em>ldif</em>，<em>monitor</em>，<em>bdb</em>和<em>hdb</em>后端可用。</p>
<p><code>cn=Backends</code>，<code> cn=Monitor</code>对象也是可用的后端对象的容器。每个可用的后端对象包含有关特定后端的信息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Backend 0,cn=Backends,cn=Monitor</span><br><span class="line">monitoredInfo: config</span><br><span class="line">monitorRuntimeConfig: TRUE</span><br><span class="line">supportedControl: 2.16.840.1.113730.3.4.2</span><br><span class="line">seeAlso: cn=Database 0,cn=Databases,cn=Monitor</span><br><span class="line"></span><br><span class="line">dn: cn=Backend 1,cn=Backends,cn=Monitor</span><br><span class="line">monitoredInfo: ldif</span><br><span class="line">monitorRuntimeConfig: TRUE</span><br><span class="line">supportedControl: 2.16.840.1.113730.3.4.2</span><br><span class="line"></span><br><span class="line">dn: cn=Backend 2,cn=Backends,cn=Monitor</span><br><span class="line">monitoredInfo: monitor</span><br><span class="line">monitorRuntimeConfig: TRUE</span><br><span class="line">supportedControl: 2.16.840.1.113730.3.4.2</span><br><span class="line">seeAlso: cn=Database 2,cn=Databases,cn=Monitor</span><br><span class="line"></span><br><span class="line">dn: cn=Backend 3,cn=Backends,cn=Monitor</span><br><span class="line">monitoredInfo: bdb</span><br><span class="line">monitorRuntimeConfig: TRUE</span><br><span class="line">supportedControl: 1.3.6.1.1.12</span><br><span class="line">supportedControl: 2.16.840.1.113730.3.4.2</span><br><span class="line">supportedControl: 1.3.6.1.4.1.4203.666.5.2</span><br><span class="line">supportedControl: 1.2.840.113556.1.4.319</span><br><span class="line">supportedControl: 1.3.6.1.1.13.1</span><br><span class="line">supportedControl: 1.3.6.1.1.13.2</span><br><span class="line">supportedControl: 1.3.6.1.4.1.4203.1.10.1</span><br><span class="line">supportedControl: 1.2.840.113556.1.4.1413</span><br><span class="line">supportedControl: 1.3.6.1.4.1.4203.666.11.7.2</span><br><span class="line">seeAlso: cn=Database 1,cn=Databases,cn=Monitor</span><br><span class="line"></span><br><span class="line">dn: cn=Backend 4,cn=Backends,cn=Monitor</span><br><span class="line">monitoredInfo: hdb</span><br><span class="line">monitorRuntimeConfig: TRUE</span><br><span class="line">supportedControl: 1.3.6.1.1.12</span><br><span class="line">supportedControl: 2.16.840.1.113730.3.4.2</span><br><span class="line">supportedControl: 1.3.6.1.4.1.4203.666.5.2</span><br><span class="line">supportedControl: 1.2.840.113556.1.4.319</span><br><span class="line">supportedControl: 1.3.6.1.1.13.1</span><br><span class="line">supportedControl: 1.3.6.1.1.13.2</span><br><span class="line">supportedControl: 1.3.6.1.4.1.4203.1.10.1</span><br><span class="line">supportedControl: 1.2.840.113556.1.4.1413</span><br><span class="line">supportedControl: 1.3.6.1.4.1.4203.666.11.7.2</span><br></pre></td></tr></table></figure>

<p>对于每个这些对象，monitorInfo指示对象中的哪个后端信息是关于的。例如，<code>cn=Backend 3</code>，<code>cn=Backends</code>，<code>cn=Monitor</code>对象包含（在示例中）有关<em>bdb</em>后端的信息。</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>monitoredInfo</td>
<td>后端名称</td>
</tr>
<tr>
<td>supportedControl</td>
<td>支持LDAP控制扩展</td>
</tr>
<tr>
<td>seeAlso</td>
<td>这个后端实例的数据库对象</td>
</tr>
</tbody></table>
<h4 id="20-4-2-Connections"><a href="#20-4-2-Connections" class="headerlink" title="20.4.2 Connections"></a>20.4.2 Connections</h4><p>主条目为空; 它应该包含一些关于连接数的统计信息。</p>
<p>为每个打开的连接创建动态子条目，并对该连接上的活动进行统计（稍后将对其进行详细说明）。有两个特殊的子条目分别显示总数和当前连接的数量。</p>
<p>例如：</p>
<p>总连接数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Total,cn=Connections,cn=Monitor</span><br><span class="line">structuralObjectClass: monitorCounterObject</span><br><span class="line">monitorCounter: 4</span><br><span class="line">entryDN: cn=Total,cn=Connections,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<p>当前连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Current,cn=Connections,cn=Monitor</span><br><span class="line">structuralObjectClass: monitorCounterObject</span><br><span class="line">monitorCounter: 2</span><br><span class="line">entryDN: cn=Current,cn=Connections,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-3-Databases"><a href="#20-4-3-Databases" class="headerlink" title="20.4.3 Databases"></a>20.4.3 Databases</h4><p>主条目包含每个配置的数据库的命名上下文; 对于每个数据库，子条目包含类型和命名上下文。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Database 2,cn=Databases,cn=Monitor</span><br><span class="line">structuralObjectClass: monitoredObject</span><br><span class="line">monitoredInfo: monitor</span><br><span class="line">monitorIsShadow: FALSE</span><br><span class="line">monitorContext: cn=Monitor</span><br><span class="line">readOnly: FALSE</span><br><span class="line">entryDN: cn=Database 2,cn=Databases,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-4-Listener"><a href="#20-4-4-Listener" class="headerlink" title="20.4.4 Listener"></a>20.4.4 Listener</h4><p>它包含服务器当前正在侦听的设备的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Listener 0,cn=Listeners,cn=Monitor</span><br><span class="line">structuralObjectClass: monitoredObject</span><br><span class="line">monitorConnectionLocalAddress: IP=0.0.0.0:389</span><br><span class="line">entryDN: cn=Listener 0,cn=Listeners,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-5-Log"><a href="#20-4-5-Log" class="headerlink" title="20.4.5 Log"></a>20.4.5 Log</h4><p>它包含当前活动的日志项目。该<em>日志</em>子系统允许用户修改的操作<em>描述</em>属性，其值<em>必须</em>在admittable日志切换列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trace</span><br><span class="line">Packets</span><br><span class="line">Args</span><br><span class="line">Conns</span><br><span class="line">BER</span><br><span class="line">Filter</span><br><span class="line">Config</span><br><span class="line">ACL</span><br><span class="line">Stats</span><br><span class="line">Stats2</span><br><span class="line">Shell</span><br><span class="line">Parse</span><br><span class="line">Sync</span><br></pre></td></tr></table></figure>

<p>这些值可以添加，替换或删除; 它们会影响发送到syslog设备的消息。可以通过自定义模块添加自定义值。</p>
<h4 id="20-4-6-Operations"><a href="#20-4-6-Operations" class="headerlink" title="20.4.6 Operations"></a>20.4.6 Operations</h4><p>它显示了服务器执行的操作的一些统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initiated</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure>

<p>对于每个操作类型，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bind</span><br><span class="line">Unbind</span><br><span class="line">Add</span><br><span class="line">Delete</span><br><span class="line">Modrdn</span><br><span class="line">Modify</span><br><span class="line">Compare</span><br><span class="line">Search</span><br><span class="line">Abandon</span><br><span class="line">Extended</span><br></pre></td></tr></table></figure>

<p>有太多的类型列出这里的例子，所以请尝试为自己使用 监控搜索示例</p>
<h4 id="20-4-7-Overlays"><a href="#20-4-7-Overlays" class="headerlink" title="20.4.7 Overlays"></a>20.4.7 Overlays</h4><p>主条目包含运行时可用的覆盖类型; 每个叠加层的子条目包含叠加层的类型。</p>
<p>如果启用动态覆盖，它也应该包含已加载的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Overlays, Monitor</span><br><span class="line">dn: cn=Overlays,cn=Monitor</span><br><span class="line">structuralObjectClass: monitorContainer</span><br><span class="line">monitoredInfo: syncprov</span><br><span class="line">monitoredInfo: accesslog</span><br><span class="line">monitoredInfo: glue</span><br><span class="line">entryDN: cn=Overlays,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: TRUE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-8-SASL"><a href="#20-4-8-SASL" class="headerlink" title="20.4.8 SASL"></a>20.4.8 SASL</h4><p>目前空</p>
<h4 id="20-4-9-Statistics"><a href="#20-4-9-Statistics" class="headerlink" title="20.4.9 Statistics"></a>20.4.9 Statistics</h4><p>它显示了服务器发送的数据的一些统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bytes</span><br><span class="line">PDU</span><br><span class="line">Entries</span><br><span class="line">Referrals</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Entries, Statistics, Monitor</span><br><span class="line">dn: cn=Entries,cn=Statistics,cn=Monitor</span><br><span class="line">structuralObjectClass: monitorCounterObject</span><br><span class="line">monitorCounter: 612248</span><br><span class="line">entryDN: cn=Entries,cn=Statistics,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-10-Threads"><a href="#20-4-10-Threads" class="headerlink" title="20.4.10 Threads"></a>20.4.10 Threads</h4><p>它包含启动时启用的最大线程数和当前的后备负载。</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Max, Threads, Monitor</span><br><span class="line">dn: cn=Max,cn=Threads,cn=Monitor</span><br><span class="line">structuralObjectClass: monitoredObject</span><br><span class="line">monitoredInfo: 16</span><br><span class="line">entryDN: cn=Max,cn=Threads,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-11-Time"><a href="#20-4-11-Time" class="headerlink" title="20.4.11 Time"></a>20.4.11 Time</h4><p>它包含两个子条目，其中包含服务器的开始时间和当前时间。</p>
<p>例如</p>
<p>开始时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Start,cn=Time,cn=Monitor</span><br><span class="line">structuralObjectClass: monitoredObject</span><br><span class="line">monitorTimestamp: 20061205124040Z</span><br><span class="line">entryDN: cn=Start,cn=Time,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<p>当前时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Current,cn=Time,cn=Monitor</span><br><span class="line">structuralObjectClass: monitoredObject</span><br><span class="line">monitorTimestamp: 20061207120624Z</span><br><span class="line">entryDN: cn=Current,cn=Time,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<h4 id="20-4-12-TLS"><a href="#20-4-12-TLS" class="headerlink" title="20.4.12 TLS"></a>20.4.12 TLS</h4><p>目前空</p>
<h3 id="20-4-13-Waiters"><a href="#20-4-13-Waiters" class="headerlink" title="20.4.13 Waiters"></a>20.4.13 Waiters</h3><p>它包含当前读取服务器的数量。</p>
<p>例如</p>
<p>读服务员：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Read,cn=Waiters,cn=Monitor</span><br><span class="line">structuralObjectClass: monitorCounterObject</span><br><span class="line">monitorCounter: 7</span><br><span class="line">entryDN: cn=Read,cn=Waiters,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<p>写服务员：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dn: cn=Write,cn=Waiters,cn=Monitor</span><br><span class="line">structuralObjectClass: monitorCounterObject</span><br><span class="line">monitorCounter: 0</span><br><span class="line">entryDN: cn=Write,cn=Waiters,cn=Monitor</span><br><span class="line">subschemaSubentry: cn=Subschema</span><br><span class="line">hasSubordinates: FALSE</span><br></pre></td></tr></table></figure>

<p>在这里添加新的监控事项，并讨论，引用手册页和示例</p>
]]></content>
      <categories>
        <category>Documents</category>
      </categories>
      <tags>
        <tag>openldap</tag>
      </tags>
  </entry>
</search>
